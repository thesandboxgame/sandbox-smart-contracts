{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-5.0.2/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-5.0.2/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-5.0.2/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-5.0.2/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-5.0.2/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-5.0.2/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {OwnableUpgradeable} from \"./OwnableUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable2Step\n    struct Ownable2StepStorage {\n        address _pendingOwner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable2Step\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant Ownable2StepStorageLocation = 0x237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00;\n\n    function _getOwnable2StepStorage() private pure returns (Ownable2StepStorage storage $) {\n        assembly {\n            $.slot := Ownable2StepStorageLocation\n        }\n    }\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable2Step_init() internal onlyInitializing {\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        return $._pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        $._pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        delete $._pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/token/common/ERC2981Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC2981Upgradeable is Initializable, IERC2981, ERC165Upgradeable {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC2981\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC2981\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n\n    /**\n     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The default royalty receiver is invalid.\n     */\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n    /**\n     * @dev The royalty set for an specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The royalty receiver for `tokenId` is invalid.\n     */\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n\n    function __ERC2981_init() internal onlyInitializing {\n    }\n\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n    struct ERC721Storage {\n        // Token name\n        string _name;\n\n        // Token symbol\n        string _symbol;\n\n        mapping(uint256 tokenId => address) _owners;\n\n        mapping(address owner => uint256) _balances;\n\n        mapping(uint256 tokenId => address) _tokenApprovals;\n\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n\n        $._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        $._tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-5.0.2/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/common/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 indexed _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 indexed _fromTokenId, uint256 indexed _toTokenId);\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/ERC2771HandlerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/utils/ContextUpgradeable.sol\";\n\n/**\n * @title ERC2771HandlerUpgradeable\n * @author The Sandbox\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice minimal ERC2771 handler to keep bytecode-size down\n * @dev based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/metatx/ERC2771Context.sol\n *      with an initializer for proxies and a mutable forwarder\n */\nabstract contract ERC2771HandlerUpgradeable is ContextUpgradeable {\n    /// @custom:storage-location erc7201:thesandbox.storage.avatar.nft-collection.ERC2771HandlerUpgradeable\n    struct ERC2771HandlerUpgradeableStorage {\n        address trustedForwarder;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"thesandbox.storage.avatar.nft-collection.ERC2771HandlerUpgradeable\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant ERC2771_HANDLER_UPGRADABLE_STORAGE_LOCATION =\n    0x269c7d123624135714769792dd28ef6db020f837bcb105cea22203ad17aa7000;\n\n    function _getERC2771HandlerUpgradableStorage() private pure returns (ERC2771HandlerUpgradeableStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC2771_HANDLER_UPGRADABLE_STORAGE_LOCATION\n        }\n    }\n\n    /**\n     * @notice emitted when the trusted forwarder is set\n     * @param operator the sender of the transaction\n     * @param oldForwarder the old trusted forwarder address\n     * @param newForwarder the new trusted forwarder address\n     */\n    event TrustedForwarderSet(address indexed operator, address indexed oldForwarder, address indexed newForwarder);\n\n\n    /**\n     * @notice set the trusted forwarder\n     * @param forwarder the new trusted forwarder address\n     * @dev address(0) disables the forwarder\n     */\n    function _setTrustedForwarder(address forwarder) internal {\n        ERC2771HandlerUpgradeableStorage storage $ = _getERC2771HandlerUpgradableStorage();\n        emit TrustedForwarderSet(_msgSender(), $.trustedForwarder, forwarder);\n        $.trustedForwarder = forwarder;\n    }\n\n    /**\n     * @notice Returns the address of the trusted forwarder.\n     * @return the trusted forwarder address\n     */\n    function trustedForwarder() external view virtual returns (address) {\n        ERC2771HandlerUpgradeableStorage storage $ = _getERC2771HandlerUpgradableStorage();\n        return $.trustedForwarder;\n    }\n\n    /**\n     * @notice Indicates whether any particular address is the trusted forwarder.\n     * @param forwarder the address ot the trusted forwarder to check\n     * @return true if forwarder is the trusted forwarder address\n     */\n    function isTrustedForwarder(address forwarder) external view virtual returns (bool) {\n        return _isTrustedForwarder(forwarder);\n    }\n\n    /**\n     * @notice Override for `msg.sender`.\n     * @return the address of the sender\n     * @dev Defaults to the original `msg.sender` whenever a call is not performed by the trusted forwarder\n     * or the calldata length is less than 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (_isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength :]));\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * @notice Override for `msg.data`.\n     * @return the message data with the address of the sender removed\n     * @dev Defaults to the original `msg.data` whenever a call is not performed by the trusted forwarder\n     * or the calldata length is less than 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (_isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[: calldataLength - contextSuffixLength];\n        } else {\n            return msg.data;\n        }\n    }\n\n    /**\n     * @notice Indicates whether any particular address is the trusted forwarder.\n     * @param forwarder the address ot the trusted forwarder to check\n     * @return true if forwarder is the trusted forwarder address\n     */\n    function _isTrustedForwarder(address forwarder) internal view virtual returns (bool) {\n        ERC2771HandlerUpgradeableStorage storage $ = _getERC2771HandlerUpgradableStorage();\n        return forwarder == $.trustedForwarder;\n    }\n\n    /**\n     * @notice ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/INFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.26;\n\nimport {IERC20} from \"@openzeppelin/contracts-5.0.2/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts-5.0.2/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title INFTCollection\n * @author The Sandbox\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice Events emitted and Error raised by the NFTCollection\n */\ninterface INFTCollection {\n    /**\n     * @notice minting can be denied because of the following reasons\n     **/\n    enum MintDenialReason {\n        None,\n        NotConfigured,\n        InvalidAmount,\n        GlobalMaxTokensPerWalletExceeded,\n        WaveMaxTokensOverallExceeded,\n        WaveMaxTokensPerWalletExceeded,\n        MaxSupplyExceeded\n    }\n\n    /**\n     * @notice Structure to hold initialization parameters\n     * @param _collectionOwner the address that will be set as the owner of the collection\n     * @param _initialBaseURI an URI that will be used as the base for token URI\n     * @param _name name of the ERC721 token\n     * @param _symbol token symbol of the ERC721 token\n     * @param _mintTreasury collection treasury address (where the payments are sent)\n     * @param _signAddress signer address that is allowed to create mint signatures\n     * @param _initialTrustedForwarder trusted forwarder address\n     * @param _allowedToExecuteMint token address that is used for payments and that is allowed to execute mint\n     * @param _maxSupply max supply of tokens to be allowed to be minted per contract\n     * @param _maxTokensPerWallet max tokens per wallet\n     */\n    struct InitializationParams {\n        address collectionOwner;\n        string initialBaseURI;\n        string name;\n        string symbol;\n        address payable mintTreasury;\n        address signAddress;\n        address initialTrustedForwarder;\n        IERC20Metadata allowedToExecuteMint;\n        uint256 maxSupply;\n        uint256 maxTokensPerWallet;\n    }\n\n    /**\n     * @notice Structure used to mint in batch\n     * @param wallet destination address that will receive the tokens\n     * @param amount of tokens to mint\n     */\n    struct BatchMintingData {\n        address wallet;\n        uint256 amount;\n    }\n\n    /**\n     * @notice Structure used save minting wave information\n     * @param waveMaxTokensOverall max tokens to buy per wave, cumulating all addresses\n     * @param waveMaxTokensPerWallet max tokens to buy, per wallet in a given wave\n     * @param waveSingleTokenPrice price of one token mint (in the token denoted by the allowedToExecuteMint contract)\n     * @param waveTotalMinted number of total minted tokens in the current running wave\n     * @param waveOwnerToClaimedCounts mapping of [owner -> minted count]\n     */\n    struct WaveData {\n        uint256 waveMaxTokensOverall;\n        uint256 waveMaxTokensPerWallet;\n        uint256 waveSingleTokenPrice;\n        uint256 waveTotalMinted;\n        mapping(address owner => uint256 count) waveOwnerToClaimedCounts;\n    }\n\n    /**\n     * @notice Event emitted when the contract was initialized.\n     * @dev emitted at proxy startup, only once\n     * @param baseURI an URI that will be used as the base for token URI\n     * @param name name of the ERC721 token\n     * @param symbol token symbol of the ERC721 token\n     * @param mintTreasury collection treasury address (where the payments are sent)\n     * @param signAddress signer address that is allowed to create mint signatures\n     * @param allowedToExecuteMint token address that is used for payments and that is allowed to execute mint\n     * @param maxSupply max supply of tokens to be allowed to be minted per contract\n     * @param maxTokensPerWallet maximum amount of tokens that can be minted per wallet across all waves\n     */\n    event ContractInitialized(\n        string indexed baseURI,\n        string indexed name,\n        string indexed symbol,\n        address mintTreasury,\n        address signAddress,\n        IERC20Metadata allowedToExecuteMint,\n        uint256 maxSupply,\n        uint256 maxTokensPerWallet\n    );\n\n    /**\n     * @notice Event emitted when a wave was set up\n     * @dev emitted when setupWave is called\n     * @param operator the sender of the transaction\n     * @param waveMaxTokens the allowed number of tokens to be minted in this wave (cumulative by all minting wallets)\n     * @param waveMaxTokensToBuy max tokens to buy, per wallet in a given wave\n     * @param waveSingleTokenPrice the price to mint a token in a given wave, in wei\n     * @param waveIndex the current wave index\n     */\n    event WaveSetup(\n        address indexed operator,\n        uint256 waveMaxTokens,\n        uint256 waveMaxTokensToBuy,\n        uint256 waveSingleTokenPrice,\n        uint256 waveIndex\n    );\n\n    /**\n     * @notice Event emitted when a wave mint is completed\n     * @param tokenId the token id\n     * @param wallet the wallet address of the receiver\n     * @param waveIndex the wave index\n     */\n    event WaveMint(uint256 tokenId, address indexed wallet, uint256 waveIndex);\n\n    /**\n     * @notice Event emitted when an address was set as allowed to mint\n     * @dev emitted when setAllowedExecuteMint is called\n     * @param operator the sender of the transaction\n     * @param oldToken old address that is used for payments and that is allowed to execute mint\n     * @param newToken new address that is used for payments and that is allowed to execute mint\n     */\n    event AllowedExecuteMintSet(address indexed operator, IERC20 indexed oldToken, IERC20 indexed newToken);\n\n    /**\n     * @notice Event emitted when the treasury address was saved\n     * @dev emitted when setTreasury is called\n     * @param operator the sender of the transaction\n     * @param oldTreasury old collection treasury address (where the payments are sent)\n     * @param newTreasury new collection treasury address (where the payments are sent)\n     */\n    event TreasurySet(address indexed operator, address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Event emitted when the base token URI for the contract was set or changed\n     * @dev emitted when setBaseURI is called\n     * @param operator the sender of the transaction\n     * @param oldBaseURI old URI that will be used as the base for token metadata URI\n     * @param newBaseURI new URI that will be used as the base for token metadata URI\n     */\n    event BaseURISet(address indexed operator, string oldBaseURI, string newBaseURI);\n\n    /**\n     * @notice Event emitted when the max supply is set or changed\n     * @dev emitted when setSignAddress is called\n     * @param operator the sender of the transaction\n     * @param oldMaxSupply old maximum amount of tokens that can be minted\n     * @param newMaxSupply new maximum amount of tokens that can be minted\n     */\n    event MaxSupplySet(address indexed operator, uint256 oldMaxSupply, uint256 newMaxSupply);\n\n    /**\n     * @notice Event emitted when a token personalization was made.\n     * @dev emitted when personalize is called\n     * @param operator the sender of the transaction\n     * @param tokenId id of the token which had the personalization done\n     * @param personalizationMask the exact personalization that was done, as a custom meaning bit-mask\n     */\n    event Personalized(address indexed operator, uint256 indexed tokenId, uint256 indexed personalizationMask);\n\n    /**\n     * @notice Event emitted when a token personalization was made.\n     * @param operator the sender of the transaction\n     * @param receiver the receiver of the royalties\n     * @param feeNumerator percentage of the royalties in feeDenominator units\n     */\n    event DefaultRoyaltySet(address indexed operator, address indexed receiver, uint96 feeNumerator);\n\n    /**\n     * @notice Event emitted when default royalties are reset\n     * @param operator the sender of the transaction\n     */\n    event DefaultRoyaltyReset(address indexed operator);\n\n    /**\n     * @notice Event emitted when a token personalization was made.\n     * @param operator the sender of the transaction\n     * @param tokenId the token id\n     * @param receiver the receiver of the royalties\n     * @param feeNumerator percentage of the royalties in feeDenominator units\n     */\n    event TokenRoyaltySet(\n        address indexed operator,\n        uint256 indexed tokenId,\n        address indexed receiver,\n        uint96 feeNumerator\n    );\n\n    /**\n     * @notice Event emitted when default royalties are reset\n     * @param operator the sender of the transaction\n     * @param tokenId the token id\n     */\n    event TokenRoyaltyReset(address indexed operator, uint256 indexed tokenId);\n\n    /**\n     * @notice Event emitted when the max tokens per wallet is set\n     * @param operator the sender of the transaction\n     * @param oldMaxTokensPerWallet old maximum tokens per wallet\n     * @param newMaxTokensPerWallet new maximum tokens per wallet\n     */\n    event MaxTokensPerWalletSet(address indexed operator, uint256 oldMaxTokensPerWallet, uint256 newMaxTokensPerWallet);\n\n    /**\n     * @notice event emitted when a token was burned\n     * @param operator the sender of the transaction\n     * @param tokenId the id of the token that was burned\n     * @param burner the owner that burned the token\n     */\n    event TokenBurned(address indexed operator, uint256 indexed tokenId, address indexed burner);\n\n    /**\n     * @notice event emitted when token burning was enabled\n     * @param operator the sender of the transaction\n     */\n    event TokenBurningEnabled(address indexed operator);\n\n    /**\n     * @notice event emitted when token burning was disabled\n     * @param operator the sender of the transaction\n     */\n    event TokenBurningDisabled(address indexed operator);\n\n    /**\n     * @notice The operation failed because the base token uri is empty.\n     * @param baseURI an URI that will be used as the base for token URI\n     */\n    error InvalidBaseTokenURI(string baseURI);\n\n    /**\n     * @notice The operation failed the wave index is zero, no wave was ever configured\n     */\n    error ContractNotConfigured();\n\n    /**\n     * @notice The operation failed because the token name is invalid\n     * @param name name of the ERC721 token\n     */\n    error InvalidName(string name);\n\n    /**\n     * @notice The operation failed because the token symbol is invalid\n     * @param symbol token symbol of the ERC721 token\n     */\n    error InvalidSymbol(string symbol);\n\n    /**\n     * @notice The operation failed because the treasury is wrong\n     * @param mintTreasury collection treasury address (where the payments are sent)\n     */\n    error InvalidTreasury(address mintTreasury);\n\n    /**\n     * @notice The operation failed because the allowedToExecuteMint is not a contract or wrong\n     * @param allowedToExecuteMint token address that is used for payments and that is allowed to execute mint\n     */\n    error InvalidAllowedToExecuteMint(IERC20Metadata allowedToExecuteMint);\n\n    /**\n     * @notice The operation failed because the maxSupply is lower than totalSupply\n     * @param maxSupply max supply of tokens to be allowed to be minted per contract\n     * @param totalSupply amount of tokens minted till now\n     */\n    error LowMaxSupply(uint256 maxSupply, uint256 totalSupply);\n\n    /**\n     * @notice The operation failed because the batch data len is zero\n     */\n    error InvalidBatchData();\n\n    /**\n     * @notice The operation failed because the wave arguments are wrong\n     * @param waveMaxTokensOverall the allowed number of tokens to be minted in this wave (cumulative by all minting wallets)\n     * @param waveMaxTokensPerWallet max tokens to buy, per wallet in a given wave\n     */\n    error InvalidWaveData(uint256 waveMaxTokensOverall, uint256 waveMaxTokensPerWallet);\n\n    /**\n     * @notice The operation failed because the wave is completed\n     * @param reason the reason for the denial\n     * @param wallet wallet to be checked if it can mint\n     * @param amount amount to be checked if can be minted\n     * @param waveIndex the current wave index\n     */\n    error CannotMint(MintDenialReason reason, address wallet, uint256 amount, uint256 waveIndex);\n\n    /**\n     * @notice The operation failed because the max tokens per wallet is invalid\n     * @param maxTokensPerWallet max tokens per wallet\n     */\n    error InvalidMaxTokensPerWallet(uint256 maxTokensPerWallet, uint256 maxSupply);\n\n    /**\n     * @notice The operation failed because the wave max tokens per wallet is higher than the global max tokens per wallet\n     * @param waveMaxTokensPerWallet wave max tokens per wallet\n     * @param maxTokensPerWallet global max tokens per wallet\n     */\n    error WaveMaxTokensHigherThanGlobalMax(uint256 waveMaxTokensPerWallet, uint256 maxTokensPerWallet);\n\n    /**\n     * @notice The operation failed because burning is enabled.\n     */\n    error EnforcedBurn();\n\n    /**\n     * @notice The operation failed because burning is disabled.\n     */\n    error ExpectedBurn();\n\n    /**\n     * @notice Event emitted when the purchase agent is set\n     * @param operator the sender of the transaction\n     * @param purchaseAgent the address of the purchase agent\n     */\n    event PurchaseAgentSet(address indexed operator, address indexed purchaseAgent);\n\n    /**\n     * @notice Event emitted when a wallet is marked as agent-controlled\n     * @param operator the sender of the transaction\n     * @param wallet the wallet address\n     * @param isAgentControlled true if the wallet is agent-controlled\n     */\n    event AgentControlledSet(address indexed operator, address indexed wallet, bool isAgentControlled);\n\n    /**\n     * @notice Mints a token for a specific wave.\n     * @param to The address to mint the token to.\n     * @param amount The amount of tokens to mint.\n     * @param waveIndex The wave index.\n     * @param signatureId The signature ID.\n     * @param signature The signature.\n     */\n    function waveMint(\n        address to,\n        uint256 amount,\n        uint256 waveIndex,\n        uint256 signatureId,\n        bytes calldata signature\n    ) external returns (uint256[] memory);\n\n    /**\n     * @notice Returns the token price for a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @return Price per token in the wave's payment token.\n     */\n    function waveSingleTokenPrice(uint256 waveIndex) external view returns (uint256);\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/ISandboxSand.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @dev Minimal interface for the SAND token contract.\n */\ninterface ISandboxSand {\n    function approveAndCall(\n        address target,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes memory);\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/NFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.26;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/access/Ownable2StepUpgradeable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/utils/ContextUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/utils/PausableUpgradeable.sol\";\nimport {ERC2981Upgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/token/common/ERC2981Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable-5.0.2/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-5.0.2/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts-5.0.2/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-5.0.2/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC4906} from \"../common/IERC4906.sol\";\nimport {UpdatableOperatorFiltererUpgradeable} from \"./UpdatableOperatorFiltererUpgradeable.sol\";\nimport {ERC2771HandlerUpgradeable} from \"./ERC2771HandlerUpgradeable.sol\";\nimport {NFTCollectionSignature} from \"./NFTCollectionSignature.sol\";\nimport {INFTCollection} from \"./INFTCollection.sol\";\n\n/**\n * @title NFTCollection\n * @author The Sandbox\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice Implements an upgradeable ERC721 contract for Avatar NFT collections.\n * @dev Implements the following features:\n * - Upgradeable proxy pattern\n * - Two-step ownership transfer\n * - OpenSea and ERC2981 royalty standards\n * - ERC4906 metadata update notifications\n * - ERC165 interface detection\n * - ERC2771 meta-transaction support\n * - Burn tracking for game access control\n * - ERC20-based minting with approveAndCall pattern\n * - Batch minting and transfer operations\n */\ncontract NFTCollection is\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable,\n    ERC721Upgradeable,\n    ERC2981Upgradeable,\n    ERC2771HandlerUpgradeable,\n    UpdatableOperatorFiltererUpgradeable,\n    PausableUpgradeable,\n    NFTCollectionSignature,\n    IERC4906,\n    INFTCollection\n{\n    /// @custom:storage-location erc7201:thesandbox.storage.avatar.nft-collection.NFTCollection\n    struct NFTCollectionStorage {\n        /**\n         * @notice Maximum supply cap for the collection.\n         */\n        uint256 maxSupply;\n        /**\n         * @notice Maximum tokens that can be minted per wallet across all waves.\n         */\n        uint256 maxTokensPerWallet;\n        /**\n         * @notice Treasury address receiving minting payments.\n         */\n        address mintTreasury;\n        /**\n         * @notice Base URI for token metadata.\n         */\n        string baseTokenURI;\n        /**\n         * @notice Array of minting wave configurations.\n         */\n        WaveData[] waveData;\n        /**\n         * @notice ERC20 token contract used for minting payments.\n         */\n        IERC20 allowedToExecuteMint;\n        /**\n         * @notice Mapping of token personalization traits.\n         */\n        mapping(uint256 tokenId => uint256 mask) personalizationTraits;\n        /**\n         * @notice Mapping of tokens minted per address.\n         */\n        mapping(address wallet => uint256 count) mintedCount;\n        /**\n         * @notice Current total supply of minted tokens.\n         */\n        uint256 totalSupply;\n        /**\n         * @notice Flag controlling token burn functionality.\n         */\n        bool isBurnEnabled;\n        /**\n         * @notice Address that can transfer tokens on behalf of agent-controlled wallets.\n         */\n        address purchaseAgent;\n        /**\n         * @notice Mapping of wallets that are controlled by the purchase agent.\n         */\n        mapping(address wallet => bool isAgentControlled) isAgentControlled;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"thesandbox.storage.avatar.nft-collection.NFTCollection\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant NFT_COLLECTION_STORAGE_LOCATION =\n        0x54137d560768c3c24834e09621a4fafd063f4a5812823197e84bcd3fbaff7d00;\n\n    function _getNFTCollectionStorage() private pure returns (NFTCollectionStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NFT_COLLECTION_STORAGE_LOCATION\n        }\n    }\n\n    /**\n     * @notice Mitigates a possible Implementation contract takeover, as indicated by\n     *         https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializing_the_implementation_contract\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the NFT collection with configuration parameters.\n     * @param params Struct containing all initialization parameters, see InitializationParams for details.\n     * @dev External initialization entry point following the upgradeable pattern.\n     */\n    function initialize(InitializationParams calldata params) external virtual initializer {\n        __NFTCollection_init(params);\n    }\n\n    /**\n     * @notice Internal initialization logic for the NFT collection.\n     * @param params Struct containing all initialization parameters, see InitializationParams for details.\n     * @dev Initializes all inherited contracts and sets initial configuration values.\n     */\n    function __NFTCollection_init(InitializationParams calldata params) internal onlyInitializing {\n        if (bytes(params.name).length == 0) {\n            revert InvalidName(params.name);\n        }\n        if (bytes(params.symbol).length == 0) {\n            revert InvalidSymbol(params.symbol);\n        }\n        __ReentrancyGuard_init();\n        __Ownable_init(params.collectionOwner);\n        __ERC2981_init();\n        _setTrustedForwarder(params.initialTrustedForwarder);\n        __ERC721_init(params.name, params.symbol);\n        __Pausable_init();\n        _setBaseURI(params.initialBaseURI);\n        _setTreasury(params.mintTreasury);\n        _setSignAddress(params.signAddress);\n        _setAllowedExecuteMint(params.allowedToExecuteMint);\n        _setMaxSupply(params.maxSupply);\n        _setMaxTokensPerWallet(params.maxTokensPerWallet);\n\n        emit ContractInitialized(\n            params.initialBaseURI,\n            params.name,\n            params.symbol,\n            params.mintTreasury,\n            params.signAddress,\n            params.allowedToExecuteMint,\n            params.maxSupply,\n            params.maxTokensPerWallet\n        );\n    }\n\n    /**\n     * @notice Creates a new minting wave.\n     * @param _waveMaxTokensOverall Maximum tokens that can be minted in this wave.\n     * @param _waveMaxTokensPerWallet Maximum tokens per wallet for this wave.\n     * @param _waveSingleTokenPrice Price per token in wave, denominated in allowedToExecuteMint token.\n     * @dev Validates wave parameters against global limits and current supply.\n     */\n    function setupWave(\n        uint256 _waveMaxTokensOverall,\n        uint256 _waveMaxTokensPerWallet,\n        uint256 _waveSingleTokenPrice\n    ) external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (\n            _waveMaxTokensOverall > $.maxSupply ||\n            _waveMaxTokensOverall == 0 ||\n            _waveMaxTokensPerWallet == 0 ||\n            _waveMaxTokensPerWallet > _waveMaxTokensOverall\n        ) {\n            revert InvalidWaveData(_waveMaxTokensOverall, _waveMaxTokensPerWallet);\n        }\n        if (_waveMaxTokensPerWallet > $.maxTokensPerWallet) {\n            revert WaveMaxTokensHigherThanGlobalMax(_waveMaxTokensPerWallet, $.maxTokensPerWallet);\n        }\n        uint256 waveIndex = $.waveData.length;\n        emit WaveSetup(_msgSender(), _waveMaxTokensOverall, _waveMaxTokensPerWallet, _waveSingleTokenPrice, waveIndex);\n        $.waveData.push();\n        $.waveData[waveIndex].waveMaxTokensOverall = _waveMaxTokensOverall;\n        $.waveData[waveIndex].waveMaxTokensPerWallet = _waveMaxTokensPerWallet;\n        $.waveData[waveIndex].waveSingleTokenPrice = _waveSingleTokenPrice;\n    }\n\n    /**\n     * @notice Mints tokens using the latest wave configuration.\n     * @param wallet Address receiving the minted tokens.\n     * @param amount Number of tokens to mint.\n     * @param signatureId Unique identifier for the minting signature.\n     * @param signature Cryptographic signature authorizing the mint.\n     * @dev Only callable by allowedToExecuteMint contract. Uses the most recent wave configuration.\n     */\n    function mint(\n        address wallet,\n        uint256 amount,\n        uint256 signatureId,\n        bytes calldata signature\n    ) external whenNotPaused nonReentrant {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        uint256 wavesLength = $.waveData.length;\n        if (wavesLength == 0) {\n            revert ContractNotConfigured();\n        }\n        if (_msgSender() != address($.allowedToExecuteMint)) {\n            revert ERC721InvalidSender(_msgSender());\n        }\n        _checkAndSetMintSignature(wallet, signatureId, signature);\n        // pick the last wave\n        uint256 waveIndex = wavesLength - 1;\n        WaveData storage waveData = $.waveData[waveIndex];\n        _doMint(waveData, wallet, amount, waveIndex);\n    }\n\n    /**\n     * @notice Mints tokens using a specific wave configuration.\n     * @param wallet Address receiving the minted tokens.\n     * @param amount Number of tokens to mint.\n     * @param waveIndex Index of the wave configuration to use.\n     * @param signatureId Unique identifier for the minting signature.\n     * @param signature Cryptographic signature authorizing the mint.\n     * @dev Only callable by allowedToExecuteMint contract.\n     */\n    function waveMint(\n        address wallet,\n        uint256 amount,\n        uint256 waveIndex,\n        uint256 signatureId,\n        bytes calldata signature\n    ) external whenNotPaused nonReentrant returns (uint256[] memory) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if ($.waveData.length == 0) {\n            revert ContractNotConfigured();\n        }\n        if (_msgSender() != address($.allowedToExecuteMint)) {\n            revert ERC721InvalidSender(_msgSender());\n        }\n        _checkAndSetWaveMintSignature(wallet, waveIndex, signatureId, signature);\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return _doMint(waveData, wallet, amount, waveIndex);\n    }\n\n    /**\n     * @notice Deactivates a minting wave by setting its maximum tokens to zero.\n     * @param waveIndex Index of the wave to cancel.\n     * @dev Cannot cancel the most recent wave to prevent disruption of mint function.\n     */\n    function cancelWave(uint256 waveIndex) external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        /// @dev don't use _getWaveData, we don't want to cancel the last wave by mistake\n        if (waveIndex >= $.waveData.length) {\n            revert ContractNotConfigured();\n        }\n        $.waveData[waveIndex].waveMaxTokensOverall = 0;\n    }\n\n    /**\n     * @notice Performs batch minting for multiple addresses.\n     * @param waveIndex Index of the wave configuration to use.\n     * @param wallets Array of recipient addresses and mint amounts.\n     * @dev Owner-only function for airdrops. Bypasses wave restrictions but respects maxSupply.\n     */\n    function batchMint(uint256 waveIndex, BatchMintingData[] calldata wallets) external whenNotPaused onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        uint256 len = wallets.length;\n        if (len == 0) {\n            revert InvalidBatchData();\n        }\n        if ($.waveData.length == 0) {\n            revert ContractNotConfigured();\n        }\n        for (uint256 i; i < len; i++) {\n            uint256 _totalSupply = $.totalSupply;\n            address wallet = wallets[i].wallet;\n            uint256 amount = wallets[i].amount;\n            if (amount == 0) {\n                revert CannotMint(MintDenialReason.InvalidAmount, wallet, amount, waveIndex);\n            }\n            if ($.totalSupply + amount > $.maxSupply) {\n                revert CannotMint(MintDenialReason.MaxSupplyExceeded, wallet, amount, waveIndex);\n            }\n            for (uint256 j; j < amount; j++) {\n                // @dev _mint already checks the destination wallet\n                // @dev start with tokenId = 1\n                _mint(wallet, _totalSupply + j + 1);\n                emit WaveMint(_totalSupply + j + 1, wallet, waveIndex);\n            }\n            $.totalSupply += amount;\n        }\n    }\n\n    /**\n     * @notice Triggers metadata refresh for a specific token.\n     * @param tokenId ID of the token to refresh.\n     * @param signatureId Unique identifier for the reveal signature.\n     * @param signature Cryptographic signature authorizing the reveal.\n     * @dev Emits MetadataUpdate for marketplace integration. Caller must be token owner.\n     */\n    function reveal(uint256 tokenId, uint256 signatureId, bytes calldata signature) external whenNotPaused {\n        address sender = _msgSender();\n        address owner = ownerOf(tokenId);\n        if (owner != sender) {\n            revert ERC721IncorrectOwner(sender, tokenId, owner);\n        }\n        _checkAndSetRevealSignature(sender, signatureId, signature);\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @notice Updates token traits using a bit mask.\n     * @param tokenId ID of the token to personalize.\n     * @param personalizationMask Bit mask encoding trait configurations.\n     * @param signatureId Unique identifier for the personalization signature.\n     * @param signature Cryptographic signature authorizing the personalization.\n     * @dev Caller must be token owner. Emits MetadataUpdate event.\n     */\n    function personalize(\n        uint256 tokenId,\n        uint256 personalizationMask,\n        uint256 signatureId,\n        bytes calldata signature\n    ) external whenNotPaused {\n        address sender = _msgSender();\n        address owner = ownerOf(tokenId);\n        if (owner != sender) {\n            revert ERC721IncorrectOwner(sender, tokenId, owner);\n        }\n        _checkAndSetPersonalizationSignature(sender, tokenId, personalizationMask, signatureId, signature);\n        _updateTokenTraits(tokenId, personalizationMask);\n    }\n\n    /**\n     * @notice Updates token traits with privileged access.\n     * @param tokenId ID of the token to personalize.\n     * @param personalizationMask Bit mask encoding trait configurations.\n     * @dev Owner-only function for game-driven trait updates.\n     */\n    function operatorPersonalize(uint256 tokenId, uint256 personalizationMask) external onlyOwner {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        _updateTokenTraits(tokenId, personalizationMask);\n    }\n\n    /**\n     * @notice Burns a token.\n     * @param tokenId ID of the token to burn.\n     * @dev Requires burning to be enabled. Caller must own or be approved for token.\n     */\n    function burn(uint256 tokenId) external whenNotPaused {\n        _burnWithCheck(tokenId);\n    }\n\n    /**\n     * @notice Enables token burning functionality.\n     * @dev Reverts if burning is already enabled. Only callable by owner.\n     */\n    function enableBurning() external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if ($.isBurnEnabled) {\n            revert EnforcedBurn();\n        }\n        $.isBurnEnabled = true;\n        emit TokenBurningEnabled(_msgSender());\n    }\n\n    /**\n     * @notice Disables token burning functionality.\n     * @dev Reverts if burning is already disabled. Only callable by owner.\n     */\n    function disableBurning() external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (!$.isBurnEnabled) {\n            revert ExpectedBurn();\n        }\n        $.isBurnEnabled = false;\n        emit TokenBurningDisabled(_msgSender());\n    }\n\n    /**\n     * @notice Pauses all token operations.\n     * @dev Reverts if contract is already paused. Only callable by owner.\n     */\n    function pause() external onlyOwner {\n        _requireNotPaused();\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses all token operations.\n     * @dev Reverts if contract is not paused. Only callable by owner.\n     */\n    function unpause() external onlyOwner {\n        _requirePaused();\n        _unpause();\n    }\n\n    /**\n     * @notice Updates the treasury address for minting payments.\n     * @param treasury New treasury address.\n     * @dev Reverts if treasury address is zero. Only callable by owner.\n     */\n    function setTreasury(address treasury) external onlyOwner {\n        _setTreasury(treasury);\n    }\n\n    /**\n     * @notice Updates the signing address for validating operations.\n     * @param _signAddress New signer address.\n     * @dev Only callable by owner.\n     */\n    function setSignAddress(address _signAddress) external onlyOwner {\n        _setSignAddress(_signAddress);\n    }\n\n    /**\n     * @notice Updates the maximum supply cap.\n     * @param _maxSupply New maximum token supply.\n     * @dev Must be greater than current supply. Only callable by owner.\n     */\n    function setMaxSupply(uint256 _maxSupply) external onlyOwner {\n        _setMaxSupply(_maxSupply);\n    }\n\n    /**\n     * @notice Updates the maximum tokens per wallet limit.\n     * @param _maxTokensPerWallet New maximum tokens per wallet.\n     * @dev Must be greater than zero and less than maxSupply. Only callable by owner.\n     */\n    function setMaxTokensPerWallet(uint256 _maxTokensPerWallet) external onlyOwner {\n        _setMaxTokensPerWallet(_maxTokensPerWallet);\n    }\n\n    /**\n     * @notice Updates the ERC20 token contract used for minting payments.\n     * @param minterToken Address of the ERC20 token contract.\n     * @dev Must be a valid contract address. Only callable by owner.\n     */\n    function setAllowedExecuteMint(IERC20Metadata minterToken) external onlyOwner {\n        _setAllowedExecuteMint(minterToken);\n    }\n\n    /**\n     * @notice Updates the base URI for token metadata.\n     * @param baseURI New base URI string.\n     * @dev Emits BatchMetadataUpdate for the entire collection. Only callable by owner.\n     */\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n        // Refreshes the whole collection (https://docs.opensea.io/docs/metadata-standards#metadata-updates)\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    /**\n     * @notice Sets the operator filter registry address.\n     * @param registry Address of the registry contract.\n     * @dev Used for marketplace filtering. Only callable by owner.\n     */\n    function setOperatorRegistry(address registry) external virtual onlyOwner {\n        _setOperatorRegistry(registry);\n    }\n\n    /**\n     * @notice Updates the trusted forwarder for meta-transactions.\n     * @param forwarder New forwarder address.\n     * @dev Set to address(0) to disable meta-transactions. Only callable by owner.\n     */\n    function setTrustedForwarder(address forwarder) external virtual onlyOwner {\n        _setTrustedForwarder(forwarder);\n    }\n\n    /**\n     * @notice Registers the contract with OpenSea's operator filter registry.\n     * @param subscriptionOrRegistrantToCopy Address to copy or subscribe to.\n     * @param subscribe True to subscribe, false to copy the list.\n     * @dev Pass address(0) to register without subscription. Only callable by owner.\n     */\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyOwner {\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /**\n     * @notice Sets the purchase agent address.\n     * @param _purchaseAgent The address of the purchase agent.\n     * @dev Only callable by owner.\n     */\n    function setPurchaseAgent(address _purchaseAgent) external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        emit PurchaseAgentSet(_msgSender(), _purchaseAgent);\n        $.purchaseAgent = _purchaseAgent;\n    }\n\n    /**\n     * @notice Sets wallets as agent-controlled by the purchase agent.\n     * @param wallets The wallet addresses.\n     * @param agentControlledFlags Flags indicating if wallets are agent-controlled.\n     * @dev Only callable by owner.\n     */\n    function setBatchAgentControlled(\n        address[] calldata wallets,\n        bool[] calldata agentControlledFlags\n    ) external onlyOwner {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (wallets.length != agentControlledFlags.length) {\n            revert InvalidBatchData();\n        }\n        for (uint256 i; i < wallets.length; ++i) {\n            $.isAgentControlled[wallets[i]] = agentControlledFlags[i];\n            emit AgentControlledSet(_msgSender(), wallets[i], agentControlledFlags[i]);\n        }\n    }\n\n    /**\n     * @notice Safely transfers multiple tokens between addresses.\n     * @param from Source address.\n     * @param to Destination address.\n     * @param ids Array of token IDs to transfer.\n     * @param data Additional data for receiver callback.\n     * @dev Verifies receiver contract compatibility. Requires approval or ownership.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external virtual whenNotPaused onlyAllowedOperator(from) {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address msgSender = _msgSender();\n        uint256 numTokens = ids.length;\n        for (uint256 i; i < numTokens; i++) {\n            uint256 tokenId = ids[i];\n            // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n            // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n            address previousOwner = _update(to, tokenId, msgSender);\n            if (previousOwner != from) {\n                revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n            }\n            _checkOnERC721ReceivedImpl(from, to, tokenId, data);\n        }\n    }\n\n    /**\n     * @notice Transfers multiple tokens between addresses.\n     * @param from Source address.\n     * @param to Destination address.\n     * @param ids Array of token IDs to transfer.\n     * @dev Requires approval or ownership. Does not verify receiver compatibility.\n     */\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids\n    ) external virtual whenNotPaused onlyAllowedOperator(from) {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address msgSender = _msgSender();\n        uint256 numTokens = ids.length;\n        for (uint256 i; i < numTokens; i++) {\n            uint256 tokenId = ids[i];\n            // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n            // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n            address previousOwner = _update(to, tokenId, msgSender);\n            if (previousOwner != from) {\n                revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets default royalty information for all tokens.\n     * @param receiver Royalty recipient address.\n     * @param feeNumerator Royalty fee in basis points.\n     * @dev Only callable by owner.\n     */\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {\n        /// @dev ERC2981Upgradeable don't emit and don't give access to the old value\n        emit DefaultRoyaltySet(_msgSender(), receiver, feeNumerator);\n        _setDefaultRoyalty(receiver, feeNumerator);\n    }\n\n    /**\n     * @notice Removes default royalty configuration.\n     * @dev Only callable by owner.\n     */\n    function resetDefaultRoyalty() external onlyOwner {\n        /// @dev ERC2981Upgradeable don't emit and don't give access to the old value\n        emit DefaultRoyaltyReset(_msgSender());\n        _deleteDefaultRoyalty();\n    }\n\n    /**\n     * @notice Sets royalty information for a specific token.\n     * @param tokenId Token ID to configure.\n     * @param receiver Royalty recipient address.\n     * @param feeNumerator Royalty fee in basis points.\n     * @dev Overrides default royalty for the specified token. Only callable by owner.\n     */\n    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external onlyOwner {\n        /// @dev ERC2981Upgradeable don't emit and don't give access to the old value\n        emit TokenRoyaltySet(_msgSender(), tokenId, receiver, feeNumerator);\n        _setTokenRoyalty(tokenId, receiver, feeNumerator);\n    }\n\n    /**\n     * @notice Resets token-specific royalty configuration.\n     * @param tokenId Token ID to reset.\n     * @dev Returns token to default royalty configuration. Only callable by owner.\n     */\n    function resetTokenRoyalty(uint256 tokenId) external onlyOwner {\n        /// @dev ERC2981Upgradeable don't emit and don't give access to the old value\n        emit TokenRoyaltyReset(_msgSender(), tokenId);\n        _resetTokenRoyalty(tokenId);\n    }\n\n    /**\n     * @notice Retrieves personalization traits for a token.\n     * @param tokenId Token ID to query.\n     * @return Bit mask of token's personalization traits.\n     */\n    function personalizationOf(uint256 tokenId) external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.personalizationTraits[tokenId];\n    }\n\n    /**\n     * @notice Returns the number of tokens minted by an address.\n     * @param wallet Address to query.\n     * @return Number of tokens minted by the address.\n     */\n    function mintedCount(address wallet) external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.mintedCount[wallet];\n    }\n\n    /**\n     * @notice Checks if an address can mint tokens in a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @param wallet Address to check.\n     * @param amount Number of tokens to check.\n     * @return Reason code indicating mint permission status.\n     */\n    function isMintDenied(uint256 waveIndex, address wallet, uint256 amount) external view returns (MintDenialReason) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (waveIndex >= $.waveData.length) {\n            return MintDenialReason.NotConfigured;\n        }\n        WaveData storage waveData = $.waveData[waveIndex];\n        return _isMintDenied($, waveData, wallet, amount);\n    }\n\n    /**\n     * @notice Returns the fee denominator for royalty calculations.\n     * @return Fee denominator value (10000 for basis points).\n     * @dev Used in conjunction with royalty fee numerator.\n     */\n    function feeDenominator() external pure virtual returns (uint96) {\n        return _feeDenominator();\n    }\n\n    /**\n     * @notice Returns the current chain ID.\n     * @return Current blockchain network ID.\n     */\n    function chain() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Returns the maximum token supply cap.\n     * @return Maximum number of tokens that can be minted.\n     */\n    function maxSupply() external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.maxSupply;\n    }\n\n    /**\n     * @notice Returns the treasury address for minting payments.\n     * @return Address receiving minting payments.\n     */\n    function mintTreasury() external view returns (address) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.mintTreasury;\n    }\n\n    /**\n     * @notice Returns the base URI for token metadata.\n     * @return Base URI string.\n     */\n    function baseTokenURI() external view returns (string memory) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.baseTokenURI;\n    }\n\n    /**\n     * @notice Returns the maximum tokens allowed for a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @return Maximum tokens allowed in the wave.\n     */\n    function waveMaxTokensOverall(uint256 waveIndex) external view returns (uint256) {\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return waveData.waveMaxTokensOverall;\n    }\n\n    /**\n     * @notice Returns the maximum tokens per wallet for a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @return Maximum tokens allowed per wallet in the wave.\n     */\n    function waveMaxTokensPerWallet(uint256 waveIndex) external view returns (uint256) {\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return waveData.waveMaxTokensPerWallet;\n    }\n\n    /**\n     * @notice Returns the token price for a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @return Price per token in the wave's payment token.\n     */\n    function waveSingleTokenPrice(uint256 waveIndex) external view returns (uint256) {\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return waveData.waveSingleTokenPrice;\n    }\n\n    /**\n     * @notice Returns the total tokens minted in a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @return Total tokens minted in the wave.\n     */\n    function waveTotalMinted(uint256 waveIndex) external view returns (uint256) {\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return waveData.waveTotalMinted;\n    }\n\n    /**\n     * @notice Returns the number of tokens minted by an address in a specific wave.\n     * @param waveIndex Wave configuration index.\n     * @param owner Address to query.\n     * @return Number of tokens minted by the address in the wave.\n     */\n    function waveOwnerToClaimedCounts(uint256 waveIndex, address owner) external view returns (uint256) {\n        WaveData storage waveData = _getWaveData(waveIndex);\n        return waveData.waveOwnerToClaimedCounts[owner];\n    }\n\n    /**\n     * @notice Returns the total number of configured waves.\n     * @return Number of minting waves configured.\n     */\n    function waveCount() external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.waveData.length;\n    }\n\n    /**\n     * @notice Returns the ERC20 token used for minting payments.\n     * @return Address of the payment token contract.\n     */\n    function allowedToExecuteMint() external view returns (IERC20) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.allowedToExecuteMint;\n    }\n\n    /**\n     * @notice Returns the global maximum tokens per wallet limit.\n     * @return Maximum tokens allowed per wallet across all waves.\n     */\n    function maxTokensPerWallet() external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.maxTokensPerWallet;\n    }\n\n    /**\n     * @notice Returns the current total supply of minted tokens.\n     * @return Current number of minted tokens.\n     */\n    function totalSupply() external view returns (uint256) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.totalSupply;\n    }\n\n    /**\n     * @notice Returns the burn functionality status.\n     * @return True if token burning is enabled.\n     */\n    function isBurnEnabled() external view returns (bool) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.isBurnEnabled;\n    }\n\n    /**\n     * @notice Returns the purchase agent address.\n     * @return Address that can transfer tokens on behalf of agent-controlled wallets.\n     */\n    function purchaseAgent() external view returns (address) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.purchaseAgent;\n    }\n\n    /**\n     * @notice Returns if a wallet is controlled by the purchase agent.\n     * @param wallet The address to check.\n     * @return True if the wallet is controlled by the purchase agent.\n     */\n    function isAgentControlled(address wallet) external view returns (bool) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.isAgentControlled[wallet];\n    }\n\n    /**\n     * @notice Sets approval for an operator to manage caller's tokens.\n     * @param operator Address to grant approval to.\n     * @param approved True to approve, false to revoke.\n     * @dev Overrides ERC721 implementation to add operator filtering.\n     */\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) public override whenNotPaused onlyAllowedOperatorApproval(operator) {\n        super.setApprovalForAll(operator, approved);\n    }\n\n    /**\n     * @notice Approves an operator to transfer a specific token.\n     * @param operator Address to grant approval to.\n     * @param tokenId ID of token to approve.\n     * @dev Overrides ERC721 implementation to add operator filtering.\n     */\n    function approve(\n        address operator,\n        uint256 tokenId\n    ) public override whenNotPaused onlyAllowedOperatorApproval(operator) {\n        super.approve(operator, tokenId);\n    }\n\n    /**\n     * @notice Transfers a token between addresses.\n     * @param from Source address.\n     * @param to Destination address.\n     * @param tokenId ID of token to transfer.\n     * @dev Overrides ERC721 implementation to add operator filtering.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override whenNotPaused onlyAllowedOperator(from) {\n        super.transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @notice Safely transfers a token between addresses.\n     * @param from Source address.\n     * @param to Destination address.\n     * @param tokenId ID of token to transfer.\n     * @param data Additional data for receiver callback.\n     * @dev Overrides ERC721 implementation to add operator filtering.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override whenNotPaused onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @notice Checks interface support using ERC165.\n     * @param interfaceId Interface identifier to check.\n     * @return True if interface is supported.\n     * @dev Adds support for ERC4906 interface.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC2981Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Internal function to perform minting operations.\n     * @param waveData Wave configuration data.\n     * @param wallet Address receiving tokens.\n     * @param amount Number of tokens to mint.\n     * @param waveIndex Wave configuration index.\n     * @dev Handles payment processing and token minting.\n     */\n    function _doMint(\n        WaveData storage waveData,\n        address wallet,\n        uint256 amount,\n        uint256 waveIndex\n    ) internal returns (uint256[] memory) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        MintDenialReason reason = _isMintDenied($, waveData, wallet, amount);\n        if (reason != MintDenialReason.None) {\n            revert CannotMint(reason, wallet, amount, waveIndex);\n        }\n        uint256 _price = waveData.waveSingleTokenPrice * amount;\n        if (_price > 0) {\n            SafeERC20.safeTransferFrom($.allowedToExecuteMint, wallet, $.mintTreasury, _price);\n        }\n        uint256 _totalSupply = $.totalSupply;\n        waveData.waveOwnerToClaimedCounts[wallet] += amount;\n        waveData.waveTotalMinted += amount;\n        $.totalSupply += amount;\n        $.mintedCount[wallet] += amount;\n        uint256[] memory tokenIds = new uint256[](amount);\n        for (uint256 i; i < amount; i++) {\n            // @dev _safeMint already checks the destination _wallet\n            // @dev start with tokenId = 1\n            tokenIds[i] = _totalSupply + i + 1;\n            _safeMint(wallet, tokenIds[i]);\n            emit WaveMint(tokenIds[i], wallet, waveIndex);\n        }\n        return tokenIds;\n    }\n\n    /**\n     * @notice Updates the treasury address.\n     * @param _treasury New treasury address.\n     * @dev Validates address is non-zero and emits update event.\n     */\n    function _setTreasury(address _treasury) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (_treasury == address(0)) {\n            revert InvalidTreasury(_treasury);\n        }\n        emit TreasurySet(_msgSender(), $.mintTreasury, _treasury);\n        $.mintTreasury = _treasury;\n    }\n\n    /**\n     * @notice Updates the allowed minting token.\n     * @param _minterToken New ERC20 token for minting payments.\n     * @dev Validates contract address and emits update event.\n     */\n    function _setAllowedExecuteMint(IERC20Metadata _minterToken) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (!_isContract(address(_minterToken))) {\n            revert InvalidAllowedToExecuteMint(_minterToken);\n        }\n        emit AllowedExecuteMintSet(_msgSender(), $.allowedToExecuteMint, _minterToken);\n        $.allowedToExecuteMint = _minterToken;\n    }\n\n    /**\n     * @notice Updates the maximum supply cap.\n     * @param _maxSupply New maximum token supply.\n     * @dev Validates against current supply and emits update event.\n     */\n    function _setMaxSupply(uint256 _maxSupply) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (_maxSupply == 0) {\n            revert LowMaxSupply(0, $.totalSupply);\n        }\n        if (_maxSupply < $.totalSupply) {\n            revert LowMaxSupply(_maxSupply, $.totalSupply);\n        }\n        emit MaxSupplySet(_msgSender(), $.maxSupply, _maxSupply);\n        $.maxSupply = _maxSupply;\n    }\n\n    /**\n     * @notice Updates the maximum tokens per wallet.\n     * @param _maxTokensPerWallet New maximum tokens per wallet.\n     * @dev Validates against maxSupply and emits update event.\n     */\n    function _setMaxTokensPerWallet(uint256 _maxTokensPerWallet) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (_maxTokensPerWallet == 0 || _maxTokensPerWallet > $.maxSupply) {\n            revert InvalidMaxTokensPerWallet(_maxTokensPerWallet, $.maxSupply);\n        }\n        emit MaxTokensPerWalletSet(_msgSender(), $.maxTokensPerWallet, _maxTokensPerWallet);\n        $.maxTokensPerWallet = _maxTokensPerWallet;\n    }\n\n    /**\n     * @notice Burns a token with validation checks.\n     * @param tokenId Token ID to burn.\n     * @dev Verifies burn is enabled and caller is authorized.\n     */\n    function _burnWithCheck(uint256 tokenId) internal virtual {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (!$.isBurnEnabled) {\n            revert ExpectedBurn();\n        }\n        address sender = _msgSender();\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(address(0), tokenId, sender);\n        emit TokenBurned(sender, tokenId, previousOwner);\n    }\n\n    /**\n     * @notice Updates token personalization traits.\n     * @param tokenId Token ID to update.\n     * @param personalizationMask New trait configuration.\n     * @dev No input validation - calling functions must perform checks.\n     */\n    function _updateTokenTraits(uint256 tokenId, uint256 personalizationMask) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        $.personalizationTraits[tokenId] = personalizationMask;\n        emit Personalized(_msgSender(), tokenId, personalizationMask);\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @notice Updates the base token URI.\n     * @param baseURI New base URI for token metadata.\n     * @dev Validates URI length and emits update event.\n     */\n    function _setBaseURI(string calldata baseURI) internal {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        if (bytes(baseURI).length == 0) {\n            revert InvalidBaseTokenURI(baseURI);\n        }\n        emit BaseURISet(_msgSender(), $.baseTokenURI, baseURI);\n        $.baseTokenURI = baseURI;\n    }\n\n    /**\n     * @dev See {ERC721-_isAuthorized}.\n     *\n     * Overridden to allow the `purchaseAgent` to transfer tokens from `isAgentControlled` wallets.\n     */\n    function _isAuthorized(\n        address owner,\n        address spender,\n        uint256 tokenId\n    ) internal view virtual override(ERC721Upgradeable) returns (bool) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        // The purchaseAgent can spend tokens from agent-controlled wallets.\n        if ($.purchaseAgent != address(0) && spender == $.purchaseAgent && $.isAgentControlled[owner]) {\n            return true;\n        }\n        return super._isAuthorized(owner, spender, tokenId);\n    }\n\n    /**\n     * @notice Internal function to check minting permissions.\n     * @param $ Storage pointer.\n     * @param waveData Wave configuration data.\n     * @param wallet Address attempting to mint.\n     * @param amount Number of tokens requested.\n     * @return Reason code indicating mint permission status.\n     */\n    function _isMintDenied(\n        NFTCollectionStorage storage $,\n        WaveData storage waveData,\n        address wallet,\n        uint256 amount\n    ) internal view returns (MintDenialReason) {\n        if ($.mintedCount[wallet] + amount > $.maxTokensPerWallet) {\n            return MintDenialReason.GlobalMaxTokensPerWalletExceeded;\n        }\n        if (amount == 0) {\n            return MintDenialReason.InvalidAmount;\n        }\n        if (waveData.waveTotalMinted + amount > waveData.waveMaxTokensOverall) {\n            return MintDenialReason.WaveMaxTokensOverallExceeded;\n        }\n        if (waveData.waveOwnerToClaimedCounts[wallet] + amount > waveData.waveMaxTokensPerWallet) {\n            return MintDenialReason.WaveMaxTokensPerWalletExceeded;\n        }\n        if ($.totalSupply + amount > $.maxSupply) {\n            return MintDenialReason.MaxSupplyExceeded;\n        }\n        return MintDenialReason.None;\n    }\n\n    /**\n     * @notice Helper function to retrieve wave data by index.\n     * @param waveIndex Index of the wave configuration.\n     * @return waveData Storage pointer to the wave configuration.\n     * @dev Accepts indices >= waveData.length to access the latest wave.\n     */\n    function _getWaveData(uint256 waveIndex) internal view returns (WaveData storage) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        uint256 waveDataLen = $.waveData.length;\n        if (waveIndex >= waveDataLen) {\n            waveIndex = waveDataLen - 1;\n        }\n        return $.waveData[waveIndex];\n    }\n\n    /**\n     * @notice Returns the base URI for token metadata.\n     * @return Base URI string for token metadata.\n     * @dev Internal implementation of ERC721 _baseURI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        NFTCollectionStorage storage $ = _getNFTCollectionStorage();\n        return $.baseTokenURI;\n    }\n\n    /**\n     * @notice Returns the message data for meta-transactions.\n     * @return Message data with meta-transaction context.\n     * @dev ERC2771 compatible msg.data getter.\n     */\n    function _msgData() internal view override(ContextUpgradeable, ERC2771HandlerUpgradeable) returns (bytes calldata) {\n        return ERC2771HandlerUpgradeable._msgData();\n    }\n\n    /**\n     * @notice Returns the message sender for meta-transactions.\n     * @return sender Effective message sender accounting for meta-transactions.\n     * @dev ERC2771 compatible msg.sender getter.\n     */\n    function _msgSender()\n        internal\n        view\n        override(\n            ContextUpgradeable,\n            ERC2771HandlerUpgradeable,\n            UpdatableOperatorFiltererUpgradeable,\n            NFTCollectionSignature\n        )\n        returns (address sender)\n    {\n        sender = ERC2771HandlerUpgradeable._msgSender();\n    }\n\n    /**\n     * @notice Returns the context suffix length for meta-transactions.\n     * @return Length of the meta-transaction context (20 bytes for address).\n     * @dev ERC2771 specification implementation.\n     */\n    function _contextSuffixLength()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771HandlerUpgradeable)\n        returns (uint256)\n    {\n        return ERC2771HandlerUpgradeable._contextSuffixLength();\n    }\n\n    /**\n     * @notice Checks if an address is a contract.\n     * @param account Address to check.\n     * @return True if the address contains code.\n     * @dev Can be bypassed if called during contract construction.\n     */\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n\n    /**\n     * @notice Validates ERC721 receiver implementation.\n     * @param from Source address.\n     * @param to Destination address.\n     * @param tokenId Token ID being transferred.\n     * @param data Additional transfer data.\n     * @dev Reverts if receiver contract does not implement IERC721Receiver.\n     */\n    function _checkOnERC721ReceivedImpl(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/NFTCollectionSignature.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.26;\n\nimport {ECDSA} from \"@openzeppelin/contracts-5.0.2/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title NFTCollectionSignature\n * @author The Sandbox\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice Signatures accepted by the NFTCollection\n * @dev We have a set of different signatures to be backward compatible with previous collections\n * @dev We must be sure that all the signatures are different and cannot be reused by different methods, so,\n * @dev we added an extra constant string to reveal to distinguish it from the mint signature.\n * @dev mint:           ['address', 'uint256', 'address', 'uint256']\n * @dev reveal:         ['address', 'uint256', 'address', 'uint256', 'string']\n * @dev personalize:    ['address', 'uint256', 'address', 'uint256', 'uint256', 'uint256']\n * @dev waveMint:       ['address', 'uint256', 'uint256', 'address', 'uint256']\n */\nabstract contract NFTCollectionSignature {\n    enum SignatureType {\n        Unused,\n        Mint,\n        Personalization,\n        Reveal,\n        WaveMint\n    }\n\n    /// @custom:storage-location erc7201:thesandbox.storage.avatar.nft-collection.NFTCollectionSignature\n    struct NFTCollectionSignatureStorage {\n\n        /**\n          * @notice all signatures must come from this specific address, otherwise they are invalid\n          */\n        address signAddress;\n\n        /**\n         * @notice map used to mark if a specific signatureId was used\n         *      values are 0 (default, unused) and 1 (used)\n         *      Used to avoid a signature reuse\n         */\n        mapping(uint256 signatureId => SignatureType signatureType) signatureIds;\n    }\n\n    /**\n     * @notice Event emitted when the signer address was set or changed\n     * @dev emitted when setSignAddress is called\n     * @param operator the sender of the transaction\n     * @param oldSignAddress old signer address that is allowed to create mint signatures\n     * @param newSignAddress new signer address that is allowed to create mint signatures\n     */\n    event SignAddressSet(address indexed operator, address indexed oldSignAddress, address indexed newSignAddress);\n\n    /**\n     * @notice The operation failed because signature is invalid or it was already used\n     * @param signatureId the ID of the provided signature\n     */\n    error InvalidSignature(uint256 signatureId);\n\n    /**\n     * @notice The operation failed because the signAddress is wrong\n     * @param signAddress signer address that is allowed to create mint signatures\n     */\n    error InvalidSignAddress(address signAddress);\n\n    // keccak256(abi.encode(uint256(keccak256(\"thesandbox.storage.avatar.nft-collection.NFTCollectionSignature\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant NFT_COLLECTION_SIGNATURE_STORAGE_LOCATION =\n    0x40778db7ee4c29e622e04906f2c4ade86f805ca9734a7b64bb0f84f333357900;\n\n    function _getNFTCollectionSignatureStorage() private pure returns (NFTCollectionSignatureStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NFT_COLLECTION_SIGNATURE_STORAGE_LOCATION\n        }\n    }\n\n    /**\n      * @notice return the address from which all signatures must come from this specific address, otherwise they are invalid\n      * @return the signer address\n      */\n    function signAddress() external view returns (address) {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        return $.signAddress;\n    }\n\n    /**\n     * @notice returns the type of signature used for a specific Id\n     * @param signatureId signing signature ID\n     * @return the type of signature used\n     */\n    function getSignatureType(uint256 signatureId) external view returns (SignatureType) {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        return $.signatureIds[signatureId];\n    }\n\n    /**\n     * @notice updates the sign address.\n     * @param _signAddress new signer address to be set\n     */\n    function _setSignAddress(address _signAddress) internal {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        if (_signAddress == address(0)) {\n            revert InvalidSignAddress(_signAddress);\n        }\n        emit SignAddressSet(_msgSender(), $.signAddress, _signAddress);\n        $.signAddress = _signAddress;\n    }\n\n    /**\n     * @notice checks that the provided signature is valid, while also taking into\n     *         consideration the provided address and signatureId.\n     * @param wallet address to be used in validating the signature\n     * @param signatureId signing signature ID\n     * @param signature signing signature value\n     */\n    function _checkAndSetMintSignature(\n        address wallet,\n        uint256 signatureId,\n        bytes calldata signature\n    ) internal {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        if ($.signatureIds[signatureId] != SignatureType.Unused\n            || _getMintSignature(wallet, signatureId, address(this), block.chainid, signature) != $.signAddress) {\n            revert InvalidSignature(signatureId);\n        }\n        $.signatureIds[signatureId] = SignatureType.Mint;\n    }\n\n    /**\n     * @notice checks that the provided signature is valid, while also taking into\n     *         consideration the provided address and signatureId.\n     * @param wallet address to be used in validating the signature\n     * @param waveIndex the index of the wave that is used to mint\n     * @param signatureId signing signature ID\n     * @param signature signing signature value\n     */\n    function _checkAndSetWaveMintSignature(\n        address wallet,\n        uint256 waveIndex,\n        uint256 signatureId,\n        bytes calldata signature\n    ) internal {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        if ($.signatureIds[signatureId] != SignatureType.Unused\n            || _getWaveMintSignature(wallet, waveIndex, signatureId, address(this), block.chainid, signature) != $.signAddress) {\n            revert InvalidSignature(signatureId);\n        }\n        $.signatureIds[signatureId] = SignatureType.WaveMint;\n    }\n\n    /**\n     * @notice checks that the provided signature is valid, while also taking into\n     *         consideration the provided address and signatureId.\n     * @param wallet address to be used in validating the signature\n     * @param signatureId signing signature ID\n     * @param signature signing signature value\n     */\n    function _checkAndSetRevealSignature(\n        address wallet,\n        uint256 signatureId,\n        bytes calldata signature\n    ) internal {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        if ($.signatureIds[signatureId] != SignatureType.Unused\n            || _getRevealSignature(wallet, signatureId, address(this), block.chainid, signature) != $.signAddress) {\n            revert InvalidSignature(signatureId);\n        }\n        $.signatureIds[signatureId] = SignatureType.Reveal;\n    }\n\n\n    /**\n     * @notice checks that the provided personalization signature is valid, while also taking into\n     *         consideration the provided address and signatureId.\n     * @param wallet address to be used in validating the signature\n     * @param signatureId signing signature ID\n     * @param signature signing signature value\n     * @param tokenId what token to personalize\n     * @param personalizationMask a mask where each bit has a custom meaning in-game\n     */\n    function _checkAndSetPersonalizationSignature(\n        address wallet,\n        uint256 tokenId,\n        uint256 personalizationMask,\n        uint256 signatureId,\n        bytes calldata signature\n    ) internal {\n        NFTCollectionSignatureStorage storage $ = _getNFTCollectionSignatureStorage();\n        if ($.signatureIds[signatureId] != SignatureType.Unused ||\n            _getPersonalizationSignature(\n                wallet,\n                signatureId,\n                address(this),\n                block.chainid,\n                tokenId,\n                personalizationMask,\n                signature\n            ) != $.signAddress) {\n            revert InvalidSignature(signatureId);\n        }\n        $.signatureIds[signatureId] = SignatureType.Personalization;\n    }\n\n\n    /**\n     * @notice get the address related to mint the signature\n     * @param wallet wallet that was used in signature generation\n     * @param signatureId id of signature\n     * @param contractAddress contract address that was used in signature generation\n     * @param chainId chain ID for which the signature was generated\n     * @param signature signature\n     * @return address that validates the provided signature\n     */\n    function _getMintSignature(\n        address wallet,\n        uint256 signatureId,\n        address contractAddress,\n        uint256 chainId,\n        bytes calldata signature\n    ) internal pure returns (address) {\n        return\n        ECDSA.recover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(abi.encode(wallet, signatureId, contractAddress, chainId))\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @notice get the address related to the reveal signature\n     * @param wallet wallet that was used in signature generation\n     * @param signatureId id of signature\n     * @param contractAddress contract address that was used in signature generation\n     * @param chainId chain ID for which the signature was generated\n     * @param signature signature\n     * @return address that validates the provided signature\n     */\n    function _getRevealSignature(\n        address wallet,\n        uint256 signatureId,\n        address contractAddress,\n        uint256 chainId,\n        bytes calldata signature\n    ) internal pure returns (address) {\n        /// @dev the string \"reveal\" is to distinguish it from the minting signature.\n        return\n        ECDSA.recover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(abi.encode(wallet, signatureId, contractAddress, chainId, \"reveal\"))\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @notice get the address related to the personalization signature\n     * @param wallet wallet that was used in signature generation\n     * @param signatureId id of signature\n     * @param contractAddress contract address that was used in signature generation\n     * @param chainId chain ID for which the signature was generated\n     * @param tokenId token ID for which the signature was generated\n     * @param personalizationMask a mask where each bit has a custom meaning in-game\n     * @param signature signature\n     * @return address that validates the provided signature\n     */\n    function _getPersonalizationSignature(\n        address wallet,\n        uint256 signatureId,\n        address contractAddress,\n        uint256 chainId,\n        uint256 tokenId,\n        uint256 personalizationMask,\n        bytes calldata signature\n    ) internal pure returns (address) {\n        return\n        ECDSA.recover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(\n                        abi.encode(\n                            wallet,\n                            signatureId,\n                            contractAddress,\n                            chainId,\n                            tokenId,\n                            personalizationMask\n                        )\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @notice get the address related to the wave mint signature\n     * @param wallet wallet that was used in signature generation\n     * @param waveIndex the index of the wave that is used to mint\n     * @param signatureId id of signature\n     * @param contractAddress contract address that was used in signature generation\n     * @param chainId chain ID for which the signature was generated\n     * @param signature signature\n     * @return address that validates the provided signature\n     */\n    function _getWaveMintSignature(\n        address wallet,\n        uint256 waveIndex,\n        uint256 signatureId,\n        address contractAddress,\n        uint256 chainId,\n        bytes calldata signature\n    ) internal pure returns (address) {\n        return\n        ECDSA.recover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(\n                        abi.encode(\n                            wallet,\n                            waveIndex,\n                            signatureId,\n                            contractAddress,\n                            chainId\n                        )\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    /**\n     * @notice ERC2771 compatible msg.sender getter\n     * @return sender msg.sender\n     */\n    function _msgSender() internal view virtual returns (address);\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/PurchaseWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {INFTCollection} from \"./INFTCollection.sol\";\nimport {ISandboxSand} from \"./ISandboxSand.sol\";\n\n/**\n * @title PurchaseWrapper\n * @author The Sandbox\n * @notice Contract that facilitates NFT purchases using SAND.\n * @custom:security-contact contact-blockchain@sandbox.game\n * @dev Implements IERC721Receiver to handle NFT receipts. Uses Ownable for admin functions.\n */\ncontract PurchaseWrapper is AccessControl, IERC721Receiver, ReentrancyGuard {\n    /**\n     * @dev Stores information about a purchase linked to a local temporary token ID.\n     * @param caller The EOA who called the `confirmPurchase` function.\n     * @param nftCollection The address of the NFT collection contract from which the NFT was/will be minted.\n     * @param nftTokenId The actual token ID of the minted NFT. It is 0 until the NFT is minted and received by this contract.\n     */\n    struct PurchaseInfo {\n        address caller;\n        address nftCollection;\n        uint256 nftTokenId;\n    }\n\n    /**\n     * @notice The role that is authorized to call this contract's functions.\n     */\n    bytes32 public constant AUTHORIZED_CALLER_ROLE = keccak256(\"AUTHORIZED_CALLER_ROLE\");\n\n    /**\n     * @notice Address of the SAND token used for purchases.\n     */\n    IERC20 public sandToken;\n\n    /**\n     * @notice Mapping from a local temporary token ID to the details of the purchase.\n     * @dev This `localTokenId` is provided by the caller during `confirmPurchase` and is used\n     *      to uniquely identify a purchase transaction and later to reference the minted NFT\n     *      in the wrapper's transfer functions.\n     */\n    mapping(uint256 localTokenId => PurchaseInfo purchaseInfo) private _purchaseInfo;\n\n    /**\n     * @notice Mapping from an NFT collection address to a boolean indicating if it is authorized.\n     */\n    mapping(address nftCollection => bool isAuthorized) private _authorizedNftCollections;\n\n    /**\n     * @notice Emitted when an NFT collection is authorized.\n     */\n    event NftCollectionAuthorized(address indexed nftCollection, bool isAuthorized);\n\n    /**\n     * @notice Emitted when an NFT purchase is confirmed and the minting process is initiated.\n     * @param originalSender The address that initiated the purchase.\n     * @param nftCollection The address of the NFT collection.\n     * @param localTokenId The temporary local token ID for this purchase.\n     * @param nftTokenId The actual ID of the minted NFT.\n     */\n    event PurchaseConfirmed(\n        address indexed originalSender,\n        address indexed nftCollection,\n        uint256 localTokenId,\n        uint256 indexed nftTokenId\n    );\n\n    /**\n     * @notice Emitted when an NFT is transferred using the wrapper's transfer functions.\n     * @param localTokenId The local token ID representing the NFT.\n     * @param from The address from which the NFT is transferred.\n     * @param to The address to which the NFT is transferred.\n     * @param nftTokenId The actual ID of the transferred NFT.\n     */\n    event NftTransferredViaWrapper(\n        uint256 localTokenId,\n        address indexed from,\n        address indexed to,\n        uint256 indexed nftTokenId\n    );\n\n    // Custom Errors\n    error PurchaseWrapperSandTokenAddressCannotBeZero();\n    error PurchaseWrapperNftCollectionAddressCannotBeZero();\n    error PurchaseWrapperLocalTokenIdAlreadyInUse(uint256 localTokenId);\n    error PurchaseWrapperNftPurchaseFailedViaApproveAndCall();\n    error PurchaseWrapperInvalidRecipientAddress();\n    error PurchaseWrapperNoSandTokensToRecover();\n    error PurchaseWrapperTransferToZeroAddress();\n    error PurchaseWrapperInvalidLocalTokenIdOrPurchaseNotCompleted(uint256 localTokenId);\n    error PurchaseWrapperNftNotYetMintedOrRecorded(uint256 localTokenId);\n    error PurchaseWrapperNftCollectionNotRecorded(uint256 localTokenId);\n    error PurchaseWrapperFromAddressIsNotOriginalRecipient(address expected, address actual);\n    error PurchaseWrapperCallerNotAuthorized(address caller);\n    error PurchaseWrapperRandomTempTokenIdCannotBeZero();\n    error PurchaseWrapperNftCollectionNotAuthorized(address nftCollection);\n\n    /**\n     * @notice Constructor to set the SAND token contract address.\n     * @param _admin The initial owner of this contract.\n     * @param _sandToken Address of the Sand (ERC20) token contract.\n     */\n    constructor(address _admin, address _sandToken, address _authorizedCaller) {\n        if (_sandToken == address(0)) revert PurchaseWrapperSandTokenAddressCannotBeZero();\n        sandToken = IERC20(_sandToken);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(AUTHORIZED_CALLER_ROLE, _authorizedCaller);\n    }\n\n    /**\n     * @notice Confirms a purchase request, takes payment, and initiates the NFT minting process\n     *         by calling `approveAndCall` on the `sandToken` contract, which in turn calls\n     *         the `waveMint` (or similar) function on the `nftCollection` contract.\n     * @dev The `randomTempTokenId` must be unique for each purchase attempt and is used to track\n     *      the purchase through to NFT delivery. This function sets transaction-scoped context\n     *      variables (`_txContext_...`) that are used by `onERC721Received`.\n     * @param sender The original EOA initiating the purchase and who will receive the NFT.\n     * @param nftCollection Address of the target NFT Collection contract for minting.\n     * @param waveIndex The wave index for minting on the NFT Collection.\n     * @param signatureId The signature ID for verification by the NFT Collection.\n     * @param randomTempTokenId A unique temporary ID chosen by the caller to identify this purchase.\n     *                          This ID will be associated with the minted NFT.\n     * @param signature The signature data for verification by the NFT Collection.\n     */\n    function confirmPurchase(\n        address sender,\n        address nftCollection,\n        uint256 waveIndex,\n        uint256 signatureId,\n        uint256 randomTempTokenId,\n        bytes calldata signature\n    ) external nonReentrant {\n        _validateAndAuthorizePurchase(sender, nftCollection, randomTempTokenId);\n\n        uint256 sandAmount = INFTCollection(nftCollection).waveSingleTokenPrice(waveIndex);\n\n        PurchaseInfo storage info = _purchaseInfo[randomTempTokenId];\n        info.caller = sender;\n        info.nftCollection = nftCollection;\n\n        IERC20 sandTokenCached = sandToken;\n        SafeERC20.safeTransferFrom(sandTokenCached, sender, address(this), sandAmount);\n\n        uint256 nftTokenId = _initiateMintViaApproveAndCall(\n            nftCollection,\n            sandAmount,\n            waveIndex,\n            signatureId,\n            signature\n        );\n\n        info.nftTokenId = nftTokenId;\n\n        IERC721(nftCollection).transferFrom(address(this), sender, nftTokenId);\n\n        emit PurchaseConfirmed(sender, nftCollection, randomTempTokenId, nftTokenId);\n    }\n\n    /**\n     * @notice Safely transfers an NFT associated with a `localTokenId` using `safeTransferFrom`.\n     * @dev Similar to `transferFrom` but uses `safeTransferFrom` for the actual NFT transfer.\n     *      The `msg.sender` must be the `from` address.\n     * @param from The current owner of the NFT.\n     * @param to The new address to receive the NFT.\n     * @param localTokenId The local temporary token ID.\n     */\n    function safeTransferFrom(address from, address to, uint256 localTokenId) external {\n        if (!hasRole(AUTHORIZED_CALLER_ROLE, msg.sender)) {\n            revert PurchaseWrapperCallerNotAuthorized(msg.sender);\n        }\n        if (to == address(0)) revert PurchaseWrapperTransferToZeroAddress();\n        PurchaseInfo memory info = _purchaseInfo[localTokenId];\n\n        if (info.caller == address(0)) revert PurchaseWrapperInvalidLocalTokenIdOrPurchaseNotCompleted(localTokenId);\n        if (info.nftTokenId == 0) revert PurchaseWrapperNftNotYetMintedOrRecorded(localTokenId);\n        if (info.nftCollection == address(0)) revert PurchaseWrapperNftCollectionNotRecorded(localTokenId);\n        if (info.caller != from) revert PurchaseWrapperFromAddressIsNotOriginalRecipient(from, info.caller);\n\n        IERC721(info.nftCollection).safeTransferFrom(from, to, info.nftTokenId);\n\n        emit NftTransferredViaWrapper(localTokenId, from, to, info.nftTokenId);\n    }\n\n    /**\n     * @notice Recovers SAND tokens (or other ERC20 specified in `sandToken`)\n     *         that were accidentally sent or accumulated in this contract.\n     * @dev Only callable by the contract owner.\n     * @param recipient Address to receive the recovered ERC20 tokens.\n     */\n    function recoverSand(address recipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (recipient == address(0)) revert PurchaseWrapperInvalidRecipientAddress();\n        IERC20 sandTokenCached = sandToken;\n        uint256 balance = sandTokenCached.balanceOf(address(this));\n        if (balance == 0) revert PurchaseWrapperNoSandTokensToRecover();\n\n        SafeERC20.safeTransfer(sandTokenCached, recipient, balance);\n    }\n\n    /**\n     * @notice Sets the authorization status for an NFT collection to be used with this contract.\n     * @dev Only callable by the contract owner.\n     * @param nftCollection The address of the NFT collection to authorize.\n     * @param isAuthorized Whether the NFT collection is authorized.\n     */\n    function setNftCollectionAuthorization(\n        address nftCollection,\n        bool isAuthorized\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (nftCollection == address(0)) revert PurchaseWrapperNftCollectionAddressCannotBeZero();\n        _authorizedNftCollections[nftCollection] = isAuthorized;\n        emit NftCollectionAuthorized(nftCollection, isAuthorized);\n    }\n\n    /**\n     * @notice Retrieves the purchase information for a given local token ID.\n     * @param localTokenId The local temporary token ID of the purchase.\n     * @return A `PurchaseInfo` struct containing the details of the purchase.\n     */\n    function getPurchaseInfo(uint256 localTokenId) external view returns (PurchaseInfo memory) {\n        return _purchaseInfo[localTokenId];\n    }\n\n    /**\n     * @notice Handles the receipt of an ERC721 token, expected to be called by an NFT collection\n     *         contract after a successful mint initiated by `confirmPurchase`.\n     * @dev This function is a simple pass-through to conform to the IERC721Receiver interface.\n     *      The core logic has been moved into `confirmPurchase`.\n     * @return bytes4 The selector `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n     */\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function _initiateMintViaApproveAndCall(\n        address nftCollection,\n        uint256 sandAmount,\n        uint256 waveIndex,\n        uint256 signatureId,\n        bytes calldata signature\n    ) private returns (uint256) {\n        bytes memory data = abi.encodeCall(\n            INFTCollection.waveMint,\n            (\n                address(this), // NFTs will be minted to this contract first\n                1,\n                waveIndex,\n                signatureId,\n                signature\n            )\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = address(sandToken).call(\n            abi.encodeCall(ISandboxSand.approveAndCall, (nftCollection, sandAmount, data))\n        );\n\n        if (!success) {\n            revert PurchaseWrapperNftPurchaseFailedViaApproveAndCall();\n        }\n        uint256[] memory tokenIds = new uint256[](1);\n        // The return data from `approveAndCall` is a `bytes` type, which means the actual return data from `waveMint` (an abi-encoded uint256[])\n        // is itself abi-encoded. We need to go deeper.\n        // `result` raw data layout:\n        // - 0x00: offset to bytes data (0x20)\n        // - 0x20: length of bytes data (e.g., 96 for a single uint256 in an array)\n        // - 0x40: start of the `waveMint` return data\n        //   - 0x40: offset to array data (0x20)\n        //   - 0x60: array length (1)\n        //   - 0x80: the token ID\n        if (result.length < 160) {\n            revert PurchaseWrapperNftPurchaseFailedViaApproveAndCall();\n        }\n        bytes32 tokenIdWord;\n        assembly {\n            // We read the word at offset 0x80 in the raw return data.\n            // The `result` variable is a memory pointer, and its data starts at an offset of 0x20.\n            // So we read from result + 0x20 (start of data) + 0x80 (offset to tokenId) = result + 0xa0\n            tokenIdWord := mload(add(result, 0xa0))\n        }\n        tokenIds[0] = uint256(tokenIdWord);\n        return tokenIds[0];\n    }\n\n    function _validateAndAuthorizePurchase(\n        address sender,\n        address nftCollection,\n        uint256 randomTempTokenId\n    ) private view {\n        if (msg.sender != address(sandToken) || !hasRole(AUTHORIZED_CALLER_ROLE, sender)) {\n            revert PurchaseWrapperCallerNotAuthorized(sender);\n        }\n        if (!_authorizedNftCollections[nftCollection]) {\n            revert PurchaseWrapperNftCollectionNotAuthorized(nftCollection);\n        }\n\n        if (randomTempTokenId == 0) revert PurchaseWrapperRandomTempTokenIdCannotBeZero();\n        if (_purchaseInfo[randomTempTokenId].nftTokenId != 0) {\n            revert PurchaseWrapperLocalTokenIdAlreadyInUse(randomTempTokenId);\n        }\n    }\n}\n"
    },
    "@sandbox-smart-contracts/avatar/contracts/nft-collection/UpdatableOperatorFiltererUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable one-contract-per-file\npragma solidity 0.8.26;\n\n/**\n * @title UpdatableOperatorFiltererUpgradeable\n * @author The Sandbox\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice This contract would subscribe or copy or just to the subscription provided or just register to\n *          default subscription list\n * @dev This contract is the upgradeable version of the OpenSea implementation\n *      https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/OperatorFilterer.sol\n *      and adapted to the 0.5.9 solidity version\n *      To avoid an extra IOperatorFilterRegistry file for a code that is deprecated the interface is added below\n */\nabstract contract UpdatableOperatorFiltererUpgradeable {\n    /// @custom:storage-location erc7201:thesandbox.storage.avatar.nft-collection.UpdatableOperatorFiltererUpgradeable\n    struct UpdatableOperatorFiltererUpgradeableStorage {\n        /**\n         * @notice the registry filter\n         */\n        IOperatorFilterRegistry operatorFilterRegistry;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"thesandbox.storage.avatar.nft-collection.UpdatableOperatorFiltererUpgradeable\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant UPDATABLE_OPERATOR_FILTERER_UPGRADABLE_STORAGE_LOCATION =\n    0x71a93d37b91262fe5ff5f64b534078b04fa3ca1f04b63abeac7b60ede712e800;\n\n    function _getUpdatableOperatorFiltererUpgradeableStorage() private pure returns (UpdatableOperatorFiltererUpgradeableStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := UPDATABLE_OPERATOR_FILTERER_UPGRADABLE_STORAGE_LOCATION\n        }\n    }\n\n    /**\n     * @notice emitted when a registry is set\n     * @param operator the sender of the transaction\n     * @param oldRegistry address of the old registry\n     * @param newRegistry address of the new registry to set\n     */\n    event OperatorRegistrySet(address indexed operator, IOperatorFilterRegistry indexed oldRegistry, address indexed newRegistry);\n\n    /**\n     * @notice emitted when the contract is registered into the registry\n     * @param operator the sender of the transaction\n     * @param registry address of the registry to set\n     * @param subscriptionOrRegistrant address to subscribe or copy entries from\n     * @param subscribe should it subscribe\n     */\n    event ContractRegistered(\n        address indexed operator,\n        IOperatorFilterRegistry indexed registry,\n        address indexed subscriptionOrRegistrant,\n        bool subscribe\n    );\n\n    /**\n     * @notice the caller is not the operator\n     * @param operator that does the call\n     */\n    error OperatorNotAllowed(address operator);\n\n    /**\n     * @notice the registry is not configured\n     * @param operator that does the call\n     */\n    error RegistryNotSet(address operator);\n\n    /**\n     * @notice this contract is already registered\n     * @param operator that does the call\n     */\n    error AlreadyRegistered(address operator);\n\n    /**\n     * @notice Used in approval operations to check if the operator is allowed to call this contract\n     * @param operator The address receiving the approval\n     */\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkIsOperatorAllowed(address(this), operator);\n        _;\n    }\n\n    /**\n     * @notice Used in transfer from operations to check if the sender of the token is allowed to call this contract\n     * @param from the sender of the token\n     */\n    modifier onlyAllowedOperator(address from) virtual {\n        // Allow spending tokens from addresses with balance (from == _msgSender())\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n        // from an EOA.\n        if (from != _msgSender()) {\n            _checkIsOperatorAllowed(address(this), _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @notice return the operatorFilterRegistry address\n     * @return the operatorFilterRegistry address\n     */\n    function operatorFilterRegistry() external view returns (IOperatorFilterRegistry) {\n        UpdatableOperatorFiltererUpgradeableStorage storage $ = _getUpdatableOperatorFiltererUpgradeableStorage();\n        return $.operatorFilterRegistry;\n    }\n\n    /**\n     * @notice Register this contract into the registry\n     * @param subscriptionOrRegistrantToCopy address to subscribe or copy entries from\n     * @param subscribe should it subscribe\n     */\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal {\n        UpdatableOperatorFiltererUpgradeableStorage storage $ = _getUpdatableOperatorFiltererUpgradeableStorage();\n        IOperatorFilterRegistry registry = $.operatorFilterRegistry;\n        bool isContract = address(registry).code.length > 0;\n        if (!isContract) {\n            revert RegistryNotSet(_msgSender());\n        }\n        if (registry.isRegistered(address(this))) {\n            revert AlreadyRegistered(_msgSender());\n        }\n\n        if (subscribe) {\n            registry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n        } else if (subscriptionOrRegistrantToCopy != address(0)) {\n            registry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n        } else {\n            registry.register(address(this));\n        }\n        emit ContractRegistered(_msgSender(), registry, subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /**\n     * @notice sets filter registry address deployed in test\n     * @param registry the address of the registry\n     * @dev address(0) disables the registry\n     */\n    function _setOperatorRegistry(address registry) internal {\n        UpdatableOperatorFiltererUpgradeableStorage storage $ = _getUpdatableOperatorFiltererUpgradeableStorage();\n        emit OperatorRegistrySet(_msgSender(), $.operatorFilterRegistry, registry);\n        $.operatorFilterRegistry = IOperatorFilterRegistry(registry);\n    }\n\n    /**\n     * @notice Check if the operator is allowed for the given registrant\n     * @param registrant address of the registrant\n     * @param operator operator address to check\n     */\n    function _checkIsOperatorAllowed(address registrant, address operator) internal view {\n        UpdatableOperatorFiltererUpgradeableStorage storage $ = _getUpdatableOperatorFiltererUpgradeableStorage();\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        IOperatorFilterRegistry registry = $.operatorFilterRegistry;\n        if (address(registry).code.length > 0) {\n            /* solhint-disable no-empty-blocks */\n            try registry.isOperatorAllowed(registrant, operator) returns (bool retval) {\n                if (retval) {\n                    return;\n                }\n            } catch (bytes memory) {}\n            /* solhint-enable  no-empty-blocks */\n            revert OperatorNotAllowed(operator);\n        }\n    }\n\n    /**\n     * @notice ERC2771 compatible msg.sender getter\n     * @return sender msg.sender\n     */\n    function _msgSender() internal view virtual returns (address);\n}\n\n/**\n * @title IOperatorFilterRegistry\n * @author Opensea\n * @custom:security-contact contact-blockchain@sandbox.game\n * @notice Based on the opensea registry implementation, added here to be used specifically and\n * @notice just once in UpdatableOperatorFiltererUpgradeable\n * @dev see: https://github.com/ProjectOpenSea/operator-filter-registry/tree/main\n */\ninterface IOperatorFilterRegistry {\n    /**\n     * @notice Returns true if an address has registered\n     * @param addr the address to check if it is registered\n     * @return true if an address has registered\n     */\n    function isRegistered(address addr) external returns (bool);\n\n    /**\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\n     *         true if supplied registrant address is not registered.\n     * @param registrant the address of the contract to check for (usually address(this))\n     * @param operator the operator to check if it is registered for this registrant\n     * @return true if operator is not filtered for a given token\n     */\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n\n    /**\n     * @notice Registers an address with the registry and \"subscribes\" to another address's filtered operators and codeHashes.\n     * @param registrant the address of the contract to check for (usually address(this))\n     * @param subscription address to subscribe to\n     */\n    function registerAndSubscribe(address registrant, address subscription) external;\n\n    /**\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\n     *         address without subscribing.\n     * @param registrant the address of the contract to check for (usually address(this))\n     * @param registrantToCopy address to copy entries from\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\n     * @param registrant the address of the contract to check for (usually address(this))\n     */\n    function register(address registrant) external;\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}