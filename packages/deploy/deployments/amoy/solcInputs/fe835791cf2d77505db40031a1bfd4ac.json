{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-0.8/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/extensions/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/presets/ERC1155PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/presets/ERC1155PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../extensions/ERC1155Burnable.sol\";\nimport \"../extensions/ERC1155Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC1155} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC1155PresetMinterPauser is Context, AccessControlEnumerable, ERC1155Burnable, ERC1155Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\n     * deploys the contract.\n     */\n    constructor(string memory uri) ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155, ERC1155Pausable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/ERC20/ERC20BaseToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"./extensions/ERC20Internal.sol\";\nimport \"../../interfaces/IERC20Extended.sol\";\nimport \"../WithSuperOperators.sol\";\n\nabstract contract ERC20BaseToken is WithSuperOperators, IERC20, IERC20Extended, ERC20Internal, Context {\n    string internal _name;\n    string internal _symbol;\n    address internal immutable _operator;\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address admin,\n        address operator\n    ) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _admin = admin;\n        _operator = operator;\n    }\n\n    /// @notice Transfer `amount` tokens to `to`.\n    /// @param to The recipient address of the tokens being transfered.\n    /// @param amount The number of tokens being transfered.\n    /// @return success Whether or not the transfer succeeded.\n    function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(_msgSender(), to, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `from` to `to`.\n    /// @param from The origin address  of the tokens being transferred.\n    /// @param to The recipient address of the tokensbeing  transfered.\n    /// @param amount The number of tokens transfered.\n    /// @return success Whether or not the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (_msgSender() != from && !_superOperators[_msgSender()] && _msgSender() != _operator) {\n            uint256 currentAllowance = _allowances[from][_msgSender()];\n            if (currentAllowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHORIZED_ALLOWANCE\");\n                _allowances[from][_msgSender()] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Burn `amount` tokens.\n    /// @param amount The number of tokens to burn.\n    function burn(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    /// @notice Burn `amount` tokens from `owner`.\n    /// @param from The address whose token to burn.\n    /// @param amount The number of tokens to burn.\n    function burnFor(address from, uint256 amount) external override {\n        _burn(from, amount);\n    }\n\n    /// @notice Approve `spender` to transfer `amount` tokens.\n    /// @param spender The address to be given rights to transfer.\n    /// @param amount The number of tokens allowed.\n    /// @return success Whether or not the call succeeded.\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        _approveFor(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /// @notice Get the name of the token collection.\n    /// @return The name of the token collection.\n    function name() external view virtual returns (string memory) {\n        //added virtual\n        return _name;\n    }\n\n    /// @notice Get the symbol for the token collection.\n    /// @return The symbol of the token collection.\n    function symbol() external view virtual returns (string memory) {\n        //added virtual\n        return _symbol;\n    }\n\n    /// @notice Get the total number of tokens in existence.\n    /// @return The total number of tokens in existence.\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Get the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    /// @notice Get the allowance of `spender` for `owner`'s tokens.\n    /// @param owner The address whose token is allowed.\n    /// @param spender The address allowed to transfer.\n    /// @return remaining The amount of token `spender` is allowed to transfer on behalf of `owner`.\n    function allowance(address owner, address spender) external view override returns (uint256 remaining) {\n        return _allowances[owner][spender];\n    }\n\n    /// @notice Get the number of decimals for the token collection.\n    /// @return The number of decimals.\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @notice Approve `spender` to transfer `amount` tokens from `owner`.\n    /// @param owner The address whose token is allowed.\n    /// @param spender The address to be given rights to transfer.\n    /// @param amount The number of tokens allowed.\n    /// @return success Whether or not the call succeeded.\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) public override returns (bool success) {\n        require(_msgSender() == owner || _superOperators[_msgSender()] || _msgSender() == _operator, \"NOT_AUTHORIZED\");\n        _approveFor(owner, spender, amount);\n        return true;\n    }\n\n    /// @notice Increase the allowance for the spender if needed\n    /// @param owner The address of the owner of the tokens\n    /// @param spender The address wanting to spend tokens\n    /// @param amountNeeded The amount requested to spend\n    /// @return success Whether or not the call succeeded.\n    function addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded\n    ) public returns (bool success) {\n        require(_msgSender() == owner || _superOperators[_msgSender()] || _msgSender() == _operator, \"INVALID_SENDER\");\n        _addAllowanceIfNeeded(owner, spender, amountNeeded);\n        return true;\n    }\n\n    /// @dev See addAllowanceIfNeeded.\n    function _addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded /*(ERC20Internal, ERC20ExecuteExtension, ERC20BasicApproveExtension)*/\n    ) internal virtual override {\n        if (amountNeeded > 0 && !isSuperOperator(spender) && spender != _operator) {\n            uint256 currentAllowance = _allowances[owner][spender];\n            if (currentAllowance < amountNeeded) {\n                _approveFor(owner, spender, amountNeeded);\n            }\n        }\n    }\n\n    /// @dev See approveFor.\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount /*(ERC20BasicApproveExtension, ERC20Internal)*/\n    ) internal virtual override {\n        require(owner != address(0) && spender != address(0), \"INVALID_OWNER_||_SPENDER\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /// @dev See transfer.\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount /*(ERC20Internal, ERC20ExecuteExtension)*/\n    ) internal virtual override {\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(to != address(this), \"NOT_TO_THIS\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"INSUFFICIENT_FUNDS\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    /// @dev Mint tokens for a recipient.\n    /// @param to The recipient address.\n    /// @param amount The number of token to mint.\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(amount > 0, \"MINT_O_TOKENS\");\n        uint256 currentTotalSupply = _totalSupply;\n        uint256 newTotalSupply = currentTotalSupply + amount;\n        require(newTotalSupply > currentTotalSupply, \"OVERFLOW\");\n        _totalSupply = newTotalSupply;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    /// @dev Burn tokens from an address.\n    /// @param from The address whose tokens to burn.\n    /// @param amount The number of token to burn.\n    function _burn(address from, uint256 amount) internal {\n        require(amount > 0, \"BURN_O_TOKENS\");\n        if (_msgSender() != from && !_superOperators[_msgSender()] && _msgSender() != _operator) {\n            uint256 currentAllowance = _allowances[from][_msgSender()];\n            if (currentAllowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"INSUFFICIENT_ALLOWANCE\");\n                _allowances[from][_msgSender()] = currentAllowance - amount;\n            }\n        }\n\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"INSUFFICIENT_FUNDS\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/ERC20/extensions/ERC20BasicApproveExtension.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"./ERC20Internal.sol\";\nimport \"../../../Libraries/BytesUtil.sol\";\n\nabstract contract ERC20BasicApproveExtension is ERC20Internal, Context {\n    /// @notice Approve `target` to spend `amount` and call it with data.\n    /// @param target The address to be given rights to transfer and destination of the call.\n    /// @param amount The number of tokens allowed.\n    /// @param data The bytes for the call.\n    /// @return The data of the call.\n    function approveAndCall(\n        address target,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes memory) {\n        require(BytesUtil.doFirstParamEqualsAddress(data, _msgSender()), \"FIRST_PARAM_NOT_SENDER\");\n\n        _approveFor(_msgSender(), target, amount);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, string(returnData));\n        return returnData;\n    }\n\n    /// @notice Temporarily approve `target` to spend `amount` and call it with data.\n    /// Previous approvals remains unchanged.\n    /// @param target The destination of the call, allowed to spend the amount specified\n    /// @param amount The number of tokens allowed to spend.\n    /// @param data The bytes for the call.\n    /// @return The data of the call.\n    function paidCall(\n        address target,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes memory) {\n        require(BytesUtil.doFirstParamEqualsAddress(data, _msgSender()), \"FIRST_PARAM_NOT_SENDER\");\n\n        if (amount > 0) {\n            _addAllowanceIfNeeded(_msgSender(), target, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, string(returnData));\n\n        return returnData;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/ERC20/extensions/ERC20Internal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nabstract contract ERC20Internal {\n    function _approveFor(\n        address owner,\n        address target,\n        uint256 amount\n    ) internal virtual;\n\n    function _addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title ERC2771Handler\n * @author The Sandbox\n * @notice Handle meta-transactions\n * @dev minimal ERC2771 handler to keep bytecode-size down\n * based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/metatx/ERC2771Context.sol\n * with an initializer for proxies and a mutable forwarder\n */\nabstract contract ERC2771Handler {\n    address internal _trustedForwarder;\n\n    event TrustedForwarderSet(address indexed newForwarder);\n\n    /**\n     * @dev Initializes the contract\n     * @param forwarder trusted forwarder address\n     */\n    function __ERC2771Handler_initialize(address forwarder) internal {\n        _trustedForwarder = forwarder;\n        emit TrustedForwarderSet(_trustedForwarder);\n    }\n\n    /**\n     * @notice Checks if an address is a trusted forwarder\n     * @param forwarder address to check\n     * @return is trusted\n     */\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    /**\n     * @notice Get the current trusted forwarder\n     * @return trustedForwarder address of the trusted forwarder\n     */\n    function getTrustedForwarder() external view returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev if the call comes from the trusted forwarder, it gets the real sender by checking the encoded address in the data\n     * @return sender address of the real sender\n     */\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * @dev if the call comes from the trusted forwarder, it substracts the sender address from `msg.data` to get the real `msg.data`\n     * @return the real `msg.data`\n     */\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/ERC721BaseTokenV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n/* solhint-disable func-order, code-complexity */\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {\n    IERC721ReceiverUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {WithSuperOperatorsV2} from \"./WithSuperOperatorsV2.sol\";\nimport {IERC721MandatoryTokenReceiver} from \"../interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title ERC721BaseTokenV2\n/// @author The Sandbox\n/// @notice Basic functionalities of a NFT\n/// @dev ERC721 implementation that supports meta-transactions and super operators\ncontract ERC721BaseTokenV2 is ContextUpgradeable, IERC721Upgradeable, WithSuperOperatorsV2 {\n    using AddressUpgradeable for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    uint256 internal constant NOT_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\n    uint256 internal constant OPERATOR_FLAG = (2**255);\n    uint256 internal constant NOT_OPERATOR_FLAG = OPERATOR_FLAG - 1;\n    uint256 internal constant BURNED_FLAG = (2**160);\n\n    mapping(address => uint256) internal _numNFTPerAddress;\n    /**\n     * @dev mapping to store owner of lands and quads.\n     * For 1x1 lands it also the 255 bit is 1 if that land has operator approved and is 0 if no operator is approved.\n     * For burned 1x1 Land 160 bit is set to 1.\n     */\n    mapping(uint256 => uint256) internal _owners;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    mapping(uint256 => address) internal _operators;\n\n    /// @notice Approve an operator to spend tokens on the senders behalf.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approve(address operator, uint256 id) public virtual override {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = _ownerOf(id);\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(\n            owner == msgSender || _operatorsForAll[owner][msgSender] || _superOperators[msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Approve an operator to spend tokens on the sender behalf.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public virtual {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = _ownerOf(id);\n        address msgSender = _msgSender();\n        require(sender != address(0), \"ZERO_ADDRESS_SENDER\");\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(\n            msgSender == sender || _operatorsForAll[sender][msgSender] || _superOperators[msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        require(address(uint160(ownerData)) == sender, \"OWNER_NOT_SENDER\");\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Transfer a token between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, \"\"), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual override {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public virtual {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    /// @notice Transfer many tokens between 2 addresses, while\n    /// ensuring the receiving contract has a receiver method.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external virtual {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public virtual {\n        require(sender != address(0), \"Invalid sender address\");\n        address msgSender = _msgSender();\n        require(msgSender == sender || _superOperators[msgSender], \"UNAUTHORIZED_APPROVE_FOR_ALL\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id The token which will be burnt.\n    function burn(uint256 id) external virtual {\n        _burn(_msgSender(), _ownerOf(id), id);\n    }\n\n    /// @notice Burn token `id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id The token which will be burnt.\n    function burnFrom(address from, uint256 id) external virtual {\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(\n            msgSender == from ||\n                (operatorEnabled && _operators[id] == msgSender) ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender],\n            \"UNAUTHORIZED_BURN\"\n        );\n        _burn(from, owner, id);\n    }\n\n    /// @notice Get the number of tokens owned by an address.\n    /// @param owner The address to look for.\n    /// @return The number of tokens owned by the address.\n    function balanceOf(address owner) external view override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS_OWNER\");\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice Get the owner of a token.\n    /// @param id The id of the token.\n    /// @return owner The address of the token owner.\n    function ownerOf(uint256 id) external view override returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"NONEXISTANT_TOKEN\");\n    }\n\n    /// @notice Get the approved operator for a specific token.\n    /// @param id The id of the token.\n    /// @return The address of the operator.\n    function getApproved(uint256 id) external view override returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @notice Check if the sender approved the operator.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    /// @param data Additional data.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, data), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Check if the contract supports an interface.\n    /// 0x01ffc9a7 is ERC-165.\n    /// 0x80ac58cd is ERC-721\n    /// @param id The id of the interface.\n    /// @return Whether the interface is supported.\n    function supportsInterface(bytes4 id) public pure virtual override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /// @dev By overriding this function in an implementation which inherits this contract,\n    /// you can enable versioned tokenIds without the extra overhead of writing to a new storage slot in _owners each time a version is incremented.\n    /// See GameToken._storageId() for an example, where the storageId is the tokenId minus the version number.\n    /// !!! Caution !!! Overriding this function without taking appropriate care could lead to\n    /// ownerOf() returning an owner for non-existent tokens. Tests should be written to\n    /// guard against introducing this bug.\n    /// @param id The id of a token.\n    /// @return The id used for storage mappings.\n    function _storageId(uint256 id) internal view virtual returns (uint256) {\n        return id;\n    }\n\n    function _updateOwnerData(\n        uint256 id,\n        uint256 oldData,\n        address newOwner,\n        bool hasOperator\n    ) internal virtual {\n        if (hasOperator) {\n            _owners[_storageId(id)] = (oldData & NOT_ADDRESS) | OPERATOR_FLAG | uint256(uint160(newOwner));\n        } else {\n            _owners[_storageId(id)] = ((oldData & NOT_ADDRESS) & NOT_OPERATOR_FLAG) | uint256(uint160(newOwner));\n        }\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _updateOwnerData(id, _owners[_storageId(id)], to, false);\n        emit Transfer(from, to, id);\n    }\n\n    /// @dev See approveFor.\n    function _approveFor(\n        uint256 ownerData,\n        address operator,\n        uint256 id\n    ) internal {\n        address owner = _ownerOf(id);\n        if (operator == address(0)) {\n            _updateOwnerData(id, ownerData, owner, false);\n        } else {\n            _updateOwnerData(id, ownerData, owner, true);\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /// @dev See batchTransferFrom.\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _operatorsForAll[from][msgSender] || _superOperators[msgSender];\n\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"BATCHTRANSFERFROM_NOT_OWNER\");\n            require(authorized || (operatorEnabled && _operators[id] == msgSender), \"NOT_AUTHORIZED\");\n            _updateOwnerData(id, _owners[_storageId(id)], to, false);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(_checkOnERC721BatchReceived(msgSender, from, to, ids, data), \"ERC721_BATCH_RECEIVED_REJECTED\");\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i++) {\n                    require(_checkOnERC721Received(msgSender, from, to, ids[i], data), \"ERC721_RECEIVED_REJECTED\");\n                }\n            }\n        }\n    }\n\n    /// @dev See setApprovalForAll.\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_APPROVAL_CHANGE\");\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /// @dev See burn.\n    function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) internal {\n        require(from == owner, \"NOT_OWNER\");\n        uint256 storageId = _storageId(id);\n        _owners[storageId] = (_owners[storageId] & NOT_OPERATOR_FLAG) | BURNED_FLAG; // record as non owner but keep track of last owner\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param tokenId The id of the token we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x150b7a02 is returned.\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 batch transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param ids The ids of the tokens we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x4b808c46 is returned.\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    /// @dev See ownerOf\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            return address(0);\n        }\n        return address(uint160(data));\n    }\n\n    /// @dev Get the owner and operatorEnabled status of a token.\n    /// @param id The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        virtual\n        returns (address owner, bool operatorEnabled)\n    {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n        } else {\n            owner = address(uint160(data));\n        }\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n    }\n\n    /// @dev Check whether a transfer is a meta Transaction or not.\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param to The address receiving the token.\n    /// @param id The token being transferred.\n    function _checkTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal view {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(owner == from, \"CHECKTRANSFER_NOT_OWNER\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(\n            msgSender == owner ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender] ||\n                (operatorEnabled && _operators[id] == msgSender),\n            \"UNAUTHORIZED_TRANSFER\"\n        );\n    }\n\n    /// @dev Check if there was enough gas.\n    /// @param _contract The address of the contract to check.\n    /// @param interfaceId The id of the interface we want to test.\n    /// @return Whether or not this check succeeded.\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory callData = abi.encodeWithSelector(ERC165ID, interfaceId);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, callData)\n            let call_size := mload(callData)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/WithAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\ncontract WithAdmin {\n    address internal _admin;\n\n    /// @dev Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"ADMIN_ONLY\");\n        _;\n    }\n\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"ADMIN_ACCESS_DENIED\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/WithAdminV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title WithAdminV2\n/// @author The Sandbox\n/// @notice Add an admin to the contract\ncontract WithAdminV2 is ContextUpgradeable {\n    address internal _admin;\n\n    /// @dev Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    modifier onlyAdmin() {\n        require(_msgSender() == _admin, \"ADMIN_ONLY\");\n        _;\n    }\n\n    /// @notice Get the current admin\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice Change the admin of the contract\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        address admin = _admin;\n        require(_msgSender() == admin, \"ADMIN_ACCESS_DENIED\");\n        emit AdminChanged(admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/WithSuperOperators.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./WithAdmin.sol\";\n\ncontract WithSuperOperators is WithAdmin {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address indexed superOperator, bool indexed enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/BaseWithStorage/WithSuperOperatorsV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {WithAdminV2} from \"./WithAdminV2.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title WithSuperOperatorsV2\n/// @author The Sandbox\n/// @notice Add super operators handled by an admin\ncontract WithSuperOperatorsV2 is ContextUpgradeable, WithAdminV2 {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address indexed superOperator, bool indexed enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external onlyAdmin {\n        require(_msgSender() == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20 {\n    /// @notice emitted when tokens are transfered from one address to another.\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\n    /// @param value amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice emitted when owner grant transfer rights to another address\n    /// @param owner address allowing its token to be transferred.\n    /// @param spender address allowed to spend on behalf of `owner`\n    /// @param value amount of tokens allowed.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice return the current total amount of tokens owned by all holders.\n    /// @return supply total number of tokens held.\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @notice return the number of tokens held by a particular address.\n    /// @param who address being queried.\n    /// @return balance number of token held by that address.\n    function balanceOf(address who) external view returns (uint256 balance);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    /// @notice approve an address to spend on your behalf.\n    /// @param spender address entitled to transfer on your behalf.\n    /// @param value amount allowed to be transfered.\n    /// @param success whether the approval succeeded.\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /// @notice return the current allowance for a particular owner/spender pair.\n    /// @param owner address allowing spender.\n    /// @param spender address allowed to spend.\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) external view returns (uint256 amount);\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/interfaces/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Extended is IERC20 {\n    function burnFor(address from, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool success);\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title IERC721MandatoryTokenReceiver\n * @author The Sandbox\n * @notice Interface for any contract that wants to support safeBatchTransfers\n * from ERC721 asset contracts.\n * @dev The ERC-165 identifier for this interface is 0x5e8bf644.\n */\ninterface IERC721MandatoryTokenReceiver {\n    /**\n     * @notice Whenever tokens are transferred to this contract via {IERC721-safeBatchTransferFrom}\n     * by `operator` from `from`, this function is called.\n     * @param operator sender\n     * @param from owner of the tokens\n     * @param ids token ids\n     * @param data extra data\n     * @return 0x4b808c46 if the transfer is a success\n     */\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    /**\n     * @notice Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     * @param operator sender\n     * @param from owner of the token\n     * @param tokenId token id\n     * @param data extra data\n     * @return 0x4b808c46 if the transfer is a success\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/interfaces/ILandToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/// @title ILandToken\n/// @author The Sandbox\n/// @notice Interface of the LAND token including quad methods\ninterface ILandToken {\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external;\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external;\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/interfaces/IPolygonLand.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {ILandToken} from \"./ILandToken.sol\";\n\n/**\n * @title IPolygonLand\n * @author The Sandbox\n * @notice Interface of the LAND token on the child chain\n */\ninterface IPolygonLand is ILandToken {\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external;\n\n    /**\n     * @notice Checks if a LAND exists by its coordinates\n     * @param size size of the quad\n     * @param x x coordinate\n     * @param y y coordinate\n     * @return does the LAND exist\n     */\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) external view returns (bool);\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/common/Libraries/BytesUtil.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nlibrary BytesUtil {\n    uint256 private constant DATA_MIN_LENGTH = 68;\n\n    /// @dev Check if the data == _address.\n    /// @param data The bytes passed to the function.\n    /// @param _address The address to compare to.\n    /// @return Whether the first param == _address.\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\n        if (data.length < DATA_MIN_LENGTH) {\n            return false;\n        }\n        uint256 value;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(uint160(_address));\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/OperatorFilterer/contracts/OperatorFilterRegistrant.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {IOperatorFilterRegistry} from \"../interfaces/IOperatorFilterRegistry.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title OperatorFilterSubription\n/// @notice This contract is ment to register and copy the default subscription of the openSea for the operator filter and our Token contract are supposed to subscribe to This contract on openSea operator filter registry\n/// @custom:experimental This is an experimental contract. There could be future changes according to the change in the requirements\ncontract OperatorFilterSubscription is OwnableUpgradeable {\n    address public constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\n\n    IOperatorFilterRegistry public constant operatorFilterRegistry =\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n    function initialize() external initializer {\n        // Subscribe and copy the entries of the Default subscription list of open sea.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            operatorFilterRegistry.registerAndCopyEntries(address(this), DEFAULT_SUBSCRIPTION);\n        }\n        __Ownable_init();\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {IOperatorFilterRegistry} from \"../../interfaces/IOperatorFilterRegistry.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n///@title OperatorFiltererUpgradeable\n///@author The Sandbox\n///@notice This contract would subscibe or copy or just to the subscription provided or just register to default subscription list\n///@dev This contract is the upgradeable version of the OpenSea implementation https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/OperatorFilterer.sol and adapted to the 0.5.9 solidity version\nabstract contract OperatorFiltererUpgradeable is ContextUpgradeable {\n    IOperatorFilterRegistry public operatorFilterRegistry;\n\n    event ContractRegistered(address indexed subscriptionOrRegistrant, bool subscribe);\n\n    function __OperatorFilterer_init(address subscriptionOrRegistrantToCopy, bool subscribe) internal onlyInitializing {\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /**\n     * @notice Register this contract into the registry\n     * @param subscriptionOrRegistrantToCopy address to subscribe or copy entries from\n     * @param subscribe should it subscribe\n     */\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal {\n        if (address(operatorFilterRegistry).code.length > 0) {\n            if (!operatorFilterRegistry.isRegistered(address(this))) {\n                if (subscribe) {\n                    operatorFilterRegistry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    if (subscriptionOrRegistrantToCopy != address(0)) {\n                        operatorFilterRegistry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                    } else {\n                        operatorFilterRegistry.register(address(this));\n                    }\n                }\n            }\n        }\n        emit ContractRegistered(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    modifier onlyAllowedOperator(address from) virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            // Allow spending tokens from addresses with balance\n            // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n            // from an EOA.\n            if (from == _msgSender()) {\n                _;\n                return;\n            }\n            if (!operatorFilterRegistry.isOperatorAllowed(address(this), _msgSender())) {\n                revert(\"Operator Not Allowed\");\n            }\n        }\n        _;\n    }\n\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            if (!operatorFilterRegistry.isOperatorAllowed(address(this), operator)) {\n                revert(\"Operator Not Allowed\");\n            }\n        }\n        _;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/**\n * @title IOperatorFilterRegistry\n * @author OpenSea\n * @notice Interface of the operator filter registry\n * @dev This interface comes from OpenSea https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/IOperatorFilterRegistry.sol and adapted to the 0.5.9 solidity version\n */\ninterface IOperatorFilterRegistry {\n    /**\n     * @notice Check if the operator is allowed for the given registrant\n     * @param registrant address of the registrant\n     * @param operator operator address to check\n     * @return is the operator allowed\n     */\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n    /**\n     * @notice Register a new address\n     * @param registrant address to register\n     */\n    function register(address registrant) external;\n\n    /**\n     * @notice Register a new address & subscribe to an address\n     * @param registrant address of the registrant\n     * @param subscription address where the registrant is subscribed to\n     */\n    function registerAndSubscribe(address registrant, address subscription) external;\n\n    /**\n     * @notice Register and copy entries of another registrant\n     * @param registrant address of the registrant\n     * @param registrantToCopy address to copy from\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice update the operator for a registrant\n     * @param registrant address of the registrant\n     * @param operator operator to be updated\n     * @param filtered is it filtered\n     */\n    function updateOperator(\n        address registrant,\n        address operator,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update operators for a registrant\n     * @param registrant address of the registrant\n     * @param operators addresses of the operators\n     * @param filtered is it filtered\n     */\n    function updateOperators(\n        address registrant,\n        address[] calldata operators,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update code hash\n     * @param registrant address of the registrant\n     * @param codehash code hash\n     * @param filtered is it filtered\n     */\n    function updateCodeHash(\n        address registrant,\n        bytes32 codehash,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update code hashes\n     * @param registrant address of the registrant\n     * @param codeHashes code hashes\n     * @param filtered is it filtered\n     */\n    function updateCodeHashes(\n        address registrant,\n        bytes32[] calldata codeHashes,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Subscribe a registrant\n     * @param registrant address of the registrant\n     * @param registrantToSubscribe address to subscribe with\n     */\n    function subscribe(address registrant, address registrantToSubscribe) external;\n\n    /**\n     * @notice Unsubscribe a registrant\n     * @param registrant address of the registrant\n     * @param copyExistingEntries copy existing entries\n     */\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n    /**\n     * @notice Get the subscription of an address\n     * @param addr address to check\n     * @return registrant the registrant address\n     */\n    function subscriptionOf(address addr) external returns (address registrant);\n\n    /**\n     * @notice Get the subscribers of the registrant\n     * @param registrant address of the registrant\n     * @return the subscribers addresses\n     */\n    function subscribers(address registrant) external returns (address[] memory);\n\n    /**\n     * @notice Get a specific subscriber\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return the ith subscriber of the registrant\n     */\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Copy the entries of a registrant\n     * @param registrant address of the registrant\n     * @param registrantToCopy address to copy\n     */\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice Is a registrant filtered\n     * @param registrant address of the registrant\n     * @param operator operator address to check\n     * @return is it filtered\n     */\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n    /**\n     * @notice Is the code hash of an operator filtered\n     * @param registrant address of the registrant\n     * @param operatorWithCode operator address to check\n     * @return is it filtered\n     */\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n    /**\n     * @notice Is the code hash filtered\n     * @param registrant address of the registrant\n     * @param codeHash code hash\n     * @return is it filtered\n     */\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n    /**\n     * @notice Get the filtered operators\n     * @param addr address to check\n     * @return filtered operators\n     */\n    function filteredOperators(address addr) external returns (address[] memory);\n\n    /**\n     * @notice Get the filtered code hashes\n     * @param addr address to check\n     * @return filtered code hashes\n     */\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n    /**\n     * @notice Get a specific operator\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return address of the operator\n     */\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Get the ith filtered code hash\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return the code hash\n     */\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n    /**\n     * @notice Is the address registered\n     * @param addr address to check\n     * @return is it registered\n     */\n    function isRegistered(address addr) external returns (bool);\n\n    /**\n     * @notice Get the code hash for this address\n     * @param addr address to check\n     * @return the code hash\n     */\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/polygon/child/land/PolygonLandBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\n\npragma solidity 0.8.2;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"../../../common/BaseWithStorage/ERC721BaseTokenV2.sol\";\nimport \"../../../common/interfaces/IPolygonLand.sol\";\n\nabstract contract PolygonLandBaseToken is IPolygonLand, Initializable, ERC721BaseTokenV2 {\n    using AddressUpgradeable for address;\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n\n    event Minter(address minter, bool enabled);\n\n    modifier validQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) {\n        require(size == 1 || size == 3 || size == 6 || size == 12 || size == 24, \"Invalid size\");\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        _;\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() public pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() public pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external view returns (uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id % GRID_SIZE;\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external view returns (uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id / GRID_SIZE;\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\"https://api.sandbox.game/lands/\", StringsUpgradeable.toString(id), \"/metadata.json\")\n            );\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param user The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external virtual override {\n        require(isMinter(_msgSender()), \"!AUTHORIZED\");\n        _mintQuad(user, size, x, y, data);\n    }\n\n    function _mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"to is zero address\");\n        require(!exists(size, x, y), \"Already minted\");\n\n        uint256 quadId;\n        uint256 id = x + y * GRID_SIZE;\n\n        if (size == 1) {\n            quadId = id;\n        } else if (size == 3) {\n            quadId = LAYER_3x3 + id;\n        } else if (size == 6) {\n            quadId = LAYER_6x6 + id;\n        } else if (size == 12) {\n            quadId = LAYER_12x12 + id;\n        } else if (size == 24) {\n            quadId = LAYER_24x24 + id;\n        }\n\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(address(0), to, _idInPath(i, size, x, y));\n        }\n\n        _owners[quadId] = uint256(uint160(address(to)));\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(_msgSender(), address(0), to, size, x, y, data);\n    }\n\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(_msgSender(), from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(_msgSender(), from, to, size, x, y, data);\n    }\n\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public override(ILandToken, ERC721BaseTokenV2) {\n        super.batchTransferFrom(from, to, ids, data);\n    }\n\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view override validQuad(size, x, y) returns (bool) {\n        if (_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] != 0) return true;\n        uint256 toX = x + size;\n        uint256 toY = y + size;\n        if (size <= 12) {\n            if (_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] != 0) return true;\n        } else {\n            for (uint256 x12i = x; x12i < toX; x12i += 12) {\n                for (uint256 y12i = y; y12i < toY; y12i += 12) {\n                    uint256 id12x12 = LAYER_12x12 + x12i + y12i * GRID_SIZE;\n                    if (_owners[id12x12] != 0) return true;\n                }\n            }\n        }\n\n        if (size <= 6) {\n            if (_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE] != 0) return true;\n        } else {\n            for (uint256 x6i = x; x6i < toX; x6i += 6) {\n                for (uint256 y6i = y; y6i < toY; y6i += 6) {\n                    uint256 id6x6 = LAYER_6x6 + x6i + y6i * GRID_SIZE;\n                    if (_owners[id6x6] != 0) return true;\n                }\n            }\n        }\n\n        if (size <= 3) {\n            if (_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE] != 0) return true;\n        } else {\n            for (uint256 x3i = x; x3i < toX; x3i += 3) {\n                for (uint256 y3i = y; y3i < toY; y3i += 3) {\n                    uint256 id3x3 = LAYER_3x3 + x3i + y3i * GRID_SIZE;\n                    if (_owners[id3x3] != 0) return true;\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < size * size; i++) {\n            if (_owners[_idInPath(i, size, x, y)] != 0) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Enable or disable the ability of `minter` to transfer tokens of all (minter rights).\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(_msgSender() == _admin, \"only admin is allowed to add minters\");\n        require(minter != address(0), \"PolygonLand: Invalid address\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal validQuad(size, x, y) {\n        if (size == 1) {\n            uint256 id1x1 = x + y * GRID_SIZE;\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(uint160(address(to)));\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _idInPath(\n        uint256 i,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        uint256 row = i / size;\n        if (row % 2 == 0) {\n            // allow ids to follow a path in a quad\n            return (x + (i % size)) + ((y + row) * GRID_SIZE);\n        } else {\n            return ((x + size) - (1 + (i % size))) + ((y + row) * GRID_SIZE);\n        }\n    }\n\n    function _regroup(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        if (size == 3) {\n            _regroup3x3(from, to, x, y, true);\n        } else if (size == 6) {\n            _regroup6x6(from, to, x, y, true);\n        } else if (size == 12) {\n            _regroup12x12(from, to, x, y, true);\n        } else if (size == 24) {\n            _regroup24x24(from, to, x, y, true);\n        }\n    }\n\n    function _regroup3x3(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_3x3 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 3; xi++) {\n            for (uint256 yi = y; yi < y + 3; yi++) {\n                ownerOfAll = _checkAndClear(from, xi + yi * GRID_SIZE) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(3, x, y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup6x6(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_6x6 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 6; xi += 3) {\n            for (uint256 yi = y; yi < y + 6; yi += 3) {\n                bool ownAllIndividual = _regroup3x3(from, to, xi, yi, false);\n                uint256 id3x3 = LAYER_3x3 + xi + yi * GRID_SIZE;\n                uint256 owner3x3 = _owners[id3x3];\n                if (owner3x3 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner3x3 == uint256(uint160(address(from))), \"not owner of 3x3 quad\");\n                    }\n                    _owners[id3x3] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner3x3 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(6, x, y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup12x12(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_12x12 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 12; xi += 6) {\n            for (uint256 yi = y; yi < y + 12; yi += 6) {\n                bool ownAllIndividual = _regroup6x6(from, to, xi, yi, false);\n                uint256 id6x6 = LAYER_6x6 + xi + yi * GRID_SIZE;\n                uint256 owner6x6 = _owners[id6x6];\n                if (owner6x6 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner6x6 == uint256(uint160(address(from))), \"not owner of 6x6 quad\");\n                    }\n                    _owners[id6x6] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner6x6 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(12, x, y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup24x24(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_24x24 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 24; xi += 12) {\n            for (uint256 yi = y; yi < y + 24; yi += 12) {\n                bool ownAllIndividual = _regroup12x12(from, to, xi, yi, false);\n                uint256 id12x12 = LAYER_12x12 + xi + yi * GRID_SIZE;\n                uint256 owner12x12 = _owners[id12x12];\n                if (owner12x12 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner12x12 == uint256(uint160(address(from))), \"not owner of 12x12 quad\");\n                    }\n                    _owners[id12x12] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner12x12 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(uint160(address(from))),\n                    \"not owner of all sub quads not parent quad\"\n                );\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll || _owners[quadId] == uint256(uint160(address(from)));\n    }\n\n    function _ownerOfQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal returns (address) {\n        uint256 layer;\n        uint256 parentSize = size * 2;\n        if (size == 3) {\n            layer = LAYER_3x3;\n        } else if (size == 6) {\n            layer = LAYER_6x6;\n        } else if (size == 12) {\n            layer = LAYER_12x12;\n        } else if (size == 24) {\n            layer = LAYER_24x24;\n        } else {\n            require(false, \"Invalid size\");\n        }\n\n        address owner = address(uint160(_owners[layer + (x / size) * size + ((y / size) * size) * GRID_SIZE]));\n        if (owner != address(0)) {\n            return owner;\n        } else if (size < 24) {\n            return _ownerOfQuad(parentSize, x, y);\n        }\n        return address(0);\n    }\n\n    function _ownerOf(uint256 id) internal view override returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if ((owner1x1 & BURNED_FLAG) == BURNED_FLAG) {\n            return address(0);\n        }\n\n        if (owner1x1 != 0) {\n            return address(uint160(owner1x1)); //we check if the quad exists as an 1x1 quad, then 3x3, and so on..\n        } else {\n            address owner3x3 = address(uint160(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]));\n            if (owner3x3 != address(0)) {\n                return owner3x3;\n            } else {\n                address owner6x6 = address(uint160(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]));\n                if (owner6x6 != address(0)) {\n                    return owner6x6;\n                } else {\n                    address owner12x12 =\n                        address(uint160(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]));\n                    if (owner12x12 != address(0)) {\n                        return owner12x12;\n                    } else {\n                        return address(uint160(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]));\n                    }\n                }\n            }\n        }\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require((owner & BURNED_FLAG) != BURNED_FLAG, \"not owner\");\n            require(address(uint160(owner)) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        override\n        returns (address owner, bool operatorEnabled)\n    {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if ((owner1x1 & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n            return (owner, operatorEnabled);\n        }\n\n        if (owner1x1 != 0) {\n            owner = address(uint160(owner1x1));\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n        } else {\n            address owner3x3 = address(uint160(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]));\n            if (owner3x3 != address(uint160(0))) {\n                owner = owner3x3;\n                operatorEnabled = false;\n            } else {\n                address owner6x6 = address(uint160(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]));\n                if (owner6x6 != address(uint160(0))) {\n                    owner = owner6x6;\n                    operatorEnabled = false;\n                } else {\n                    address owner12x12 =\n                        address(uint160(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]));\n                    if (owner12x12 != address(uint160(0))) {\n                        owner = owner12x12;\n                        operatorEnabled = false;\n                    } else {\n                        owner = address(uint160(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]));\n                        operatorEnabled = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"../../../common/BaseWithStorage/ERC721BaseTokenV2.sol\";\nimport \"../../../common/interfaces/IPolygonLand.sol\";\n\n/**\n * @title PolygonLandBaseTokenV2\n * @author The Sandbox\n * @notice Implement LAND and quad functionalities on top of an ERC721 token\n * @dev This contract implements a quad tree structure to handle groups of ERC721 tokens at once\n */\nabstract contract PolygonLandBaseTokenV2 is IPolygonLand, Initializable, ERC721BaseTokenV2 {\n    using AddressUpgradeable for address;\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n\n    event Minter(address indexed minter, bool enabled);\n\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length, \"PolygonLandBaseTokenV2: sizes's and x's length are different\");\n        require(xs.length == ys.length, \"PolygonLandBaseTokenV2: x's and y's length are different\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(_msgSender(), from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to transfer tokens of all (minter rights).\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external onlyAdmin {\n        require(minter != address(0), \"PolygonLand: Invalid address\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data for transfer\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(_msgSender(), from, to, size, x, y, data);\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param user The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external virtual override {\n        _isValidQuad(size, x, y);\n        require(isMinter(_msgSender()), \"!AUTHORIZED\");\n        _mintQuad(user, size, x, y, data);\n    }\n\n    /**\n     * @notice Checks if a parent quad has child quads already minted.\n     *  Then mints the rest child quads and transfers the parent quad.\n     *  Should only be called by the tunnel.\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external virtual {\n        require(isMinter(msg.sender), \"!AUTHORIZED\");\n        require(to != address(0), \"to is zero address\");\n\n        if (exists(size, x, y)) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external pure returns (uint256) {\n        return _getX(id);\n    }\n\n    /// @inheritdoc ERC721BaseTokenV2\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public virtual override(ILandToken, ERC721BaseTokenV2) {\n        super.batchTransferFrom(from, to, ids, data);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external pure returns (uint256) {\n        return _getY(id);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() public pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size size of the\n    /// @param x x coordinate of the quad\n    /// @param y y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view override returns (bool) {\n        _isValidQuad(size, x, y);\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() public pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\"https://api.sandbox.game/lands/\", StringsUpgradeable.toString(id), \"/metadata.json\")\n            );\n    }\n\n    function _isValidQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure {\n        require(size == 1 || size == 3 || size == 6 || size == 12 || size == 24, \"Invalid size\");\n        require(x % size == 0, \"Invalid x coordinate\");\n        require(y % size == 0, \"Invalid y coordinate\");\n        require(x <= GRID_SIZE - size, \"x out of bounds\");\n        require(y <= GRID_SIZE - size, \"y out of bounds\");\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        _isValidQuad(size, x, y);\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(uint160(address(to)));\n        } else {\n            _regroupQuad(from, to, Land({x: x, y: y, size: size}), true, size / 2);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"to is zero address\");\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkOwner(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            require(_owners[_id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, _id);\n        }\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n\n    /**\n     * @dev checks if the child quads in the parent quad (size, x, y) are owned by msg.sender.\n     * It recursively checks child quad of every size(exculding Lands of 1x1 size) are minted or not.\n     * Quad which are minted are pushed into quadMinted to also check if every Land of size 1x1 in\n     * the parent quad is minted or not. While checking if the every child Quad and Land is minted it\n     * also checks and clear the owner for quads which are minted. Finally it checks if the new owner\n     * if is a contract can handle ERC721 tokens or not and transfers the parent quad to new owner.\n     * @param to The address to which the ownership of the quad will be transferred\n     * @param size The size of the quad being minted and transfered\n     * @param x The x-coordinate of the top-left corner of the quad being minted.\n     * @param y The y-coordinate of the top-left corner of the quad being minted.\n     * @param y The y-coordinate of the top-left corner of the quad being minted.\n     */\n    function _mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have. Would be used to push the minted Quads.\n        Land[] memory quadMinted = new Land[](64);\n        // index of last minted quad pushed on quadMinted Array\n        uint256 index;\n        uint256 landMinted;\n\n        // if size of the Quad in land struct to be transfered is greater than 3 we check recursivly if the child quads are minted or not.\n        if (size > 3) {\n            (index, landMinted) = _checkAndClearOwner(\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        // Lopping around the Quad in land struct to generate ids of 1x1 land token and checking if they are owned by msg.sender\n        {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 _id = _idInPath(i, size, x, y);\n                // checking land with token id \"_id\" is in the quadMinted array.\n                bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n                if (isAlreadyMinted) {\n                    // if land is in the quadMinted array there just emitting transfer event\n                    emit Transfer(msg.sender, to, _id);\n                } else {\n                    if (address(uint160(_owners[_id])) == msg.sender) {\n                        if (_operators[_id] != address(0)) _operators[_id] = address(0);\n                        landMinted += 1;\n                        emit Transfer(msg.sender, to, _id);\n                    } else {\n                        // else is checked if owned by the msg.sender or not. If it is not owned by msg.sender it should not have an owner.\n                        require(_owners[_id] == 0, \"Already minted\");\n\n                        emit Transfer(address(0), to, _id);\n                    }\n                }\n            }\n        }\n\n        // checking if the new owner \"to\" is a contract. If yes, checking if it could handle ERC721 tokens.\n        _checkBatchReceiverAcceptQuadAndClearOwner(quadMinted, index, landMinted, to, size, x, y, data);\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n        _numNFTPerAddress[msg.sender] -= landMinted;\n    }\n\n    /**\n     * @dev recursivly checks if the child quads are minted in land and push them to the quadMinted array.\n     * if a child quad is minted in land such quads child quads will be skipped such that there is no overlapping\n     * in quads which are minted. it clears the minted child quads owners.\n     * @param land the stuct which has the size x and y co-ordinate of Quad to be checked\n     * @param quadMinted array in which the minted child quad would be pushed\n     * @param landMinted total 1x1 land already minted\n     * @param index index of last element of quadMinted array\n     * @param quadCompareSize the size of the child quads to be checked.\n     * @return the index of last quad pushed in quadMinted array and the total land already minted\n     */\n    function _checkAndClearOwner(\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        //Lopping around the Quad in land struct to check if the child quad are minted or not\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                //checking if the child Quad is minted or not. i.e Checks if the quad is in the quadMinted array.\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                // if child quad is not already in the quadMinted array.\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = address(uint160(_owners[id]));\n                    // owner of the child quad is checked to be owned by msg.sender else should not be owned by anyone.\n                    if (owner == msg.sender) {\n                        // if child quad is minted it would be pushed in quadMinted array.\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        // index of quadMinted is increased\n                        index++;\n                        // total land minted is increase by the number if land of 1x1 in child quad\n                        landMinted += quadCompareSize * quadCompareSize;\n                        //owner is cleared\n                        _owners[id] = 0;\n                    } else {\n                        require(owner == address(0), \"Already minted\");\n                    }\n                }\n            }\n        }\n\n        // size of the child quad is set to be the next smaller child quad size (12 => 6 => 3)\n        quadCompareSize = quadCompareSize / 2;\n        // if child quad size is greater than 3 _checkAndClearOwner is checked for new child quads in the  quad in land struct.\n        if (quadCompareSize >= 3)\n            (index, landMinted) = _checkAndClearOwner(land, quadMinted, landMinted, index, quadCompareSize);\n        return (index, landMinted);\n    }\n\n    /// @dev checks the owner of land with 'tokenId' to be 'from' and clears it\n    /// @param from the address to be checked agains the owner of the land\n    /// @param tokenId th id of land\n    /// @return bool for if land is owned by 'from' or not.\n    function _checkAndClearLandOwner(address from, uint256 tokenId) internal returns (bool) {\n        uint256 currentOwner = _owners[tokenId];\n        if (currentOwner != 0) {\n            require((currentOwner & BURNED_FLAG) != BURNED_FLAG, \"not owner\");\n            require(address(uint160(currentOwner)) == from, \"not owner\");\n            _owners[tokenId] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    /// @dev checks if the receiver of the quad(size, x, y) is a contact. If yes can it handle ERC721 tokens. It also clears owner of 1x1 land's owned by msg.sender.\n    /// @param quadMinted - an array of Land structs in which the minted child quad or Quad to be transfered are.\n    /// @param landMinted - the total amount of land that has been minted\n    /// @param index - the index of the last element in the quadMinted array\n    /// @param to the address of the new owner of Quad to be transfered\n    /// @param size The size of the quad being minted and transfered\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        // checks if to is a contract and supports ERC721_MANDATORY_RECEIVER interfaces. if it doesn't it just clears the owner of 1x1 lands in quad(size, x, y)\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            // array to push minted 1x1 land\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            // index of last land pushed in idsToTransfer array\n            uint256 transferIndex;\n            // array to push ids to be minted\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            // index of last land pushed in idsToMint array\n            uint256 mintIndex;\n\n            // iterating over every 1x1 land in the quad to be pushed in the above arrays\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    // if land is in the quads already minted it just pushed in to the idsToTransfer array\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (address(uint160(_owners[id])) == msg.sender) {\n                    // if it is owned by the msg.sender owner data is removed and it is pused in to idsToTransfer array\n                    _owners[id] = 0;\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    // else it is not owned by any one and and pushed in teh idsToMint array\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n\n            // checking if \"to\" contact can handle ERC721 tokens\n            require(\n                _checkOnERC721BatchReceived(msg.sender, address(0), to, idsToMint, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n            require(\n                _checkOnERC721BatchReceived(msg.sender, msg.sender, to, idsToTransfer, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        } else {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n                if (address(uint160(_owners[id])) == msg.sender) _owners[id] = 0;\n            }\n        }\n    }\n\n    function _getX(uint256 id) internal pure returns (uint256) {\n        return (id & ~LAYER) % GRID_SIZE;\n    }\n\n    function _getY(uint256 id) internal pure returns (uint256) {\n        return (id & ~LAYER) / GRID_SIZE;\n    }\n\n    function _isQuadMinted(\n        Land[] memory mintedLand,\n        Land memory quad,\n        uint256 index\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < index; i++) {\n            Land memory land = mintedLand[i];\n            if (\n                land.size > quad.size &&\n                quad.x >= land.x &&\n                quad.x < land.x + land.size &&\n                quad.y >= land.y &&\n                quad.y < land.y + land.size\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _getQuadLayer(uint256 size)\n        internal\n        pure\n        returns (\n            uint256 layer,\n            uint256 parentSize,\n            uint256 childLayer\n        )\n    {\n        if (size == 1) {\n            layer = LAYER_1x1;\n            parentSize = 3;\n        } else if (size == 3) {\n            layer = LAYER_3x3;\n            parentSize = 6;\n        } else if (size == 6) {\n            layer = LAYER_6x6;\n            parentSize = 12;\n            childLayer = LAYER_3x3;\n        } else if (size == 12) {\n            layer = LAYER_12x12;\n            parentSize = 24;\n            childLayer = LAYER_6x6;\n        } else if (size == 24) {\n            layer = LAYER_24x24;\n            childLayer = LAYER_12x12;\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _getQuadId(\n        uint256 layer,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        return layer + x + y * GRID_SIZE;\n    }\n\n    function _checkOwner(\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        uint256 quadCompareSize\n    ) internal view {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n\n        if (size <= quadCompareSize) {\n            // when the size of the quad is smaller than the quadCompareSize(size to be compared with),\n            // then it is checked if the bigger quad which encapsulates the quad to be minted\n            // of with size equals the quadCompareSize has been minted or not\n            require(\n                _owners[\n                    _getQuadId(layer, (x / quadCompareSize) * quadCompareSize, (y / quadCompareSize) * quadCompareSize)\n                ] == 0,\n                \"Already minted\"\n            );\n        } else {\n            // when the size is smaller than the quadCompare size the owner of all the smaller quads with size\n            // quadCompare size in the quad to be minted are checked if they are minted or not\n            uint256 toX = x + size;\n            uint256 toY = y + size;\n            for (uint256 xi = x; xi < toX; xi += quadCompareSize) {\n                for (uint256 yi = y; yi < toY; yi += quadCompareSize) {\n                    require(_owners[_getQuadId(layer, xi, yi)] == 0, \"Already minted\");\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3) _checkOwner(size, x, y, quadCompareSize);\n    }\n\n    function _idInPath(\n        uint256 i,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        uint256 row = i / size;\n        if (row % 2 == 0) {\n            // allow ids to follow a path in a quad\n            return _getQuadId(LAYER_1x1, (x + (i % size)), (y + row));\n        } else {\n            return _getQuadId(LAYER_1x1, (x + size) - (1 + (i % size)), (y + row));\n        }\n    }\n\n    /// @dev checks if the Land's child quads are owned by the from address and clears all the previous owners\n    /// if all the child quads are not owned by the \"from\" address then the owner of parent quad to the land\n    /// is checked if owned by the \"from\" address. If from is the owner then land owner is set to \"to\" address\n    /// @param from address of the previous owner\n    /// @param to address of the new owner\n    /// @param land the quad to be regrouped and transferred\n    /// @param set for setting the new owner\n    /// @param childQuadSize  size of the child quad to be checked for owner in the regrouping\n    function _regroupQuad(\n        address from,\n        address to,\n        Land memory land,\n        bool set,\n        uint256 childQuadSize\n    ) internal returns (bool) {\n        (uint256 layer, , uint256 childLayer) = _getQuadLayer(land.size);\n        uint256 quadId = _getQuadId(layer, land.x, land.y);\n        bool ownerOfAll = true;\n\n        {\n            // double for loop iterates and checks owner of all the smaller quads in land\n            for (uint256 xi = land.x; xi < land.x + land.size; xi += childQuadSize) {\n                for (uint256 yi = land.y; yi < land.y + land.size; yi += childQuadSize) {\n                    uint256 ownerChild;\n                    bool ownAllIndividual;\n                    if (childQuadSize < 3) {\n                        // case when the smaller quad is 1x1,\n                        ownAllIndividual = _checkAndClearLandOwner(from, _getQuadId(LAYER_1x1, xi, yi)) && ownerOfAll;\n                    } else {\n                        // recursively calling the _regroupQuad function to check the owner of child quads.\n                        ownAllIndividual = _regroupQuad(\n                            from,\n                            to,\n                            Land({x: xi, y: yi, size: childQuadSize}),\n                            false,\n                            childQuadSize / 2\n                        );\n                        uint256 idChild = _getQuadId(childLayer, xi, yi);\n                        ownerChild = _owners[idChild];\n                        if (ownerChild != 0) {\n                            // checking the owner of child quad\n                            if (!ownAllIndividual) {\n                                require(ownerChild == uint256(uint160(from)), \"not owner of child Quad\");\n                            }\n                            // clearing owner of child quad\n                            _owners[idChild] = 0;\n                        }\n                    }\n                    // ownerOfAll should be true if \"from\" is owner of all the child quads itereated over\n                    ownerOfAll = (ownAllIndividual || ownerChild != 0) && ownerOfAll;\n                }\n            }\n        }\n\n        // if set is true it check if the \"from\" is owner of all else checks for the owner of parent quad is\n        // owned by \"from\" and sets the owner for the id of land to \"to\" address.\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(land.size, land.x, land.y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(uint160(to));\n            return true;\n        }\n\n        return ownerOfAll;\n    }\n\n    function _ownerOfQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal view returns (address) {\n        (uint256 layer, uint256 parentSize, ) = _getQuadLayer(size);\n        address owner = address(uint160(_owners[_getQuadId(layer, (x / size) * size, (y / size) * size)]));\n        if (owner != address(0)) {\n            return owner;\n        } else if (size < 24) {\n            return _ownerOfQuad(parentSize, x, y);\n        }\n        return address(0);\n    }\n\n    function _getQuadById(uint256 id)\n        internal\n        pure\n        returns (\n            uint256 size,\n            uint256 x,\n            uint256 y\n        )\n    {\n        x = _getX(id);\n        y = _getY(id);\n        uint256 layer = id & LAYER;\n        if (layer == LAYER_1x1) {\n            size = 1;\n        } else if (layer == LAYER_3x3) {\n            size = 3;\n        } else if (layer == LAYER_6x6) {\n            size = 6;\n        } else if (layer == LAYER_12x12) {\n            size = 12;\n        } else if (layer == LAYER_24x24) {\n            size = 24;\n        } else {\n            require(false, \"Invalid token id\");\n        }\n    }\n\n    function _ownerOf(uint256 id) internal view override returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        (uint256 size, uint256 x, uint256 y) = _getQuadById(id);\n        require(x % size == 0, \"x coordinate: Invalid token id\");\n        require(y % size == 0, \"y coordinate: Invalid token id\");\n        if (size == 1) {\n            uint256 owner1x1 = _owners[id];\n            return (owner1x1 & BURNED_FLAG) == BURNED_FLAG ? address(0) : _ownerOfQuad(size, x, y);\n        }\n        return _ownerOfQuad(size, x, y);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        override\n        returns (address owner, bool operatorEnabled)\n    {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if ((owner1x1 & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n            return (owner, operatorEnabled);\n        }\n\n        if (owner1x1 != 0) {\n            owner = address(uint160(owner1x1));\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n        } else {\n            owner = _ownerOfQuad(3, (x * 3) / 3, (y * 3) / 3);\n            operatorEnabled = false;\n        }\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/polygon/child/land/PolygonLandV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./PolygonLandBaseToken.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title LAND token on L2\ncontract PolygonLandV1 is PolygonLandBaseToken, ERC2771Handler {\n    function initialize(address trustedForwarder) external initializer {\n        _admin = _msgSender();\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyAdmin {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/polygon/child/land/PolygonLandV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./PolygonLandBaseTokenV2.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"../../../OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol\";\n\n/// @title LAND token on L2\ncontract PolygonLandV2 is PolygonLandBaseTokenV2, ERC2771Handler, OperatorFiltererUpgradeable {\n    using AddressUpgradeable for address;\n\n    event OperatorRegistrySet(address indexed registry);\n\n    function initialize(address trustedForwarder) external initializer {\n        _admin = _msgSender();\n        __ERC2771Handler_initialize(trustedForwarder);\n        emit AdminChanged(address(0), _admin);\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyAdmin {\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderSet(trustedForwarder);\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public override onlyAllowedOperatorApproval(operator) {\n        super.approveFor(sender, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) public override onlyAllowedOperatorApproval(operator) {\n        super.approve(operator, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override onlyAllowedOperator(from) {\n        super.transferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n        super.setApprovalForAll(operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public override onlyAllowedOperatorApproval(operator) {\n        super.setApprovalForAllFor(sender, operator, approved);\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.\n    /// @dev can only be called by admin.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription 'true' or to copy the list 'false'.\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAdmin {\n        require(subscriptionOrRegistrantToCopy != address(0), \"PolygonLandV2: subscription can't be zero address\");\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(address registry) external virtual onlyAdmin {\n        operatorFilterRegistry = IOperatorFilterRegistry(registry);\n        emit OperatorRegistrySet(registry);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/polygon/child/sand/PolygonSand.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"../../../Sand/SandBaseToken.sol\";\n\ncontract PolygonSand is SandBaseToken, Ownable, ERC2771Handler {\n    address public childChainManagerProxy;\n\n    constructor(\n        address _childChainManagerProxy,\n        address trustedForwarder,\n        address sandAdmin,\n        address executionAdmin\n    ) SandBaseToken(sandAdmin, executionAdmin, address(0), 0) {\n        require(_childChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        childChainManagerProxy = _childChainManagerProxy;\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @notice update the ChildChainManager Proxy address\n    /// @param newChildChainManagerProxy address of the new childChainManagerProxy\n    function updateChildChainManager(address newChildChainManagerProxy) external onlyOwner {\n        require(newChildChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        childChainManagerProxy = newChildChainManagerProxy;\n    }\n\n    /// @notice called when tokens are deposited on root chain\n    /// @param user user address for whom deposit is being done\n    /// @param depositData abi encoded amount\n    function deposit(address user, bytes calldata depositData) external {\n        require(_msgSender() == childChainManagerProxy, \"You're not allowed to deposit\");\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /// @notice called when user wants to withdraw tokens back to root chain\n    /// @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n    /// @param amount amount to withdraw\n    function withdraw(uint256 amount) external {\n        _burn(_msgSender(), amount);\n    }\n\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/Sand/SandBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/extensions/ERC20BasicApproveExtension.sol\";\nimport \"../common/BaseWithStorage/ERC20/ERC20BaseToken.sol\";\n\ncontract SandBaseToken is ERC20BaseToken, ERC20BasicApproveExtension {\n    constructor(\n        address sandAdmin,\n        address executionAdmin,\n        address beneficiary,\n        uint256 amount\n    ) ERC20BaseToken(\"SAND\", \"SAND\", sandAdmin, executionAdmin) {\n        _admin = sandAdmin;\n        if (beneficiary != address(0)) {\n            uint256 initialSupply = amount * (1 ether);\n            _mint(beneficiary, initialSupply);\n        }\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/test/FakeChildChainManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n//import \"../polygon/child/asset/PolygonAssetERC1155.sol\";\nimport \"../test/MockERC1155Asset.sol\";\nimport \"../polygon/child/sand/PolygonSand.sol\";\n\n/// @dev This is NOT a secure ChildChainManager contract implementation!\n/// DO NOT USE in production.\n\ncontract FakeChildChainManager {\n    address public polygonAsset;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() {}\n\n    function setPolygonAsset(address _polygonAsset) external {\n        polygonAsset = _polygonAsset;\n    }\n\n    function callDeposit(address user, bytes calldata depositData) external {\n        MockERC1155Asset(polygonAsset).deposit(user, depositData);\n    }\n\n    function callSandDeposit(\n        address polygonSand,\n        address user,\n        bytes calldata depositData\n    ) external {\n        PolygonSand(polygonSand).deposit(user, depositData);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/test/MockERC1155Asset.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\n/* solhint-disable no-empty-blocks */\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC1155/presets/ERC1155PresetMinterPauser.sol\";\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\n\ncontract MockERC1155Asset is ERC1155PresetMinterPauser, Ownable {\n    event Bouncer(address indexed bouncer, bool indexed enabled);\n\n    constructor(string memory uri) ERC1155PresetMinterPauser(uri) Ownable() {}\n\n    function setBouncer(address bouncer, bool enabled) external {\n        emit Bouncer(bouncer, enabled);\n    }\n\n    function mint(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256 supply,\n        address owner,\n        bytes calldata data\n    ) external {\n        _mint(owner, packId, supply, data);\n    }\n\n    function deposit(address user, bytes calldata depositData) external {\n        (uint256[] memory ids, uint256[] memory amounts, bytes memory data) =\n            abi.decode(depositData, (uint256[], uint256[], bytes));\n        emit TransferBatch(_msgSender(), address(0), user, ids, amounts);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/test/MockOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\npragma solidity 0.8.2;\n\nimport {IOperatorFilterRegistry} from \"../OperatorFilterer/interfaces/IOperatorFilterRegistry.sol\";\nimport {Ownable} from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts-0.8/utils/structs/EnumerableSet.sol\";\nimport {OperatorFilterRegistryEvents} from \"./OperatorFilterRegistryEvents.sol\";\n\n/**\n * @title  MockOperatorFilterRegistry\n * @notice Made based on the OperatorFilterRegistry of openSea at https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/OperatorFilterRegistry.sol\n * @notice This contracts allows tokens or token owners to register specific addresses or codeHashes that may be\n * *       restricted according to the isOperatorAllowed function.\n */\ncontract MockOperatorFilterRegistry is IOperatorFilterRegistry, OperatorFilterRegistryEvents {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @dev initialized accounts have a nonzero codehash (see https://eips.ethereum.org/EIPS/eip-1052)\n    /// Note that this will also be a smart contract's codehash when making calls from its constructor.\n    bytes32 public constant EOA_CODEHASH = keccak256(\"\");\n\n    mapping(address => EnumerableSet.AddressSet) private _filteredOperators;\n    mapping(address => EnumerableSet.Bytes32Set) private _filteredCodeHashes;\n    mapping(address => address) private _registrations;\n    mapping(address => EnumerableSet.AddressSet) private _subscribers;\n\n    constructor(address _defaultSubscribtion, address[] memory _blacklistedAddresses) {\n        _registrations[_defaultSubscribtion] = _defaultSubscribtion;\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[_defaultSubscribtion];\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[_defaultSubscribtion];\n        for (uint256 i; i < _blacklistedAddresses.length; i++) {\n            filteredOperatorsRef.add(_blacklistedAddresses[i]);\n            bytes32 codeHash = _blacklistedAddresses[i].codehash;\n            filteredCodeHashesRef.add(codeHash);\n        }\n    }\n\n    /**\n     * @notice restricts method caller to the address or EIP-173 \"owner()\"\n     */\n    modifier onlyAddressOrOwner(address addr) {\n        if (msg.sender != addr) {\n            try Ownable(addr).owner() returns (address owner) {\n                if (msg.sender != owner) {\n                    revert(\"Only Address or Owner\");\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"Not Ownable\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\n     *         true if supplied registrant address is not registered.\n     */\n    function isOperatorAllowed(address registrant, address operator) external view override returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            EnumerableSet.AddressSet storage filteredOperatorsRef;\n            EnumerableSet.Bytes32Set storage filteredCodeHashesRef;\n\n            filteredOperatorsRef = _filteredOperators[registration];\n            filteredCodeHashesRef = _filteredCodeHashes[registration];\n\n            if (filteredOperatorsRef.contains(operator)) {\n                revert(\"Address is filtered\");\n            }\n            if (operator.code.length > 0) {\n                bytes32 codeHash = operator.codehash;\n                if (filteredCodeHashesRef.contains(codeHash)) {\n                    revert(\"Codehash is filtered\");\n                }\n            }\n        }\n        return true;\n    }\n\n    //////////////////\n    // AUTH METHODS //\n    //////////////////\n\n    /**\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\n     */\n    function register(address registrant) external override onlyAddressOrOwner(registrant) {\n        if (_registrations[registrant] != address(0)) {\n            revert(\"Already registered\");\n        }\n        _registrations[registrant] = registrant;\n        emit RegistrationUpdated(registrant, true);\n    }\n\n    /**\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\n     *         Note that this does not remove any filtered addresses or codeHashes.\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\n     */\n    function unregister(address registrant) external onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            _subscribers[registration].remove(registrant);\n            emit SubscriptionUpdated(registrant, registration, false);\n        }\n        _registrations[registrant] = address(0);\n        emit RegistrationUpdated(registrant, false);\n    }\n\n    /**\n     * @notice Registers an address with the registry and \"subscribes\" to another address's filtered operators and codeHashes.\n     */\n    function registerAndSubscribe(address registrant, address subscription)\n        external\n        override\n        onlyAddressOrOwner(registrant)\n    {\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            revert(\"Already registered\");\n        }\n        if (registrant == subscription) {\n            revert(\"Cannot subscribe to self\");\n        }\n        address subscriptionRegistration = _registrations[subscription];\n        if (subscriptionRegistration == address(0)) {\n            revert(\"Subscribtion not registered\");\n        }\n        if (subscriptionRegistration != subscription) {\n            revert(\"Cannot subscribe to registrant with subscribtion\");\n        }\n\n        _registrations[registrant] = subscription;\n        _subscribers[subscription].add(registrant);\n        emit RegistrationUpdated(registrant, true);\n        emit SubscriptionUpdated(registrant, subscription, true);\n    }\n\n    /**\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\n     *         address without subscribing.\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy)\n        external\n        override\n        onlyAddressOrOwner(registrant)\n    {\n        if (registrantToCopy == registrant) {\n            revert(\"Cannot copy from self\");\n        }\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            revert(\"Already registered\");\n        }\n        address registrantRegistration = _registrations[registrantToCopy];\n        if (registrantRegistration == address(0)) {\n            revert(\"Registrant to copy from not registered\");\n        }\n        _registrations[registrant] = registrant;\n        emit RegistrationUpdated(registrant, true);\n        _copyEntries(registrant, registrantToCopy);\n    }\n\n    /**\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\n     */\n    function updateOperator(\n        address registrant,\n        address operator,\n        bool filtered\n    ) external override onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            revert(\"Cannot update while subscribed\");\n        }\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\n\n        if (!filtered) {\n            bool removed = filteredOperatorsRef.remove(operator);\n            if (!removed) {\n                revert(\"Address not filtered\");\n            }\n        } else {\n            bool added = filteredOperatorsRef.add(operator);\n            if (!added) {\n                revert(\"Address already filtered\");\n            }\n        }\n        emit OperatorUpdated(registrant, operator, filtered);\n    }\n\n    /**\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\n     */\n    function updateCodeHash(\n        address registrant,\n        bytes32 codeHash,\n        bool filtered\n    ) external override onlyAddressOrOwner(registrant) {\n        if (codeHash == EOA_CODEHASH) {\n            revert(\"Cannot filter EOAs\");\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            revert(\"Cannot update while subscribed\");\n        }\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\n\n        if (!filtered) {\n            bool removed = filteredCodeHashesRef.remove(codeHash);\n            if (!removed) {\n                revert(\"Codehash not filtered\");\n            }\n        } else {\n            bool added = filteredCodeHashesRef.add(codeHash);\n            if (!added) {\n                revert(\"Codehash already filtered\");\n            }\n        }\n        emit CodeHashUpdated(registrant, codeHash, filtered);\n    }\n\n    /**\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\n     */\n    function updateOperators(\n        address registrant,\n        address[] calldata operators,\n        bool filtered\n    ) external override onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            revert(\"Cannot update while subscribed\");\n        }\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\n        uint256 operatorsLength = operators.length;\n        unchecked {\n            if (!filtered) {\n                for (uint256 i = 0; i < operatorsLength; ++i) {\n                    address operator = operators[i];\n                    bool removed = filteredOperatorsRef.remove(operator);\n                    if (!removed) {\n                        revert(\"Address not filtered\");\n                    }\n                }\n            } else {\n                for (uint256 i = 0; i < operatorsLength; ++i) {\n                    address operator = operators[i];\n                    bool added = filteredOperatorsRef.add(operator);\n                    if (!added) {\n                        revert(\"Address already filtered\");\n                    }\n                }\n            }\n        }\n        emit OperatorsUpdated(registrant, operators, filtered);\n    }\n\n    /**\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\n     */\n    function updateCodeHashes(\n        address registrant,\n        bytes32[] calldata codeHashes,\n        bool filtered\n    ) external override onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            revert(\"Cannot update while subscribed\");\n        }\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\n        uint256 codeHashesLength = codeHashes.length;\n        unchecked {\n            if (!filtered) {\n                for (uint256 i = 0; i < codeHashesLength; ++i) {\n                    bytes32 codeHash = codeHashes[i];\n                    bool removed = filteredCodeHashesRef.remove(codeHash);\n                    if (!removed) {\n                        revert(\"Codehash not filtered\");\n                    }\n                }\n            } else {\n                for (uint256 i = 0; i < codeHashesLength; ++i) {\n                    bytes32 codeHash = codeHashes[i];\n                    if (codeHash == EOA_CODEHASH) {\n                        revert(\"Cannot filter EOAs\");\n                    }\n                    bool added = filteredCodeHashesRef.add(codeHash);\n                    if (!added) {\n                        revert(\"Codehash already filtered\");\n                    }\n                }\n            }\n        }\n        emit CodeHashesUpdated(registrant, codeHashes, filtered);\n    }\n\n    /**\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\n     *         subscription if present.\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\n     *         used.\n     */\n    function subscribe(address registrant, address newSubscription) external override onlyAddressOrOwner(registrant) {\n        if (registrant == newSubscription) {\n            revert(\"Cannot subscribe to self\");\n        }\n        if (newSubscription == address(0)) {\n            revert(\"Cannot subscribe to zero address\");\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration == newSubscription) {\n            revert(\"Already subscribed\");\n        }\n        address newSubscriptionRegistration = _registrations[newSubscription];\n        if (newSubscriptionRegistration == address(0)) {\n            revert(\"New subscription not registered\");\n        }\n        if (newSubscriptionRegistration != newSubscription) {\n            revert(\"Cannot Subscribe to registrant with subscription\");\n        }\n\n        if (registration != registrant) {\n            _subscribers[registration].remove(registrant);\n            emit SubscriptionUpdated(registrant, registration, false);\n        }\n        _registrations[registrant] = newSubscription;\n        _subscribers[newSubscription].add(registrant);\n        emit SubscriptionUpdated(registrant, newSubscription, true);\n    }\n\n    /**\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\n     */\n    function unsubscribe(address registrant, bool copyExistingEntries)\n        external\n        override\n        onlyAddressOrOwner(registrant)\n    {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration == registrant) {\n            revert(\"Not subscribed\");\n        }\n        _subscribers[registration].remove(registrant);\n        _registrations[registrant] = registrant;\n        emit SubscriptionUpdated(registrant, registration, false);\n        if (copyExistingEntries) {\n            _copyEntries(registrant, registration);\n        }\n    }\n\n    /**\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\n     */\n    function copyEntriesOf(address registrant, address registrantToCopy)\n        external\n        override\n        onlyAddressOrOwner(registrant)\n    {\n        if (registrant == registrantToCopy) {\n            revert(\"Cannot copy from self\");\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert(\"Not registered\");\n        }\n        if (registration != registrant) {\n            revert(\"Cannot upgrade while subscribed\");\n        }\n        address registrantRegistration = _registrations[registrantToCopy];\n        if (registrantRegistration == address(0)) {\n            revert(\"Registrant not registered\");\n        }\n        _copyEntries(registrant, registrantToCopy);\n    }\n\n    /// @dev helper to copy entries from registrantToCopy to registrant and emit events\n    function _copyEntries(address registrant, address registrantToCopy) private {\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrantToCopy];\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrantToCopy];\n        uint256 filteredOperatorsLength = filteredOperatorsRef.length();\n        uint256 filteredCodeHashesLength = filteredCodeHashesRef.length();\n        unchecked {\n            for (uint256 i = 0; i < filteredOperatorsLength; ++i) {\n                address operator = filteredOperatorsRef.at(i);\n                bool added = _filteredOperators[registrant].add(operator);\n                if (added) {\n                    emit OperatorUpdated(registrant, operator, true);\n                }\n            }\n            for (uint256 i = 0; i < filteredCodeHashesLength; ++i) {\n                bytes32 codehash = filteredCodeHashesRef.at(i);\n                bool added = _filteredCodeHashes[registrant].add(codehash);\n                if (added) {\n                    emit CodeHashUpdated(registrant, codehash, true);\n                }\n            }\n        }\n    }\n\n    //////////////////\n    // VIEW METHODS //\n    //////////////////\n\n    /**\n     * @notice Get the subscription address of a given registrant, if any.\n     */\n    function subscriptionOf(address registrant) external view override returns (address subscription) {\n        subscription = _registrations[registrant];\n        if (subscription == address(0)) {\n            revert(\"Not registered\");\n        } else if (subscription == registrant) {\n            subscription = address(0);\n        }\n    }\n\n    /**\n     * @notice Get the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscribers(address registrant) external view override returns (address[] memory) {\n        return _subscribers[registrant].values();\n    }\n\n    /**\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscriberAt(address registrant, uint256 index) external view override returns (address) {\n        return _subscribers[registrant].at(index);\n    }\n\n    /**\n     * @notice Returns true if operator is filtered by a given address or its subscription.\n     */\n    function isOperatorFiltered(address registrant, address operator) external view override returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].contains(operator);\n        }\n        return _filteredOperators[registrant].contains(operator);\n    }\n\n    /**\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\n     */\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external view override returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].contains(codeHash);\n        }\n        return _filteredCodeHashes[registrant].contains(codeHash);\n    }\n\n    /**\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\n     */\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external view override returns (bool) {\n        bytes32 codeHash = operatorWithCode.codehash;\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].contains(codeHash);\n        }\n        return _filteredCodeHashes[registrant].contains(codeHash);\n    }\n\n    /**\n     * @notice Returns true if an address has registered\n     */\n    function isRegistered(address registrant) external view override returns (bool) {\n        return _registrations[registrant] != address(0);\n    }\n\n    /**\n     * @notice Returns a list of filtered operators for a given address or its subscription.\n     */\n    function filteredOperators(address registrant) external view override returns (address[] memory) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].values();\n        }\n        return _filteredOperators[registrant].values();\n    }\n\n    /**\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashes(address registrant) external view override returns (bytes32[] memory) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].values();\n        }\n        return _filteredCodeHashes[registrant].values();\n    }\n\n    /**\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredOperatorAt(address registrant, uint256 index) external view override returns (address) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].at(index);\n        }\n        return _filteredOperators[registrant].at(index);\n    }\n\n    /**\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashAt(address registrant, uint256 index) external view override returns (bytes32) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].at(index);\n        }\n        return _filteredCodeHashes[registrant].at(index);\n    }\n\n    /// @dev Convenience method to compute the code hash of an arbitrary contract\n    function codeHashOf(address a) external view override returns (bytes32) {\n        return a.codehash;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/core/src/solc_0.8/test/OperatorFilterRegistryEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ncontract OperatorFilterRegistryEvents {\n    event RegistrationUpdated(address indexed registrant, bool indexed registered);\n\n    event OperatorUpdated(address indexed registrant, address indexed operator, bool indexed filtered);\n\n    event OperatorsUpdated(address indexed registrant, address[] operators, bool indexed filtered);\n\n    event CodeHashUpdated(address indexed registrant, bytes32 indexed codeHash, bool indexed filtered);\n\n    event CodeHashesUpdated(address indexed registrant, bytes32[] codeHashes, bool indexed filtered);\n\n    event SubscriptionUpdated(address indexed registrant, address indexed subscription, bool indexed subscribed);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}