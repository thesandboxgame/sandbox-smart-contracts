{
  "language": "Solidity",
  "sources": {
    "@manifoldxyz/royalty-registry-solidity/contracts/overrides/IRoyaltySplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nstruct Recipient {\n    address payable recipient;\n    uint16 bps;\n}\n\ninterface IRoyaltySplitter is IERC165 {\n    /**\n     * @dev Set the splitter recipients. Total bps must total 10000.\n     */\n    function setRecipients(Recipient[] calldata recipients) external;\n\n    /**\n     * @dev Get the splitter recipients;\n     */\n    function getRecipients() external view returns (Recipient[] memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControlEnumerable} from \"@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\";\nimport {AccessControlUpgradeable} from \"../AccessControlUpgradeable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerable, AccessControlUpgradeable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControlEnumerable\n    struct AccessControlEnumerableStorage {\n        mapping(bytes32 role => EnumerableSet.AddressSet) _roleMembers;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControlEnumerable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlEnumerableStorageLocation = 0xc1f6fe24621ce81ec5827caf0253cadb74709b061630e6b55e82371705932000;\n\n    function _getAccessControlEnumerableStorage() private pure returns (AccessControlEnumerableStorage storage $) {\n        assembly {\n            $.slot := AccessControlEnumerableStorageLocation\n        }\n    }\n\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            $._roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            $._roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"../IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/dependency-royalty-management/contracts/interfaces/IRoyaltyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Recipient} from \"@manifoldxyz/royalty-registry-solidity/contracts/overrides/IRoyaltySplitter.sol\";\n\n/// @title IRoyaltyManager\n/// @notice interface for RoyaltyManager Contract\ninterface IRoyaltyManager {\n    event RecipientSet(address indexed commonRecipient);\n\n    event SplitSet(uint16 commonSplit);\n\n    event RoyaltySet(uint16 royaltyBps, address indexed contractAddress);\n\n    event TrustedForwarderSet(address indexed previousForwarder, address indexed newForwarder);\n\n    event SplitterDeployed(address indexed creator, address indexed recipient, address splitterAddress);\n\n    ///@notice sets the common recipient\n    ///@param _commonRecipient is the common recipient for all the splitters\n    function setRecipient(address payable _commonRecipient) external;\n\n    ///@notice sets the common split\n    ///@param commonSplit split for the common recipient\n    function setSplit(uint16 commonSplit) external;\n\n    ///@notice to be called by the splitters to get the common recipient and split\n    ///@return recipient which has the common recipient and split\n    function getCommonRecipient() external view returns (Recipient memory recipient);\n\n    ///@notice returns the amount of basis points allocated to the creator\n    ///@return creatorSplit the share of creator in bps\n    function getCreatorSplit() external view returns (uint16 creatorSplit);\n\n    ///@notice returns the commonRecipient and EIP2981 royalty split\n    ///@return recipient address of common royalty recipient\n    ///@return royaltySplit contract EIP2981 royalty bps\n    function getRoyaltyInfo() external view returns (address payable recipient, uint16 royaltySplit);\n\n    ///@notice deploys splitter for creator\n    ///@param creator the address of the creator\n    ///@param recipient the wallet of the recipient where they would receive their royalty\n    ///@return creatorSplitterAddress splitter's address deployed for creator\n    function deploySplitter(address creator, address payable recipient)\n        external\n        returns (address payable creatorSplitterAddress);\n\n    ///@notice returns the address of splitter of a creator.\n    ///@param creator the address of the creator\n    ///@return creatorSplitterAddress splitter's address deployed for a creator\n    function getCreatorRoyaltySplitter(address creator) external view returns (address payable creatorSplitterAddress);\n\n    ///@notice returns the EIP2981 royalty split\n    ///@param _contractAddress the address of the contract for which the royalty is required\n    ///@return royaltyBps royalty bps of the contract\n    function getContractRoyalty(address _contractAddress) external view returns (uint16 royaltyBps);\n\n    ///@notice sets the trustedForwarder address to be used by the splitters\n    ///@param _newForwarder is the new trusted forwarder address\n    function setTrustedForwarder(address _newForwarder) external;\n\n    ///@notice get the current trustedForwarder address\n    ///@return trustedForwarder address of current trusted Forwarder\n    function getTrustedForwarder() external view returns (address trustedForwarder);\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/ERC721BaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {IERC721MandatoryTokenReceiver} from \"../interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport {IErrors} from \"../interfaces/IErrors.sol\";\nimport {IERC721BatchOps} from \"../interfaces/IERC721BatchOps.sol\";\nimport {WithSuperOperators} from \"./WithSuperOperators.sol\";\n\n/// @title ERC721BaseTokenCommon\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Basic functionalities of a NFT\n/// @dev ERC721 implementation that supports meta-transactions and super operators\nabstract contract ERC721BaseToken is IERC721, IERC721BatchOps, IERC721Errors, IErrors, Context, WithSuperOperators {\n    using Address for address;\n\n    uint256 internal constant NOT_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\n    uint256 internal constant OPERATOR_FLAG = (2 ** 255);\n    uint256 internal constant NOT_OPERATOR_FLAG = OPERATOR_FLAG - 1;\n    uint256 internal constant BURNED_FLAG = (2 ** 160);\n\n    /// @notice Get the number of tokens owned by an address.\n    /// @param owner The address to look for.\n    /// @return The number of tokens owned by the address.\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _readNumNFTPerAddress(owner);\n    }\n\n    /// @notice Get the owner of a token.\n    /// @param tokenId The id of the token.\n    /// @return owner The address of the token owner.\n    function ownerOf(uint256 tokenId) external view virtual override returns (address owner) {\n        owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /// @notice Get the approved operator for a specific token.\n    /// @param tokenId The id of the token.\n    /// @return The address of the operator.\n    function getApproved(uint256 tokenId) external view virtual override returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        if (operatorEnabled) {\n            return _readOperator(tokenId);\n        }\n        return address(0);\n    }\n\n    /// @notice Return the internal owner data of a Land\n    /// @param tokenId The id of the Land\n    /// @return the owner data (address + burn flag + operatorEnabled)\n    /// @dev for debugging purposes\n    function getOwnerData(uint256 tokenId) external view virtual returns (uint256) {\n        return _readOwnerData(tokenId);\n    }\n\n    /// @notice Check if the sender approved the operator.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function isApprovedForAll(address owner, address operator) external view virtual override returns (bool) {\n        return _isApprovedForAllOrSuperOperator(owner, operator);\n    }\n\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param to The address receiving the token.\n    /// @param tokenId The token being transferred.\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        address msgSender = _msgSender();\n        _doTransfer(msgSender, from, to, tokenId);\n        if (to.code.length > 0 && _checkIERC721MandatoryTokenReceiver(to)) {\n            _checkOnERC721Received(msgSender, from, to, tokenId, \"\");\n        }\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param tokenId The id of the token.\n    /// @param data Additional data.\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) internal {\n        address msgSender = _msgSender();\n        _doTransfer(msgSender, from, to, tokenId);\n        if (to.code.length > 0) {\n            _checkOnERC721Received(msgSender, from, to, tokenId, data);\n        }\n    }\n\n    /// @param msgSender The sender of the transaction\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param to The address receiving the token.\n    /// @param tokenId The token being transferred.\n    function _doTransfer(address msgSender, address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert InvalidAddress();\n        }\n        bool operatorEnabled = _checkFromIsOwner(from, tokenId);\n        bool authorized = msgSender == from || _isApprovedForAllOrSuperOperator(from, msgSender);\n        if (!authorized && !(operatorEnabled && _readOperator(tokenId) == msgSender)) {\n            revert ERC721InsufficientApproval(msgSender, tokenId);\n        }\n        _transferNumNFTPerAddress(from, to, 1);\n        _updateOwnerData(tokenId, to, false);\n        emit Transfer(from, to, tokenId);\n    }\n\n    /// @param from The sender of the token\n    /// @param to The recipient of the token\n    /// @param ids The ids of the tokens\n    /// @param data additional data\n    /// @param safe checks the target contract\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        if (from == address(0) || to == address(0)) {\n            revert InvalidAddress();\n        }\n\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _isApprovedForAllOrSuperOperator(from, msgSender);\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 tokenId = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenId);\n            if (from != owner) {\n                revert ERC721InvalidOwner(from);\n            }\n            if (!authorized && !(operatorEnabled && _readOperator(tokenId) == msgSender)) {\n                revert ERC721InsufficientApproval(msgSender, tokenId);\n            }\n            _updateOwnerData(tokenId, to, false);\n            emit Transfer(from, to, tokenId);\n        }\n        _transferNumNFTPerAddress(from, to, numTokens);\n\n        if (to.code.length > 0) {\n            if (_checkIERC721MandatoryTokenReceiver(to)) {\n                _checkOnERC721BatchReceived(msgSender, from, to, ids, data);\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i++) {\n                    _checkOnERC721Received(msgSender, from, to, ids[i], data);\n                }\n            }\n        }\n    }\n\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param operator The address receiving the approval\n    /// @param approved The determination of the approval\n    function _setApprovalForAll(address from, address operator, bool approved) internal {\n        if (from == address(0)) {\n            revert ERC721InvalidSender(from);\n        }\n        address msgSender = _msgSender();\n        if (msgSender != from && !_isSuperOperator(msgSender)) {\n            revert ERC721InvalidApprover(msgSender);\n        }\n        if (_isSuperOperator(operator)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _writeOperatorForAll(from, operator, approved);\n        emit ApprovalForAll(from, operator, approved);\n    }\n\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param operator The address receiving the approval\n    /// @param tokenId The id of the token\n    function _approveFor(address from, address operator, uint256 tokenId) internal {\n        _checkFromIsOwner(from, tokenId);\n\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _isApprovedForAllOrSuperOperator(from, msgSender);\n        if (!authorized) {\n            revert ERC721InvalidApprover(msgSender);\n        }\n        if (operator == address(0)) {\n            _updateOwnerData(tokenId, from, false);\n        } else {\n            _updateOwnerData(tokenId, from, true);\n            _writeOperator(tokenId, operator);\n        }\n        emit Approval(from, operator, tokenId);\n    }\n\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param tokenId token id to burn\n    function _burn(address from, uint256 tokenId) internal {\n        bool operatorEnabled = _checkFromIsOwner(from, tokenId);\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _isApprovedForAllOrSuperOperator(from, msgSender);\n        if (!authorized && !(operatorEnabled && _readOperator(tokenId) == msgSender)) {\n            revert ERC721InsufficientApproval(msgSender, tokenId);\n        }\n        _writeOwnerData(tokenId, (_readOwnerData(tokenId) & (NOT_ADDRESS & NOT_OPERATOR_FLAG)) | BURNED_FLAG);\n        _subNumNFTPerAddress(from, 1);\n        emit Transfer(from, address(0), tokenId);\n    }\n\n    /// @notice checks that the token is taken from the owner after the call (from == owner)\n    /// @param from sender address\n    /// @param tokenId The id of the token\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _checkFromIsOwner(address from, uint256 tokenId) internal view returns (bool) {\n        if (from == address(0)) {\n            revert ERC721InvalidSender(from);\n        }\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenId);\n        // As from == owner, this is the same check as from == address(0) but we want a specific error for this one.\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        if (from != owner) {\n            revert ERC721InvalidOwner(from);\n        }\n        return operatorEnabled;\n    }\n\n    /// @param tokenId The id of the token\n    /// @param newOwner The new owner of the token\n    /// @param hasOperator if true the operator flag is set\n    function _updateOwnerData(uint256 tokenId, address newOwner, bool hasOperator) internal {\n        uint256 oldData = (_readOwnerData(tokenId) & (NOT_ADDRESS & NOT_OPERATOR_FLAG)) | uint256(uint160(newOwner));\n        if (hasOperator) {\n            oldData = oldData | OPERATOR_FLAG;\n        }\n        _writeOwnerData(tokenId, oldData);\n    }\n\n    /// @param tokenId token id\n    /// @return owner address of the owner\n    function _ownerOf(uint256 tokenId) internal view returns (address owner) {\n        (owner, ) = _ownerAndOperatorEnabledOf(tokenId);\n    }\n\n    /// @notice Get the owner and operatorEnabled flag of a token.\n    /// @param tokenId The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    /// @dev must extract the owner, burn and operator flag from _readOwnerData(tokenId) if burned must return owner = address(0)\n    function _ownerAndOperatorEnabledOf(\n        uint256 tokenId\n    ) internal view virtual returns (address owner, bool operatorEnabled);\n\n    /// @notice Check if receiving contract accepts erc721 transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param tokenId The id of the token we would like to transfer.\n    /// @param data Any additional data to send with the transfer.\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        /* solhint-disable no-empty-blocks */\n        try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\n            if (retval == IERC721Receiver.onERC721Received.selector) {\n                return;\n            }\n        } catch (bytes memory) {}\n        /* solhint-enable no-empty-blocks */\n        revert ERC721InvalidReceiver(to);\n    }\n\n    /// @notice Check if receiving contract accepts erc721 batch transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param ids The ids of the tokens we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal {\n        /* solhint-disable no-empty-blocks */\n        try IERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data) returns (\n            bytes4 retval\n        ) {\n            if (retval == IERC721MandatoryTokenReceiver.onERC721BatchReceived.selector) {\n                return;\n            }\n        } catch (bytes memory) {}\n        /* solhint-enable no-empty-blocks */\n        revert ERC721InvalidReceiver(to);\n    }\n\n    /// @notice Check if there was enough gas.\n    /// @param to The address of the contract to check.\n    /// @return Whether or not this check succeeded.\n    function _checkIERC721MandatoryTokenReceiver(address to) internal view returns (bool) {\n        return ERC165Checker.supportsERC165InterfaceUnchecked(to, type(IERC721MandatoryTokenReceiver).interfaceId);\n    }\n\n    /// @notice Check if the sender approved the operator.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function _isApprovedForAllOrSuperOperator(address owner, address operator) internal view returns (bool) {\n        return _isOperatorForAll(owner, operator) || _isSuperOperator(operator);\n    }\n\n    /// @notice Add tokens to the owner balance\n    /// @param who the owner of the token\n    /// @param val how much to add to the owner's balance\n    /// @dev we can use unchecked because there is a limited number of lands 408x408\n    function _addNumNFTPerAddress(address who, uint256 val) internal {\n        unchecked {\n            _writeNumNFTPerAddress(who, _readNumNFTPerAddress(who) + val);\n        }\n    }\n\n    /// @notice Subtract tokens to the owner balance\n    /// @param who the owner of the token\n    /// @param val how much to subtract from the owner's balance\n    /// @dev we can use unchecked because there is a limited number of lands 408x408\n    function _subNumNFTPerAddress(address who, uint256 val) internal {\n        unchecked {\n            _writeNumNFTPerAddress(who, _readNumNFTPerAddress(who) - val);\n        }\n    }\n\n    /// @notice Move balance between two users\n    /// @param from address to subtract from\n    /// @param to address to add from\n    /// @param quantity how many tokens to move\n    function _transferNumNFTPerAddress(address from, address to, uint256 quantity) internal virtual {\n        if (from != to) {\n            _subNumNFTPerAddress(from, quantity);\n            _addNumNFTPerAddress(to, quantity);\n        }\n    }\n\n    /// @notice get the number of nft for an address\n    /// @param owner address to check\n    /// @return the number of nfts\n    function _readNumNFTPerAddress(address owner) internal view virtual returns (uint256);\n\n    /// @notice set the number of nft for an address\n    /// @param owner address to set\n    /// @param quantity the number of nfts to set for the owner\n    function _writeNumNFTPerAddress(address owner, uint256 quantity) internal virtual;\n\n    /// @notice Get the owner data of a token for a user\n    /// @param tokenId The id of the token.\n    /// @return the owner data\n    /// @dev The owner data has three fields: owner address, operator flag and burn flag. See: _owners declaration.\n    function _readOwnerData(uint256 tokenId) internal view virtual returns (uint256);\n\n    /// @notice Get the owner address of a token (included in the ownerData, see: _getOwnerData)\n    /// @param tokenId The id of the token.\n    /// @return the owner address\n    function _getOwnerAddress(uint256 tokenId) internal view virtual returns (address) {\n        return address(uint160(_readOwnerData(tokenId)));\n    }\n\n    /// @notice Set the owner data of a token\n    /// @param tokenId the token Id\n    /// @param data the owner data\n    /// @dev The owner data has three fields: owner address, operator flag and burn flag. See: _owners declaration.\n    function _writeOwnerData(uint256 tokenId, uint256 data) internal virtual;\n\n    /// @notice check if an operator was enabled by a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @return true if the operator has access\n    function _isOperatorForAll(address owner, address operator) internal view virtual returns (bool);\n\n    /// @notice Provides an operator access to all the tokens of an owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @param enabled if true give access to the operator, else disable it\n    function _writeOperatorForAll(address owner, address operator, bool enabled) internal virtual;\n\n    /// @notice get the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId The id of the token.\n    /// @return the operator address\n    function _readOperator(uint256 tokenId) internal view virtual returns (address);\n\n    /// @notice set the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId the id of the token.\n    /// @param operator the operator address\n    function _writeOperator(uint256 tokenId, address operator) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/LandBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IOperatorFilterRegistry} from \"../interfaces/IOperatorFilterRegistry.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\nimport {ILandToken} from \"../interfaces/ILandToken.sol\";\nimport {IQuad} from \"../interfaces/IQuad.sol\";\nimport {ILandMetadataRegistry} from \"../interfaces/ILandMetadataRegistry.sol\";\nimport {IERC721BatchOps} from \"../interfaces/IERC721BatchOps.sol\";\nimport {WithAdmin} from \"./WithAdmin.sol\";\nimport {OperatorFiltererUpgradeable} from \"../common/OperatorFiltererUpgradeable.sol\";\nimport {WithMetadataRegistry} from \"../common/WithMetadataRegistry.sol\";\nimport {WithRoyalties} from \"../common/WithRoyalties.sol\";\nimport {WithOwner} from \"../common/WithOwner.sol\";\nimport {LandBaseToken} from \"./LandBaseToken.sol\";\n\n/// @title Land Contract\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice LAND contract\n/// @dev LAND contract implements ERC721, quads, metadata, royalties and marketplace filtering functionalities.\n/// @dev The contract also implements EIP173 because it is needed by some marketplaces. The owner() doesn't have\n/// @dev any privileged roles within the contract. It can be set by the admin to any value.\nabstract contract LandBase is\n    LandBaseToken,\n    Initializable,\n    OperatorFiltererUpgradeable,\n    WithAdmin,\n    WithMetadataRegistry,\n    WithRoyalties,\n    WithOwner\n{\n    /// @dev this protects the implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract admin\n    /// @param admin Admin of the contract\n    function initialize(address admin) external initializer {\n        // We must be able to initialize the admin if this is a fresh deploy, but we want to\n        // be backward compatible with the current deployment\n        if (_readAdmin() != address(0)) {\n            revert InvalidInitialization();\n        }\n        _setAdmin(admin);\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription 'true' or to copy the list 'false'.\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAdmin {\n        if (subscriptionOrRegistrantToCopy == address(0)) {\n            revert InvalidAddress();\n        }\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice Change the admin of the contract\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external onlyAdmin {\n        _setSuperOperator(superOperator, enabled);\n    }\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external onlyAdmin {\n        _setMinter(minter, enabled);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(IOperatorFilterRegistry registry) external virtual onlyAdmin {\n        _setOperatorRegistry(registry);\n    }\n\n    /// @notice set royalty manager\n    /// @param royaltyManager address of the manager contract for common royalty recipient\n    function setRoyaltyManager(address royaltyManager) external onlyAdmin {\n        _setRoyaltyManager(royaltyManager);\n    }\n\n    /// @notice sets address of the Metadata Registry\n    /// @param metadataRegistry The address of the Metadata Registry\n    function setMetadataRegistry(address metadataRegistry) external onlyAdmin {\n        _setMetadataRegistry(metadataRegistry);\n    }\n\n    /// @notice Set the address of the new owner of the contract\n    /// @param newOwner address of new owner\n    /// @dev This owner doesn't have any privileged role within this contract\n    /// @dev It is set by the admin to comply with EIP173 which is needed by some marketplaces\n    /// @dev Even when set to address(0) ownership is never permanently renounced the admin can always set any value\n    function transferOwnership(address newOwner) external onlyAdmin {\n        _transferOwnership(newOwner);\n    }\n\n    /// @notice Approve an operator to spend tokens on the sender behalf\n    /// @param sender The address giving the approval\n    /// @param operator The address receiving the approval\n    /// @param tokenId The id of the token\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 tokenId\n    ) external onlyAllowedOperatorApproval(operator) {\n        _approveFor(sender, operator, tokenId);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the msgSender\n    /// @param operator The address receiving the approval\n    /// @param approved The determination of the approval\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) external override onlyAllowedOperatorApproval(operator) {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender (may differ from msgSender)\n    /// @param sender The address giving the approval\n    /// @param operator The address receiving the approval\n    /// @param approved The determination of the approval\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external onlyAllowedOperatorApproval(operator) {\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice Approve an operator to spend tokens on the sender behalf\n    /// @param operator The address receiving the approval\n    /// @param tokenId The id of the token\n    function approve(address operator, uint256 tokenId) external override onlyAllowedOperatorApproval(operator) {\n        _approveFor(_msgSender(), operator, tokenId);\n    }\n\n    /// @notice Transfer a token between 2 addresses\n    /// @param from The sender of the token\n    /// @param to The recipient of the token\n    /// @param tokenId The id of the token\n    function transferFrom(address from, address to, uint256 tokenId) external override onlyAllowedOperator(from) {\n        _transferFrom(from, to, tokenId);\n    }\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external virtual override onlyAllowedOperator(from) {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer\n    /// @param from The sender of the token\n    /// @param to The recipient of the token\n    /// @param tokenId The id of the token\n    function safeTransferFrom(address from, address to, uint256 tokenId) external override onlyAllowedOperator(from) {\n        _safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer\n    /// @param from The sender of the token\n    /// @param to The recipient of the token\n    /// @param tokenId The id of the token\n    /// @param data Additional data\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override onlyAllowedOperator(from) {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /// @notice Transfer many tokens between 2 addresses, while\n    /// ensuring the receiving contract has a receiver method.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external virtual onlyAllowedOperator(from) {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /// @notice Check if the contract supports an interface\n    /// @param interfaceId The id of the interface\n    /// @return True if the interface is supported\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721BatchOps).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC2981).interfaceId ||\n            interfaceId == type(ILandToken).interfaceId ||\n            interfaceId == type(ILandToken).interfaceId ^ type(IQuad).interfaceId ||\n            interfaceId == type(IQuad).interfaceId ||\n            interfaceId == type(ILandMetadataRegistry).interfaceId;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/LandBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IErrors} from \"../interfaces/IErrors.sol\";\nimport {ILandToken} from \"../interfaces/ILandToken.sol\";\nimport {ERC721BaseToken} from \"../common/ERC721BaseToken.sol\";\n\n/// @title LandBaseToken\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Implement LAND and quad functionalities on top of an ERC721 token\n/// @dev This contract implements a quad tree structure to handle groups of ERC721 tokens at once\nabstract contract LandBaseToken is IErrors, ILandToken, ERC721BaseToken {\n    using Address for address;\n\n    /// @notice the coordinates are invalid\n    /// @param size The size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    error InvalidCoordinates(uint256 size, uint256 x, uint256 y);\n\n    /// @notice is not the owner of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    error NotOwner(uint256 x, uint256 y);\n\n    /// @notice the token is already minted\n    /// @param tokenId the id of land\n    error AlreadyMinted(uint256 tokenId);\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    /* solhint-disable const-name-snakecase */\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n    /* solhint-enable const-name-snakecase */\n\n    /// @notice emitted when a minter right is changed.\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    event Minter(address indexed minter, bool enabled);\n\n    /// @dev helper struct to store arguments in memory instead of the stack.\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external override {\n        if (from == address(0) || to == address(0)) {\n            revert InvalidAddress();\n        }\n        if (sizes.length != xs.length || xs.length != ys.length) {\n            revert InvalidLength();\n        }\n        address msgSender = _msgSender();\n        if (msgSender != from && !_isApprovedForAllOrSuperOperator(from, msgSender)) {\n            revert ERC721InvalidOwner(msgSender);\n        }\n        uint256 numTokensTransferred = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _isValidQuad(size, xs[i], ys[i]);\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransferred += size * size;\n        }\n        _transferNumNFTPerAddress(from, to, numTokensTransferred);\n\n        if (to.code.length > 0 && _checkIERC721MandatoryTokenReceiver(to)) {\n            uint256[] memory ids = new uint256[](numTokensTransferred);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            _checkOnERC721BatchReceived(msgSender, from, to, ids, data);\n        }\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size The size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @param data additional data for transfer\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        address msgSender = _msgSender();\n        if (from == address(0) || to == address(0)) {\n            revert InvalidAddress();\n        }\n        if (msgSender != from && !_isApprovedForAllOrSuperOperator(from, msgSender)) {\n            revert ERC721InvalidOwner(msgSender);\n        }\n        _isValidQuad(size, x, y);\n        _transferQuad(from, to, size, x, y);\n        _transferNumNFTPerAddress(from, to, size * size);\n        _checkBatchReceiverAcceptQuad(msgSender, from, to, size, x, y, data);\n    }\n\n    /// @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n    /// @param to The recipient of the new quad\n    /// @param size The size of the new quad\n    /// @param x The bottom left x coordinate of the new quad\n    /// @param y The bottom left y coordinate of the new quad\n    /// @param data extra data to pass to the transfer\n    function mintQuad(address to, uint256 size, uint256 x, uint256 y, bytes memory data) external virtual override {\n        address msgSender = _msgSender();\n        if (!_isMinter(msgSender)) {\n            revert ERC721InvalidOwner(msgSender);\n        }\n        _isValidQuad(size, x, y);\n        _mintQuad(msgSender, to, size, x, y, data);\n    }\n\n    /// @notice Checks if a parent quad has child quads already minted.\n    /// @notice Then mints the rest child quads and transfers the parent quad.\n    /// @notice Should only be called by the tunnel.\n    /// @param to The recipient of the new quad\n    /// @param size The size of the new quad\n    /// @param x The bottom left x coordinate of the new quad\n    /// @param y The bottom left y coordinate of the new quad\n    /// @param data extra data to pass to the transfer\n    function mintAndTransferQuad(address to, uint256 size, uint256 x, uint256 y, bytes calldata data) external virtual {\n        address msgSender = _msgSender();\n        if (!_isMinter(msgSender)) {\n            revert ERC721InvalidOwner(msgSender);\n        }\n        if (to == address(0)) {\n            revert InvalidAddress();\n        }\n\n        _isValidQuad(size, x, y);\n        if (_ownerOfQuad(size, x, y) != address(0)) {\n            _transferQuad(msgSender, to, size, x, y);\n            _transferNumNFTPerAddress(msgSender, to, size * size);\n            _checkBatchReceiverAcceptQuad(msgSender, msgSender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(msgSender, to, size, x, y, data);\n        }\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param tokenId the id of land\n    /// @return the x coordinates\n    function getX(uint256 tokenId) external pure returns (uint256) {\n        return _getX(tokenId);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param tokenId the id of land\n    /// @return the y coordinates\n    function getY(uint256 tokenId) external pure returns (uint256) {\n        return _getY(tokenId);\n    }\n\n    /// @notice Return the name of the token contract\n    /// @return The name of the token contract\n    function name() external pure virtual returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) external view virtual returns (bool) {\n        return _isMinter(who);\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size The size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(uint256 size, uint256 x, uint256 y) external view virtual override returns (bool) {\n        _isValidQuad(size, x, y);\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    /// @notice Return the symbol of the token contract\n    /// @return The symbol of the token contract\n    function symbol() external pure virtual returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() external pure virtual returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice Return the URI of a specific token\n    /// @param tokenId The id of the token\n    /// @return The URI of the token\n    function tokenURI(uint256 tokenId) external view virtual returns (string memory) {\n        if (_ownerOf(tokenId) == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return string(abi.encodePacked(\"https://api.sandbox.game/lands/\", Strings.toString(tokenId), \"/metadata.json\"));\n    }\n\n    /// @notice Check size and coordinate of a quad\n    /// @param size The size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @dev after calling this function we can safely use unchecked math for x,y,size\n    function _isValidQuad(uint256 size, uint256 x, uint256 y) internal pure {\n        if (size != 1 && size != 3 && size != 6 && size != 12 && size != 24) {\n            revert InvalidCoordinates(size, x, y);\n        }\n        if (x % size != 0 || y % size != 0 || x > GRID_SIZE - size || y > GRID_SIZE - size) {\n            revert InvalidCoordinates(size, x, y);\n        }\n    }\n\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size The size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    function _transferQuad(address from, address to, uint256 size, uint256 x, uint256 y) internal {\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            if (owner == address(0)) {\n                revert NotOwner(x, y);\n            }\n            if (owner != from) {\n                revert ERC721InvalidOwner(from);\n            }\n            _writeOwnerData(id1x1, uint160(to));\n        } else {\n            _regroupQuad(from, to, Land({x: x, y: y, size: size}), true, size / 2);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    /// @notice Mint a new quad\n    /// @param msgSender The original sender of the transaction\n    /// @param to The recipient of the new quad\n    /// @param size The size of the new quad\n    /// @param x The bottom left x coordinate of the new quad\n    /// @param y The bottom left y coordinate of the new quad\n    /// @param data extra data to pass to the transfer\n    function _mintQuad(address msgSender, address to, uint256 size, uint256 x, uint256 y, bytes memory data) internal {\n        if (to == address(0)) {\n            revert InvalidAddress();\n        }\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkQuadIsNotMinted(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            if (_readOwnerData(_id) != 0) {\n                revert AlreadyMinted(_id);\n            }\n            emit Transfer(address(0), to, _id);\n        }\n\n        _writeOwnerData(quadId, uint160(to));\n        _addNumNFTPerAddress(to, size * size);\n        _checkBatchReceiverAcceptQuad(msgSender, address(0), to, size, x, y, data);\n    }\n\n    /// @notice checks if the child quads in the parent quad (size, x, y) are owned by msgSender.\n    /// @param msgSender The original sender of the transaction\n    /// @param to The address to which the ownership of the quad will be transferred\n    /// @param size The size of the quad being minted and transferred\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @dev It recursively checks whether child quad of every size (excluding Lands of 1x1 size) are minted or not.\n    /// @dev Quad which are minted are pushed into quadMinted to also check if every Land of size 1x1 in\n    /// @dev the parent quad is minted or not. While checking if every child Quad and Land is minted it\n    /// @dev also checks and clears the owner for quads which are minted. Finally it checks if the new owner\n    /// @dev is a contract, can handle ERC-721 tokens, and transfers the parent quad to new owner.\n    function _mintAndTransferQuad(\n        address msgSender,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have. Would be used to push the minted Quads.\n        Land[] memory quadMinted = new Land[](64);\n        // index of last minted quad pushed on quadMinted Array\n        uint256 index = 0;\n        uint256 landMinted = 0;\n\n        // if size of the Quad in land struct to be transferred is greater than 3 we check recursively if the child quads are minted or not.\n        if (size > 3) {\n            (index, landMinted) = _checkQuadIsNotMintedAndClearOwner(\n                msgSender,\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        // Looping around the Quad in land struct to generate ids of 1x1 land token and checking if they are owned by msg.sender\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            // checking land with token id \"_id\" is in the quadMinted array.\n            bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n            if (isAlreadyMinted) {\n                // if land is in the quadMinted array, emit transfer event\n                emit Transfer(msgSender, to, _id);\n            } else {\n                if (_getOwnerAddress(_id) == msgSender) {\n                    if (_readOperator(_id) != address(0)) _writeOperator(_id, address(0));\n                    landMinted += 1;\n                    emit Transfer(msgSender, to, _id);\n                } else {\n                    // else check if owned by the msgSender or not. If it is not owned by msgSender it should not have an owner.\n                    if (_readOwnerData(_id) != 0) {\n                        revert AlreadyMinted(_id);\n                    }\n\n                    emit Transfer(address(0), to, _id);\n                }\n            }\n        }\n\n        // checking if the new owner \"to\" is a contract. If yes, checking if it could handle ERC721 tokens.\n        _checkBatchReceiverAcceptQuadAndClearOwner(msgSender, quadMinted, index, landMinted, to, size, x, y, data);\n\n        _writeOwnerData(quadId, uint160(to));\n        _addNumNFTPerAddress(to, size * size);\n        _subNumNFTPerAddress(msgSender, landMinted);\n    }\n\n    /// @notice recursively checks if the child quads are minted.\n    /// @param size The size of the quad\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @param quadCompareSize the size of the child quads to be checked.\n    function _checkQuadIsNotMinted(uint256 size, uint256 x, uint256 y, uint256 quadCompareSize) internal {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n\n        if (size <= quadCompareSize) {\n            // when the size of the quad is smaller than the quadCompareSize(size to be compared with),\n            // then it is checked if the bigger quad which encapsulates the quad to be minted\n            // of with size equals the quadCompareSize has been minted or not\n            uint256 id = _getQuadId(\n                layer,\n                (x / quadCompareSize) * quadCompareSize,\n                (y / quadCompareSize) * quadCompareSize\n            );\n            if (_readOwnerData(id) != 0) {\n                revert AlreadyMinted(id);\n            }\n        } else {\n            // when the size is greater than the quadCompare size the owner of all the greater quads with size\n            // quadCompare size in the quad to be minted are checked if they are minted or not\n            uint256 toX = x + size;\n            uint256 toY = y + size;\n            for (uint256 xi = x; xi < toX; xi += quadCompareSize) {\n                for (uint256 yi = y; yi < toY; yi += quadCompareSize) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    if (_readOwnerData(id) != 0) {\n                        revert AlreadyMinted(id);\n                    }\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3) _checkQuadIsNotMinted(size, x, y, quadCompareSize);\n    }\n\n    /// @notice recursively checks if the child quads are minted in land and push them to the quadMinted array.\n    /// @param msgSender The original sender of the transaction\n    /// @param land the struct which has the size x and y co-ordinate of Quad to be checked\n    /// @param quadMinted array in which the minted child quad would be pushed\n    /// @param landMinted total 1x1 land already minted\n    /// @param index index of last element of quadMinted array\n    /// @param quadCompareSize the size of the child quads to be checked.\n    /// @return the index of last quad pushed in quadMinted array and the total land already minted\n    /// @dev if a child quad is minted in land such quads child quads will be skipped such that there is no overlapping\n    /// @dev in quads which are minted. it clears the minted child quads owners.\n    function _checkQuadIsNotMintedAndClearOwner(\n        address msgSender,\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        // Looping around the Quad in land struct to check if the child quad are minted or not\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                //checking if the child Quad is minted or not. i.e Checks if the quad is in the quadMinted array.\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                // if child quad is not already in the quadMinted array.\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = _getOwnerAddress(id);\n                    // owner of the child quad is checked to be owned by msgSender else should not be owned by anyone.\n                    if (owner == msgSender) {\n                        // if child quad is minted it would be pushed in quadMinted array.\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        // index of quadMinted is increased\n                        index++;\n                        // total land minted is increase by the number if land of 1x1 in child quad\n                        landMinted += quadCompareSize * quadCompareSize;\n                        //owner is cleared\n                        _writeOwnerData(id, 0);\n                    } else {\n                        if (owner != address(0)) {\n                            revert AlreadyMinted(id);\n                        }\n                    }\n                }\n            }\n        }\n\n        // size of the child quad is set to be the next smaller child quad size (12 => 6 => 3)\n        quadCompareSize = quadCompareSize / 2;\n        // if child quad size is greater than 3 _checkAndClearOwner is checked for new child quads in the  quad in land struct.\n        if (quadCompareSize >= 3)\n            (index, landMinted) = _checkQuadIsNotMintedAndClearOwner(\n                msgSender,\n                land,\n                quadMinted,\n                landMinted,\n                index,\n                quadCompareSize\n            );\n        return (index, landMinted);\n    }\n\n    /// @dev checks the owner of land with 'tokenId' to be 'from' and clears it\n    /// @param from the address to be checked against the owner of the land\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @return bool for if land is owned by 'from' or not.\n    function _checkAndClearLandOwner(address from, uint256 x, uint256 y) internal returns (bool) {\n        uint256 tokenId = _getQuadId(LAYER_1x1, x, y);\n        uint256 currentOwner = _readOwnerData(tokenId);\n        if (currentOwner != 0) {\n            if ((currentOwner & BURNED_FLAG) == BURNED_FLAG) {\n                revert NotOwner(x, y);\n            }\n            if (address(uint160(currentOwner)) != from) {\n                revert ERC721InvalidOwner(from);\n            }\n            _writeOwnerData(tokenId, 0);\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0 && _checkIERC721MandatoryTokenReceiver(to)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            _checkOnERC721BatchReceived(operator, from, to, ids, data);\n        }\n    }\n\n    /// @param msgSender The original sender of the transaction\n    /// @param quadMinted - an array of Land structs in which the minted child quad or Quad to be transferred are.\n    /// @param landMinted - the total amount of land that has been minted\n    /// @param index - the index of the last element in the quadMinted array\n    /// @param to the address of the new owner of Quad to be transferred\n    /// @param size The size of the quad\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @dev checks if the receiver of the quad(size, x, y) is a contact. If yes can it handle ERC721 tokens. It also clears owner of 1x1 land's owned by msgSender.\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        address msgSender,\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        // checks if to is a contract and supports ERC721_MANDATORY_RECEIVER interfaces. if it doesn't it just clears the owner of 1x1 lands in quad(size, x, y)\n        if (to.code.length > 0 && _checkIERC721MandatoryTokenReceiver(to)) {\n            // array to push minted 1x1 land\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            // index of last land pushed in idsToTransfer array\n            uint256 transferIndex = 0;\n            // array to push ids to be minted\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            // index of last land pushed in idsToMint array\n            uint256 mintIndex = 0;\n\n            // iterating over every 1x1 land in the quad to be pushed in the above arrays\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    // if land is in the quads already minted it just pushed in to the idsToTransfer array\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (_getOwnerAddress(id) == msgSender) {\n                    // if it is owned by the msgSender owner data is removed and it is pushed in to idsToTransfer array\n                    _writeOwnerData(id, 0);\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    // else it is not owned by any one and and pushed in the idsToMint array\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n\n            // checking if \"to\" contact can handle ERC721 tokens\n            _checkOnERC721BatchReceived(msgSender, address(0), to, idsToMint, data);\n            _checkOnERC721BatchReceived(msgSender, msgSender, to, idsToTransfer, data);\n        } else {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n                if (_getOwnerAddress(id) == msgSender) _writeOwnerData(id, 0);\n            }\n        }\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param tokenId The token id\n    /// @return the x coordinates\n    function _getX(uint256 tokenId) internal pure returns (uint256) {\n        return (tokenId & ~LAYER) % GRID_SIZE;\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param tokenId The token id\n    /// @return the y coordinates\n    function _getY(uint256 tokenId) internal pure returns (uint256) {\n        return (tokenId & ~LAYER) / GRID_SIZE;\n    }\n\n    /// @notice check if a quad is in the array of minted lands\n    /// @param quad the quad that will be searched through mintedLand\n    /// @param quadMinted array of quads that are minted in the current transaction\n    /// @param index the amount of entries in mintedQuad\n    /// @return true if a quad is minted\n    function _isQuadMinted(Land[] memory quadMinted, Land memory quad, uint256 index) internal pure returns (bool) {\n        for (uint256 i = 0; i < index; i++) {\n            Land memory land = quadMinted[i];\n            if (\n                land.size > quad.size &&\n                quad.x >= land.x &&\n                quad.x < land.x + land.size &&\n                quad.y >= land.y &&\n                quad.y < land.y + land.size\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice get size related information (there is one-to-one relationship between layer and size)\n    /// @param size The size of the quad\n    /// @return layer the layers that corresponds to the size\n    /// @return parentSize the size of the parent (bigger quad that contains the current one)\n    /// @return childLayer the layer of the child (smaller quad contained by this one)\n    function _getQuadLayer(uint256 size) internal pure returns (uint256 layer, uint256 parentSize, uint256 childLayer) {\n        if (size == 1) {\n            layer = LAYER_1x1;\n            parentSize = 3;\n        } else if (size == 3) {\n            layer = LAYER_3x3;\n            parentSize = 6;\n        } else if (size == 6) {\n            layer = LAYER_6x6;\n            parentSize = 12;\n            childLayer = LAYER_3x3;\n        } else if (size == 12) {\n            layer = LAYER_12x12;\n            parentSize = 24;\n            childLayer = LAYER_6x6;\n        } else {\n            layer = LAYER_24x24;\n            childLayer = LAYER_12x12;\n        }\n    }\n\n    /// @notice get the quad id given the layer and coordinates.\n    /// @param layer the layer of the quad see: _getQuadLayer\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @return the tokenId of the quad\n    /// @dev this method is gas optimized, must be called with verified x,y and size, after a call to _isValidQuad\n    function _getQuadId(uint256 layer, uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            return layer + x + y * GRID_SIZE;\n        }\n    }\n\n    /// @notice return the quadId given and index, size and coordinates\n    /// @param i the index to be added to x,y to get row and column\n    /// @param size The bottom left x coordinate of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @return the tokenId of the quad\n    /// @dev this method is gas optimized, must be called with verified x,y and size, after a call to _isValidQuad\n    function _idInPath(uint256 i, uint256 size, uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            // This is an inlined/optimized version of: _getQuadId(LAYER_1x1, x + (i % size), y + (i / size))\n            return (x + (i % size)) + (y + (i / size)) * GRID_SIZE;\n        }\n    }\n\n    /// @notice checks if the Land's child quads are owned by the from address and clears all the previous owners\n    /// @param from address of the previous owner\n    /// @param to address of the new owner\n    /// @param land the quad to be regrouped and transferred\n    /// @param set for setting the new owner\n    /// @param childQuadSize  size of the child quad to be checked for owner in the regrouping\n    /// @dev if all the child quads are not owned by the \"from\" address then the owner of parent quad to the land\n    /// @dev is checked if owned by the \"from\" address. If from is the owner then land owner is set to \"to\" address\n    function _regroupQuad(\n        address from,\n        address to,\n        Land memory land,\n        bool set,\n        uint256 childQuadSize\n    ) internal returns (bool) {\n        (uint256 layer, , uint256 childLayer) = _getQuadLayer(land.size);\n        uint256 quadId = _getQuadId(layer, land.x, land.y);\n        bool ownerOfAll = true;\n\n        // double for loop iterates and checks owner of all the smaller quads in land\n        for (uint256 xi = land.x; xi < land.x + land.size; xi += childQuadSize) {\n            for (uint256 yi = land.y; yi < land.y + land.size; yi += childQuadSize) {\n                uint256 ownerChild = 0;\n                bool ownAllIndividual = false;\n                if (childQuadSize < 3) {\n                    // case when the smaller quad is 1x1,\n                    ownAllIndividual = _checkAndClearLandOwner(from, xi, yi) && ownerOfAll;\n                } else {\n                    // recursively calling the _regroupQuad function to check the owner of child quads.\n                    ownAllIndividual = _regroupQuad(\n                        from,\n                        to,\n                        Land({x: xi, y: yi, size: childQuadSize}),\n                        false,\n                        childQuadSize / 2\n                    );\n                    uint256 idChild = _getQuadId(childLayer, xi, yi);\n                    ownerChild = _readOwnerData(idChild);\n                    if (ownerChild != 0) {\n                        // checking the owner of child quad\n                        if (!ownAllIndividual && ownerChild != uint256(uint160(from))) {\n                            revert NotOwner(xi, yi);\n                        }\n                        // clearing owner of child quad\n                        _writeOwnerData(idChild, 0);\n                    }\n                }\n                // ownerOfAll should be true if \"from\" is owner of all the child quads iterated over\n                ownerOfAll = (ownAllIndividual || ownerChild != 0) && ownerOfAll;\n            }\n        }\n\n        // if set is true it check if the \"from\" is owner of all else checks for the owner of parent quad is\n        // owned by \"from\" and sets the owner for the id of land to \"to\" address.\n        if (set) {\n            if (!ownerOfAll && _ownerOfQuad(land.size, land.x, land.y) != from) {\n                revert ERC721InvalidOwner(from);\n            }\n            _writeOwnerData(quadId, uint160(to));\n            return true;\n        }\n\n        return ownerOfAll;\n    }\n\n    /// @notice return the owner of a quad given his size and coordinates or zero if is not minted yet.\n    /// @param size The size of the quad\n    /// @param x coordinate inside the quad\n    /// @param y coordinate inside the quad\n    /// @return the address of the owner\n    function _ownerOfQuad(uint256 size, uint256 x, uint256 y) internal view returns (address) {\n        (uint256 layer, uint256 parentSize, ) = _getQuadLayer(size);\n        address owner = _getOwnerAddress(_getQuadId(layer, (x / size) * size, (y / size) * size));\n        if (owner != address(0)) {\n            return owner;\n        } else if (size < 24) {\n            return _ownerOfQuad(parentSize, x, y);\n        }\n        return address(0);\n    }\n\n    /// @notice Get the owner and operatorEnabled flag of a token.\n    /// @param tokenId The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerAndOperatorEnabledOf(\n        uint256 tokenId\n    ) internal view override returns (address owner, bool operatorEnabled) {\n        if (tokenId & LAYER != 0) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        uint256 x = tokenId % GRID_SIZE;\n        uint256 y = tokenId / GRID_SIZE;\n        uint256 owner1x1 = _readOwnerData(tokenId);\n\n        if ((owner1x1 & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n            return (owner, operatorEnabled);\n        }\n\n        if (owner1x1 != 0) {\n            owner = address(uint160(owner1x1));\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n        } else {\n            owner = _ownerOfQuad(3, x, y);\n            operatorEnabled = false;\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function _setMinter(address minter, bool enabled) internal {\n        if (minter == address(0)) {\n            revert InvalidAddress();\n        }\n        if (enabled == _isMinter(minter)) {\n            revert InvalidArgument();\n        }\n        _writeMinter(minter, enabled);\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice checks if an address is enabled as minter\n    /// @param minter the address to check\n    /// @return true if the address is a minter\n    function _isMinter(address minter) internal view virtual returns (bool);\n\n    /// @notice set an address as minter\n    /// @param minter the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeMinter(address minter, bool enabled) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/OperatorFiltererUpgradeable.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport {IOperatorFilterRegistry} from \"../interfaces/IOperatorFilterRegistry.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\n/// @title OperatorFiltererUpgradeable\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice This contract would subscribe or copy or just to the subscription provided or just register to default subscription list\n/// @dev This contract is the upgradeable version of the OpenSea implementation https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/OperatorFilterer.sol and adapted to the 0.5.9 solidity version\nabstract contract OperatorFiltererUpgradeable is Context {\n    /// @notice emitted when a registry is set\n    /// @param registry address of the registry to set\n    event OperatorRegistrySet(IOperatorFilterRegistry indexed registry);\n\n    /// @notice emitted when the contract is registered into the registry\n    /// @param subscriptionOrRegistrant address to subscribe or copy entries from\n    /// @param subscribe should it subscribe\n    event ContractRegistered(address indexed subscriptionOrRegistrant, bool subscribe);\n\n    /// @notice the caller is not the operator\n    error OperatorNotAllowed();\n\n    /// @notice Used in approval operations to check if the operator is allowed to call this contract\n    /// @param operator The address receiving the approval\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkIsOperatorAllowed(address(this), operator);\n        _;\n    }\n\n    /// @notice Used in transfer from operations to check if the sender of the token is allowed to call this contract\n    /// @param from the sender of the token\n    modifier onlyAllowedOperator(address from) virtual {\n        // Allow spending tokens from addresses with balance (from == _msgSender())\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n        // from an EOA.\n        if (from != _msgSender()) {\n            _checkIsOperatorAllowed(address(this), _msgSender());\n        }\n        _;\n    }\n\n    /// @notice return the address of the operator filter registry\n    /// @return the address of  the operator filter registry\n    function operatorFilterRegistry() external view returns (IOperatorFilterRegistry) {\n        return _readOperatorFilterRegistry();\n    }\n\n    /// @notice Register this contract into the registry\n    /// @param subscriptionOrRegistrantToCopy address to subscribe or copy entries from\n    /// @param subscribe should it subscribe\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal {\n        IOperatorFilterRegistry registry = _readOperatorFilterRegistry();\n        if (address(registry).code.length > 0) {\n            if (!registry.isRegistered(address(this))) {\n                if (subscribe) {\n                    registry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    if (subscriptionOrRegistrantToCopy != address(0)) {\n                        registry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                    } else {\n                        registry.register(address(this));\n                    }\n                }\n            }\n        }\n        emit ContractRegistered(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function _setOperatorRegistry(IOperatorFilterRegistry registry) internal {\n        _writeOperatorFilterRegistry(registry);\n        emit OperatorRegistrySet(registry);\n    }\n\n    /// @notice Check if the operator is allowed for the given registrant\n    /// @param registrant address of the registrant\n    /// @param operator operator address to check\n    function _checkIsOperatorAllowed(address registrant, address operator) internal view {\n        IOperatorFilterRegistry registry = _readOperatorFilterRegistry();\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(registry).code.length > 0) {\n            /* solhint-disable no-empty-blocks */\n            try registry.isOperatorAllowed(registrant, operator) returns (bool retval) {\n                if (retval) {\n                    return;\n                }\n            } catch (bytes memory) {}\n            /* solhint-enable  no-empty-blocks */\n            revert OperatorNotAllowed();\n        }\n    }\n\n    /// @notice get the OpenSea operator filter\n    /// @return the address of the OpenSea operator filter registry\n    function _readOperatorFilterRegistry() internal view virtual returns (IOperatorFilterRegistry);\n\n    /// @notice set the OpenSea operator filter\n    /// @param registry the address of the OpenSea operator filter registry\n    function _writeOperatorFilterRegistry(IOperatorFilterRegistry registry) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/WithAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IErrors} from \"../interfaces/IErrors.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\n/// @title WithAdmin\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Add an admin to the contract\nabstract contract WithAdmin is IErrors, Context {\n    /// @notice Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice checks if the sender is admin\n    modifier onlyAdmin() {\n        if (_msgSender() != _readAdmin()) {\n            revert OnlyAdmin();\n        }\n        _;\n    }\n\n    /// @notice Get the current admin\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _readAdmin();\n    }\n\n    /// @notice Change the admin of the contract\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function _changeAdmin(address newAdmin) internal {\n        address oldAdmin = _readAdmin();\n        if (oldAdmin == address(0)) {\n            revert InvalidAddress();\n        }\n        if (oldAdmin == newAdmin) {\n            revert InvalidArgument();\n        }\n        _setAdmin(newAdmin);\n    }\n\n    /// @notice Change the admin of the contract\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function _setAdmin(address newAdmin) internal {\n        if (newAdmin == address(0)) {\n            revert InvalidAddress();\n        }\n        address oldAdmin = _readAdmin();\n        emit AdminChanged(oldAdmin, newAdmin);\n        _writeAdmin(newAdmin);\n    }\n\n    /// @notice get the admin address\n    /// @return the admin address\n    ///@dev Implement\n    function _readAdmin() internal view virtual returns (address);\n\n    /// @notice set the admin address\n    /// @param admin the admin address\n    ///@dev Implement\n    function _writeAdmin(address admin) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/WithMetadataRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.23;\n\nimport {IErrors} from \"../interfaces/IErrors.sol\";\nimport {ILandMetadataRegistry} from \"../interfaces/ILandMetadataRegistry.sol\";\n\n/// @title WithMetadataRegistry\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Add support for the metadata registry\nabstract contract WithMetadataRegistry is IErrors {\n    /// @notice value returned when the neighborhood is not set yet.\n    string private constant UNKNOWN_NEIGHBORHOOD = \"unknown\";\n\n    /// @notice emitted when the metadata registry is set\n    /// @param metadataRegistry the address of the metadata registry\n    event MetadataRegistrySet(address indexed metadataRegistry);\n\n    struct MetadataRegistryStorage {\n        ILandMetadataRegistry _metadataRegistry;\n    }\n\n    /// @custom:storage-location erc7201:thesandbox.storage.land.common.WithMetadataRegistry\n    bytes32 internal constant METADATA_REGISTRY_STORAGE_LOCATION =\n        0x3899f13de39885dfce849839be8330453b5866928dd0e5933e36794349628400;\n\n    function _getMetadataRegistryStorage() private pure returns (MetadataRegistryStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := METADATA_REGISTRY_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Get the address of the Metadata Registry\n    /// @return The address of the Metadata Registry\n    function getMetadataRegistry() external view returns (ILandMetadataRegistry) {\n        MetadataRegistryStorage storage $ = _getMetadataRegistryStorage();\n        return $._metadataRegistry;\n    }\n\n    /// @notice return the metadata for one land\n    /// @param tokenId the token id\n    /// @return premium true if the land is premium\n    /// @return neighborhoodId the number that identifies the neighborhood\n    /// @return neighborhoodName the neighborhood name\n    function getMetadata(uint256 tokenId) external view returns (bool, uint256, string memory) {\n        ILandMetadataRegistry registry = _getMetadataRegistryStorage()._metadataRegistry;\n        if (registry == ILandMetadataRegistry(address(0))) {\n            return (false, 0, UNKNOWN_NEIGHBORHOOD);\n        }\n        return registry.getMetadata(tokenId);\n    }\n\n    /// @notice return true if a land is premium\n    /// @param tokenId the token id\n    function isPremium(uint256 tokenId) external view returns (bool) {\n        ILandMetadataRegistry registry = _getMetadataRegistryStorage()._metadataRegistry;\n        if (registry == ILandMetadataRegistry(address(0))) {\n            return false;\n        }\n        return registry.isPremium(tokenId);\n    }\n\n    /// @notice return the id that identifies the neighborhood\n    /// @param tokenId the token id\n    function getNeighborhoodId(uint256 tokenId) external view returns (uint256) {\n        ILandMetadataRegistry registry = _getMetadataRegistryStorage()._metadataRegistry;\n        if (registry == ILandMetadataRegistry(address(0))) {\n            return 0;\n        }\n        return registry.getNeighborhoodId(tokenId);\n    }\n\n    /// @notice set the address of the metadata registry\n    /// @param metadataRegistry the address of the metadata registry\n    function _setMetadataRegistry(address metadataRegistry) internal {\n        if (metadataRegistry == address(0)) {\n            revert InvalidAddress();\n        }\n        MetadataRegistryStorage storage $ = _getMetadataRegistryStorage();\n        $._metadataRegistry = ILandMetadataRegistry(metadataRegistry);\n        emit MetadataRegistrySet(metadataRegistry);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/WithOwner.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.23;\n\n/// @title Owner support (EIP173)\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Add an owner for the stores that need it\ncontract WithOwner {\n    /// @notice emitted when the ownership of the contract is changed\n    /// @param previousOwner The old address of the owner.\n    /// @param newOwner The new address of the owner.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    struct OwnerStorage {\n        address _owner;\n    }\n\n    /// @custom:storage-location erc7201:thesandbox.storage.land.common.WithOwner\n    bytes32 internal constant OWNER_STORAGE_LOCATION =\n        0x1836e2fa424a35b79c13fd66f8e282cb3a31513f9610d6e7a99baf7ffe56ec00;\n\n    function _getOwnerStorage() private pure returns (OwnerStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := OWNER_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Get the address of the owner\n    /// @return The address of the owner.\n    function owner() external view returns (address) {\n        OwnerStorage storage $ = _getOwnerStorage();\n        return $._owner;\n    }\n\n    /// @notice change the ownership of the contract\n    /// @param newOwner The new address of the owner.\n    function _transferOwnership(address newOwner) internal {\n        OwnerStorage storage $ = _getOwnerStorage();\n        emit OwnershipTransferred($._owner, newOwner);\n        $._owner = newOwner;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/WithRoyalties.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.23;\n\nimport {IRoyaltyManager} from \"@sandbox-smart-contracts/dependency-royalty-management/contracts/interfaces/IRoyaltyManager.sol\";\n\n/// @title WithRoyalties\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Add royalty support to land contracts (EIP2981 implemented with our royalty manager)\ncontract WithRoyalties {\n    /// @notice emitted when the royalty manager is set\n    /// @param royaltyManager the address of royalty manager contract.\n    event RoyaltyManagerSet(address indexed royaltyManager);\n\n    uint16 internal constant TOTAL_BASIS_POINTS = 10000;\n\n    struct RoyaltiesStorage {\n        IRoyaltyManager _royaltyManager;\n    }\n\n    /// @custom:storage-location erc7201:thesandbox.storage.land.common.WithRoyalties\n    bytes32 internal constant ROYALTIES_STORAGE_LOCATION =\n        0xf7bae505580fc5d233bb20f4fb93f39f43d44ecc81ed63dd6455097b4c455000;\n\n    function _getRoyaltiesStorage() private pure returns (RoyaltiesStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ROYALTIES_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice Returns how much royalty is owed and to whom based on ERC2981\n    /// @dev tokenId is one of the EIP2981 args for this function can't be removed\n    /// @param salePrice the price of token on which the royalty is calculated\n    /// @return receiver the receiver of royalty\n    /// @return royaltyAmount the amount of royalty\n    function royaltyInfo(\n        uint256 /*_tokenId */,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount) {\n        RoyaltiesStorage storage $ = _getRoyaltiesStorage();\n        uint16 royaltyBps;\n        (receiver, royaltyBps) = $._royaltyManager.getRoyaltyInfo();\n        royaltyAmount = (salePrice * royaltyBps) / TOTAL_BASIS_POINTS;\n        return (receiver, royaltyAmount);\n    }\n\n    /// @notice returns the royalty manager\n    /// @return the address of royalty manager contract.\n    function getRoyaltyManager() external view returns (IRoyaltyManager) {\n        RoyaltiesStorage storage $ = _getRoyaltiesStorage();\n        return $._royaltyManager;\n    }\n\n    /// @notice set the address of the royalty manager\n    /// @param royaltyManager the address of royalty manager contract.\n    function _setRoyaltyManager(address royaltyManager) internal {\n        RoyaltiesStorage storage $ = _getRoyaltiesStorage();\n        $._royaltyManager = IRoyaltyManager(royaltyManager);\n        emit RoyaltyManagerSet(royaltyManager);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/common/WithSuperOperators.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IErrors} from \"../interfaces/IErrors.sol\";\n\n/// @title WithSuperOperators\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Add super operators handled by an admin\nabstract contract WithSuperOperators is IErrors {\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    event SuperOperator(address indexed superOperator, bool indexed enabled);\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    function isSuperOperator(address superOperator) external view returns (bool) {\n        return _isSuperOperator(superOperator);\n    }\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function _setSuperOperator(address superOperator, bool enabled) internal {\n        if (superOperator == address(0)) {\n            revert InvalidAddress();\n        }\n        if (enabled == _isSuperOperator(superOperator)) {\n            revert InvalidArgument();\n        }\n        _writeSuperOperator(superOperator, enabled);\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    /// @dev Implement\n    function _isSuperOperator(address superOperator) internal view virtual returns (bool);\n\n    /// @notice enable an address to be super-operator\n    /// @param superOperator the address to set\n    /// @param enabled true enable the address, false disable it.\n    /// @dev Implement\n    function _writeSuperOperator(address superOperator, bool enabled) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n    /// @notice Emitted when ownership of a contract changes.\n    /// @param previousOwner the old owner\n    /// @param newOwner the new owner\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @param newOwner The address of the new owner of the contract\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IERC721BatchOps.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title IERC721BatchOps\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice ERC721 Batch operations\ninterface IERC721BatchOps {\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external;\n\n    /// @notice Transfer many tokens between 2 addresses, while\n    /// ensuring the receiving contract has a receiver method.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IERC721MandatoryTokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ERC721MandatoryTokenReceiver\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Interface for any contract that wants to support safeBatchTransfers\n/// @notice from ERC721 asset contracts.\n/// @dev The ERC-165 identifier for this interface is 0x5e8bf644.\ninterface IERC721MandatoryTokenReceiver {\n    /// @notice Whenever tokens are transferred to this contract via {IERC721-safeBatchTransferFrom}\n    /// @notice by `operator` from `from`, this function is called.\n    /// @param operator sender\n    /// @param from owner of the tokens\n    /// @param ids token ids\n    /// @param data extra data\n    /// @return 0x4b808c46 if the transfer is a success\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    /// @notice Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n    /// @notice by `operator` from `from`, this function is called.\n    /// @param operator sender\n    /// @param from owner of the token\n    /// @param tokenId token id\n    /// @param data extra data\n    /// @return 0x150b7a02 if the transfer is a success\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/// @title Errors\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Common errors\ninterface IErrors {\n    /// @notice an address passed as argument is invalid\n    error InvalidAddress();\n\n    /// @notice an argument passed is invalid\n    error InvalidArgument();\n\n    /// @notice an array argument has an invalid length\n    error InvalidLength();\n\n    /// @notice only admin can call this function\n    error OnlyAdmin();\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/ILandMetadataRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ILandMetadataRegistry\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Interface implemented by the LandMetadataRegistry\ninterface ILandMetadataRegistry {\n    /// @notice return the metadata for one land\n    /// @param tokenId the token id\n    /// @return premium true if the land is premium\n    /// @return neighborhoodId the number that identifies the neighborhood\n    /// @return neighborhoodName the neighborhood name\n    function getMetadata(\n        uint256 tokenId\n    ) external view returns (bool premium, uint256 neighborhoodId, string memory neighborhoodName);\n\n    /// @notice return true if a land is premium\n    /// @param tokenId the token id\n    /// @return true if the land is premium\n    function isPremium(uint256 tokenId) external view returns (bool);\n\n    /// @notice return the id that identifies the neighborhood\n    /// @param tokenId the token id\n    /// @return the neighborhoodId number\n    function getNeighborhoodId(uint256 tokenId) external view returns (uint256);\n\n    /// @notice return the neighborhood name\n    /// @param tokenId the token id\n    /// @return the neighborhood name\n    function getNeighborhoodName(uint256 tokenId) external view returns (string memory);\n\n    /// @notice return the neighborhood name using neighborhood id as the key\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @return the neighborhood name\n    function getNeighborhoodNameForId(uint256 neighborhoodId) external view returns (string memory);\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/ILandToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IQuad} from \"./IQuad.sol\";\n\n/// @title ILandToken\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Interface of the LAND token including quad methods\ninterface ILandToken is IQuad {\n    /// @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n    /// @param to The recipient of the new quad\n    /// @param size The size of the new quad\n    /// @param x The bottom left x coordinate of the new quad\n    /// @param y The bottom left y coordinate of the new quad\n    /// @param data extra data to pass to the transfer\n    function mintQuad(address to, uint256 size, uint256 x, uint256 y, bytes memory data) external;\n\n    /// @notice Checks if a LAND exists by its coordinates\n    /// @param size size of the quad\n    /// @param x x coordinate\n    /// @param y y coordinate\n    /// @return does the LAND exist\n    function exists(uint256 size, uint256 x, uint256 y) external view returns (bool);\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IOperatorFilterRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title IOperatorFilterRegistry\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Interface of the operator filter registry\n/// @dev This interface comes from OpenSea https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/IOperatorFilterRegistry.sol and adapted to the 0.8.23 solidity version\ninterface IOperatorFilterRegistry {\n    /// @notice Check if the operator is allowed for the given registrant\n    /// @param registrant address of the registrant\n    /// @param operator operator address to check\n    /// @return is the operator allowed\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n    /// @notice Register a new address\n    /// @param registrant address to register\n    function register(address registrant) external;\n\n    /// @notice Register a new address & subscribe to an address\n    /// @param registrant address of the registrant\n    /// @param subscription address where the registrant is subscribed to\n    function registerAndSubscribe(address registrant, address subscription) external;\n\n    /// @notice Register and copy entries of another registrant\n    /// @param registrant address of the registrant\n    /// @param registrantToCopy address to copy from\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n    /// @notice update the operator for a registrant\n    /// @param registrant address of the registrant\n    /// @param operator operator to be updated\n    /// @param filtered is it filtered\n    function updateOperator(address registrant, address operator, bool filtered) external;\n\n    /// @notice Update operators for a registrant\n    /// @param registrant address of the registrant\n    /// @param operators addresses of the operators\n    /// @param filtered is it filtered\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n\n    /// @notice Update code hash\n    /// @param registrant address of the registrant\n    /// @param codehash code hash\n    /// @param filtered is it filtered\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n\n    /// @notice Update code hashes\n    /// @param registrant address of the registrant\n    /// @param codeHashes code hashes\n    /// @param filtered is it filtered\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n\n    /// @notice Subscribe a registrant\n    /// @param registrant address of the registrant\n    /// @param registrantToSubscribe address to subscribe with\n    function subscribe(address registrant, address registrantToSubscribe) external;\n\n    /// @notice Unsubscribe a registrant\n    /// @param registrant address of the registrant\n    /// @param copyExistingEntries copy existing entries\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n    /// @notice Get the subscription of an address\n    /// @param addr address to check\n    /// @return registrant the registrant address\n    function subscriptionOf(address addr) external returns (address registrant);\n\n    /// @notice Get the subscribers of the registrant\n    /// @param registrant address of the registrant\n    /// @return the subscribers addresses\n    function subscribers(address registrant) external returns (address[] memory);\n\n    /// @notice Get a specific subscriber\n    /// @param registrant address of the registrant\n    /// @param index index to check\n    /// @return the ith subscriber of the registrant\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n\n    /// @notice Copy the entries of a registrant\n    /// @param registrant address of the registrant\n    /// @param registrantToCopy address to copy\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n    /// @notice Is a registrant filtered\n    /// @param registrant address of the registrant\n    /// @param operator operator address to check\n    /// @return is it filtered\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n    /// @notice Is the code hash of an operator filtered\n    /// @param registrant address of the registrant\n    /// @param operatorWithCode operator address to check\n    /// @return is it filtered\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n    /// @notice Is the code hash filtered\n    /// @param registrant address of the registrant\n    /// @param codeHash code hash\n    /// @return is it filtered\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n    /// @notice Get the filtered operators\n    /// @param addr address to check\n    /// @return filtered operators\n    function filteredOperators(address addr) external returns (address[] memory);\n\n    /// @notice Get the filtered code hashes\n    /// @param addr address to check\n    /// @return filtered code hashes\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n    /// @notice Get a specific operator\n    /// @param registrant address of the registrant\n    /// @param index index to check\n    /// @return address of the operator\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n    /// @notice Get the ith filtered code hash\n    /// @param registrant address of the registrant\n    /// @param index index to check\n    /// @return the code hash\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n    /// @notice Is the address registered\n    /// @param addr address to check\n    /// @return is it registered\n    function isRegistered(address addr) external returns (bool);\n\n    /// @notice Get the code hash for this address\n    /// @param addr address to check\n    /// @return the code hash\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/interfaces/IQuad.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title IQuad\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Interface of the LAND token (quad methods)\ninterface IQuad {\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external;\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The bottom left x coordinate of the quad\n    /// @param y The bottom left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(address from, address to, uint256 size, uint256 x, uint256 y, bytes calldata data) external;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/Land.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IOperatorFilterRegistry} from \"./interfaces/IOperatorFilterRegistry.sol\";\nimport {WithAdmin} from \"./common/WithAdmin.sol\";\nimport {WithSuperOperators} from \"./common/WithSuperOperators.sol\";\nimport {OperatorFiltererUpgradeable} from \"./common/OperatorFiltererUpgradeable.sol\";\nimport {ERC721BaseToken} from \"./common/ERC721BaseToken.sol\";\nimport {LandBaseToken} from \"./common/LandBaseToken.sol\";\nimport {LandBase} from \"./common/LandBase.sol\";\nimport {LandStorageMixin} from \"./mainnet/LandStorageMixin.sol\";\n\n/// @title Land Contract on L1\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice LAND contract on L1\n/// @dev We use the storage mixing for historical reasons.\n/// @dev There is a difference between L1 and L2 storage slots order and we want to upgrade the contract.\n/// @dev This contract uses the exact storage slots configuration that we have in `core` package so we can upgrade\n/// @dev LandStorageMixin must be the first one in the inheritance chain for subclasses\ncontract Land is LandStorageMixin, LandBase {\n    /// @notice Implements the Context msg sender\n    /// @return the address of the message sender\n    function _msgSender() internal view virtual override returns (address) {\n        return msg.sender;\n    }\n\n    /// @notice get the admin address\n    /// @return the admin address\n    function _readAdmin() internal view override(LandStorageMixin, WithAdmin) returns (address) {\n        return LandStorageMixin._readAdmin();\n    }\n\n    /// @notice set the admin address\n    /// @param admin the admin address\n    function _writeAdmin(address admin) internal override(LandStorageMixin, WithAdmin) {\n        LandStorageMixin._writeAdmin(admin);\n    }\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    function _isSuperOperator(\n        address superOperator\n    ) internal view override(LandStorageMixin, WithSuperOperators) returns (bool) {\n        return LandStorageMixin._isSuperOperator(superOperator);\n    }\n\n    /// @notice enable an address to be super-operator\n    /// @param superOperator the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeSuperOperator(\n        address superOperator,\n        bool enabled\n    ) internal override(LandStorageMixin, WithSuperOperators) {\n        LandStorageMixin._writeSuperOperator(superOperator, enabled);\n    }\n\n    /// @notice get the number of nft for an address\n    /// @param owner address to check\n    /// @return the number of nfts\n    function _readNumNFTPerAddress(\n        address owner\n    ) internal view override(LandStorageMixin, ERC721BaseToken) returns (uint256) {\n        return LandStorageMixin._readNumNFTPerAddress(owner);\n    }\n\n    /// @notice set the number of nft for an address\n    /// @param owner address to set\n    /// @param quantity the number of nfts to set for the owner\n    function _writeNumNFTPerAddress(\n        address owner,\n        uint256 quantity\n    ) internal override(LandStorageMixin, ERC721BaseToken) {\n        LandStorageMixin._writeNumNFTPerAddress(owner, quantity);\n    }\n\n    /// @notice get the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @return the owner data\n    function _readOwnerData(\n        uint256 tokenId\n    ) internal view override(LandStorageMixin, ERC721BaseToken) returns (uint256) {\n        return LandStorageMixin._readOwnerData(tokenId);\n    }\n\n    /// @notice set the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @param data the owner data\n    function _writeOwnerData(uint256 tokenId, uint256 data) internal override(LandStorageMixin, ERC721BaseToken) {\n        LandStorageMixin._writeOwnerData(tokenId, data);\n    }\n\n    /// @notice check if an operator was enabled by a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @return true if the operator has access\n    function _isOperatorForAll(\n        address owner,\n        address operator\n    ) internal view override(LandStorageMixin, ERC721BaseToken) returns (bool) {\n        return LandStorageMixin._isOperatorForAll(owner, operator);\n    }\n\n    /// @notice Let an operator to access to all the tokens of a owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @param enabled if true give access to the operator, else disable it\n    function _writeOperatorForAll(\n        address owner,\n        address operator,\n        bool enabled\n    ) internal override(LandStorageMixin, ERC721BaseToken) {\n        LandStorageMixin._writeOperatorForAll(owner, operator, enabled);\n    }\n\n    /// @notice get the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId The id of the token.\n    /// @return the operator address\n    function _readOperator(\n        uint256 tokenId\n    ) internal view override(LandStorageMixin, ERC721BaseToken) returns (address) {\n        return LandStorageMixin._readOperator(tokenId);\n    }\n\n    /// @notice set the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId the id of the token.\n    /// @param operator the operator address\n    function _writeOperator(uint256 tokenId, address operator) internal override(LandStorageMixin, ERC721BaseToken) {\n        LandStorageMixin._writeOperator(tokenId, operator);\n    }\n\n    /// @notice checks if an address is enabled as minter\n    /// @param minter the address to check\n    /// @return true if the address is a minter\n    function _isMinter(address minter) internal view override(LandStorageMixin, LandBaseToken) returns (bool) {\n        return LandStorageMixin._isMinter(minter);\n    }\n\n    /// @notice set an address as minter\n    /// @param minter the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeMinter(address minter, bool enabled) internal override(LandStorageMixin, LandBaseToken) {\n        LandStorageMixin._writeMinter(minter, enabled);\n    }\n\n    /// @notice get the OpenSea operator filter\n    /// @return the address of the OpenSea operator filter registry\n    function _readOperatorFilterRegistry()\n        internal\n        view\n        override(LandStorageMixin, OperatorFiltererUpgradeable)\n        returns (IOperatorFilterRegistry)\n    {\n        return LandStorageMixin._readOperatorFilterRegistry();\n    }\n\n    /// @notice set the OpenSea operator filter\n    /// @param registry the address of the OpenSea operator filter registry\n    function _writeOperatorFilterRegistry(\n        IOperatorFilterRegistry registry\n    ) internal override(LandStorageMixin, OperatorFiltererUpgradeable) {\n        LandStorageMixin._writeOperatorFilterRegistry(registry);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/LandMetadataRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport {IErrors} from \"./interfaces/IErrors.sol\";\nimport {ILandMetadataRegistry} from \"./interfaces/ILandMetadataRegistry.sol\";\nimport {LandMetadataBase} from \"./registry/LandMetadataBase.sol\";\n\n/// @title LandMetadataRegistry\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Store information about the lands (premiumness and neighborhood)\ncontract LandMetadataRegistry is IErrors, ILandMetadataRegistry, AccessControlEnumerableUpgradeable, LandMetadataBase {\n    struct BatchSetNameData {\n        // the number that identifies the neighborhood\n        uint256 neighborhoodId;\n        // the name of the neighborhood\n        string name;\n    }\n\n    struct BatchSetData {\n        // baseTokenId the token id floor LANDS_PER_WORD\n        uint256 baseTokenId;\n        // metadata: premiumness << (BITS_PER_LAND-1) | neighborhoodId\n        uint256 metadata;\n    }\n\n    /// @notice This event is emitted when the metadata is set for a single land\n    /// @param operator the sender of the transaction\n    /// @param tokenId the token id\n    /// @param oldNeighborhoodId the number that identifies the neighborhood before changing it\n    /// @param wasPremium true if land was premium\n    /// @param newNeighborhoodId the number that identifies the neighborhood\n    /// @param isPremium true if land is premium\n    event MetadataSet(\n        address indexed operator,\n        uint256 indexed tokenId,\n        uint256 oldNeighborhoodId,\n        bool wasPremium,\n        uint256 newNeighborhoodId,\n        bool isPremium\n    );\n\n    /// @notice This event is emitted when the neighborhood name is set\n    /// @param operator the sender of the transaction\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @param name human readable name\n    event NeighborhoodNameSet(address indexed operator, uint256 indexed neighborhoodId, string name);\n\n    /// @notice This event is emitted when the metadata is set in batch\n    /// @param operator the sender of the transaction\n    /// @param data token id and metadata\n    event BatchMetadataSet(address indexed operator, BatchSetData[] data);\n\n    modifier onlyAdmin() {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\n            revert OnlyAdmin();\n        }\n        _;\n    }\n\n    /// @dev this protects the implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice initializer method, called during deployment\n    /// @param admin_ address that have admin access and can assign roles.\n    function initialize(address admin_) external initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\n    }\n\n    /// @notice set the premiumness for one land\n    /// @param tokenId the token id\n    /// @param premium true if the land is premium\n    function setPremium(uint256 tokenId, bool premium) external onlyAdmin {\n        (uint256 neighborhoodId, bool wasPremium) = _getMetadataForTokenId(tokenId);\n        _setMetadataForTokenId(tokenId, neighborhoodId, premium);\n        emit MetadataSet(_msgSender(), tokenId, neighborhoodId, wasPremium, neighborhoodId, premium);\n    }\n\n    /// @notice set the neighborhood for one land\n    /// @param tokenId the token id\n    /// @param newNeighborhoodId the number that identifies the neighborhood\n    function setNeighborhoodId(uint256 tokenId, uint256 newNeighborhoodId) external onlyAdmin {\n        _isValidNeighborhoodId(newNeighborhoodId);\n        (uint256 oldNeighborhoodId, bool wasPremium) = _getMetadataForTokenId(tokenId);\n        _setMetadataForTokenId(tokenId, newNeighborhoodId, wasPremium);\n        emit MetadataSet(_msgSender(), tokenId, oldNeighborhoodId, wasPremium, newNeighborhoodId, wasPremium);\n    }\n\n    /// @notice set the premiumness for one land\n    /// @param tokenId the token id\n    /// @param premium true if the land is premium\n    /// @param newNeighborhoodId the number that identifies the neighborhood\n    function setMetadata(uint256 tokenId, bool premium, uint256 newNeighborhoodId) external onlyAdmin {\n        _isValidNeighborhoodId(newNeighborhoodId);\n        (uint256 oldNeighborhoodId, bool wasPremium) = _getMetadataForTokenId(tokenId);\n        _setMetadataForTokenId(tokenId, newNeighborhoodId, premium);\n        emit MetadataSet(_msgSender(), tokenId, oldNeighborhoodId, wasPremium, newNeighborhoodId, premium);\n    }\n\n    /// @notice set neighborhood name\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @param name human readable name\n    function setNeighborhoodName(uint256 neighborhoodId, string calldata name) external onlyAdmin {\n        _isValidNeighborhoodId(neighborhoodId);\n        _setNeighborhoodName(neighborhoodId, name);\n        emit NeighborhoodNameSet(_msgSender(), neighborhoodId, name);\n    }\n\n    /// @notice set neighborhood name in batch\n    /// @param data array of neighborhood ids and names to set\n    function batchSetNeighborhoodName(BatchSetNameData[] calldata data) external onlyAdmin {\n        uint256 len = data.length;\n        for (uint256 i; i < len; i++) {\n            _isValidNeighborhoodId(data[i].neighborhoodId);\n            _setNeighborhoodName(data[i].neighborhoodId, data[i].name);\n            emit NeighborhoodNameSet(_msgSender(), data[i].neighborhoodId, data[i].name);\n        }\n    }\n\n    /// @notice set the metadata for LANDS_PER_WORD lands at the same time in batch\n    /// @param data token id and metadata\n    /// @dev use with care, we can set to the metadata for some lands to unknown (zero)\n    function batchSetMetadata(BatchSetData[] calldata data) external onlyAdmin {\n        uint256 len = data.length;\n        for (uint256 i; i < len; i++) {\n            BatchSetData calldata d = data[i];\n            if (_getBits(d.baseTokenId) != 0) {\n                revert InvalidBaseTokenId(d.baseTokenId);\n            }\n            _setMetadata(d.baseTokenId, d.metadata);\n        }\n        emit BatchMetadataSet(_msgSender(), data);\n    }\n\n    /// @notice return the metadata for one land\n    /// @param tokenId the token id\n    /// @return premium true if the land is premium\n    /// @return neighborhoodId the number that identifies the neighborhood\n    /// @return neighborhoodName the neighborhood name\n    function getMetadata(\n        uint256 tokenId\n    ) external view returns (bool premium, uint256 neighborhoodId, string memory neighborhoodName) {\n        (neighborhoodId, premium) = _getMetadataForTokenId(tokenId);\n        neighborhoodName = _getNeighborhoodName(neighborhoodId);\n    }\n\n    /// @notice return true if a land is premium\n    /// @param tokenId the token id\n    /// @return true if the land is premium\n    function isPremium(uint256 tokenId) external view returns (bool) {\n        (, bool premium) = _getMetadataForTokenId(tokenId);\n        return premium;\n    }\n\n    /// @notice return the id that identifies the neighborhood\n    /// @param tokenId the token id\n    /// @return the neighborhoodId number\n    function getNeighborhoodId(uint256 tokenId) external view returns (uint256) {\n        (uint256 neighborhoodId, ) = _getMetadataForTokenId(tokenId);\n        return neighborhoodId;\n    }\n\n    /// @notice return the neighborhood name\n    /// @param tokenId the token id\n    /// @return the neighborhood name\n    function getNeighborhoodName(uint256 tokenId) external view returns (string memory) {\n        (uint256 neighborhoodId, ) = _getMetadataForTokenId(tokenId);\n        return _getNeighborhoodName(neighborhoodId);\n    }\n\n    /// @notice return the neighborhood name using neighborhood id as the key\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @return the neighborhood name\n    function getNeighborhoodNameForId(uint256 neighborhoodId) external view returns (string memory) {\n        return _getNeighborhoodName(neighborhoodId);\n    }\n\n    /// @notice return the metadata of LANDS_PER_WORD lands at once\n    /// @param tokenIds the token ids\n    /// @return the raw metadata for a series of tokenIds\n    /// @dev used to debug, extracting a lot of information that must be unpacked at once.\n    function batchGetMetadata(uint256[] calldata tokenIds) external view returns (BatchSetData[] memory) {\n        uint256 len = tokenIds.length;\n        BatchSetData[] memory ret = new BatchSetData[](len);\n        for (uint256 i; i < len; i++) {\n            ret[i] = BatchSetData({baseTokenId: _getKey(tokenIds[i]), metadata: _getMetadata(tokenIds[i])});\n        }\n        return ret;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/mainnet/LandStorageMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IOperatorFilterRegistry} from \"../interfaces/IOperatorFilterRegistry.sol\";\n\n/// @title LandStorageMixin\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Storage structure of the mainnet implementation of Land contract\n/// @dev According to hardhat-storage plugin run onto the latest deployed version (@core)\n/// @dev |          contract           │      state_variable       │ storage_slot │ offset │                       type                       │ idx │                     artifact                      │ numberOfBytes │\n/// @dev |            Land             │          _admin           │      0       │   0    │                    t_address                     │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      20       │\n/// @dev |            Land             │      _superOperators      │      1       │   0    │           t_mapping(t_address,t_bool)            │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │ _metaTransactionContracts │      2       │   0    │           t_mapping(t_address,t_bool)            │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │     _numNFTPerAddress     │      3       │   0    │          t_mapping(t_address,t_uint256)          │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │          _owners          │      4       │   0    │          t_mapping(t_uint256,t_uint256)          │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │     _operatorsForAll      │      5       │   0    │ t_mapping(t_address,t_mapping(t_address,t_bool)) │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │        _operators         │      6       │   0    │          t_mapping(t_uint256,t_address)          │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │       _initialized        │      7       │   0    │                      t_bool                      │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │       1       │\n/// @dev |            Land             │           __gap           │      8       │   0    │           t_array(t_uint256)49_storage           │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │     1568      │\n/// @dev |            Land             │         _minters          │      57      │   0    │           t_mapping(t_address,t_bool)            │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      32       │\n/// @dev |            Land             │  operatorFilterRegistry   │      58      │   0    │     t_contract(IOperatorFilterRegistry)1931      │  1  │ /build-info/8962c877ac6c2963a6c119c5538d62f6.json │      20       │\ncontract LandStorageMixin {\n    /// @dev The admin of the contract\n    address internal _admin;\n\n    /// @dev super operators that can transfer tokens on behalf of all the users\n    mapping(address superOperator => bool enabled) internal _superOperators;\n\n    /// @dev Obsolete: Enabled meta-transaction processors. This feature was removed from the code.\n    mapping(address metaTransactionProcessor => bool enabled) internal _metaTransactionContracts; // unused\n\n    /// @dev Number of NFT an address own\n    mapping(address owner => uint256 numNFT) internal _numNFTPerAddress;\n\n    /// @dev mapping to store owner of lands and quads.\n    /// @dev For 1x1 lands the 255 bit is a flag that land has operator approved.\n    /// @dev For 1x1 lands the 160 bit is a flag that indicates if the token is burned.\n    mapping(uint256 owner => uint256 ownerData) internal _owners;\n\n    /// @dev Operators by owner address for all tokens\n    mapping(address owner => mapping(address operator => bool enabled)) internal _operatorsForAll;\n\n    /// @dev Operator by token id, the operator flag must be also true (see: _owners)\n    mapping(uint256 tokenId => address operator) internal _operators;\n\n    /// @dev Obsolete: Flag to check if the contract was initialized. We use OZ V5 Initializer now.\n    bool internal _initialized; // unused\n    uint256[49] private __gap; // unused\n\n    /// @dev Addresses authorized to mint tokens\n    mapping(address minter => bool enabled) internal _minters;\n\n    /// @dev OpenSea operator filter registry address\n    IOperatorFilterRegistry internal _operatorFilterRegistry;\n\n    /// @notice get the admin address\n    /// @return the admin address\n    function _readAdmin() internal view virtual returns (address) {\n        return _admin;\n    }\n\n    /// @notice set the admin address\n    /// @param admin the admin address\n    function _writeAdmin(address admin) internal virtual {\n        _admin = admin;\n    }\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    function _isSuperOperator(address superOperator) internal view virtual returns (bool) {\n        return _superOperators[superOperator];\n    }\n\n    /// @notice enable an address to be super-operator\n    /// @param superOperator the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeSuperOperator(address superOperator, bool enabled) internal virtual {\n        _superOperators[superOperator] = enabled;\n    }\n\n    /// @notice get the number of nft for an address\n    /// @param owner address to check\n    /// @return the number of nfts\n    function _readNumNFTPerAddress(address owner) internal view virtual returns (uint256) {\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice set the number of nft for an address\n    /// @param owner address to set\n    /// @param quantity the number of nfts to set for the owner\n    function _writeNumNFTPerAddress(address owner, uint256 quantity) internal virtual {\n        _numNFTPerAddress[owner] = quantity;\n    }\n\n    /// @notice get the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @return the owner data\n    function _readOwnerData(uint256 tokenId) internal view virtual returns (uint256) {\n        return _owners[tokenId];\n    }\n\n    /// @notice set the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @param data the owner data\n    function _writeOwnerData(uint256 tokenId, uint256 data) internal virtual {\n        _owners[tokenId] = data;\n    }\n\n    /// @notice check if an operator was enabled by a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @return true if the operator has access\n    function _isOperatorForAll(address owner, address operator) internal view virtual returns (bool) {\n        return _operatorsForAll[owner][operator];\n    }\n\n    /// @notice Let an operator to access to all the tokens of a owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @param enabled if true give access to the operator, else disable it\n    function _writeOperatorForAll(address owner, address operator, bool enabled) internal virtual {\n        _operatorsForAll[owner][operator] = enabled;\n    }\n\n    /// @notice get the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId The id of the token.\n    /// @return the operator address\n    function _readOperator(uint256 tokenId) internal view virtual returns (address) {\n        return _operators[tokenId];\n    }\n\n    /// @notice set the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId the id of the token.\n    /// @param operator the operator address\n    function _writeOperator(uint256 tokenId, address operator) internal virtual {\n        _operators[tokenId] = operator;\n    }\n\n    /// @notice checks if an address is enabled as minter\n    /// @param minter the address to check\n    /// @return true if the address is a minter\n    function _isMinter(address minter) internal view virtual returns (bool) {\n        return _minters[minter];\n    }\n\n    /// @notice set an address as minter\n    /// @param minter the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeMinter(address minter, bool enabled) internal virtual {\n        _minters[minter] = enabled;\n    }\n\n    /// @notice get the OpenSea operator filter\n    /// @return the address of the OpenSea operator filter registry\n    function _readOperatorFilterRegistry() internal view virtual returns (IOperatorFilterRegistry) {\n        return _operatorFilterRegistry;\n    }\n\n    /// @notice set the OpenSea operator filter\n    /// @param registry the address of the OpenSea operator filter registry\n    function _writeOperatorFilterRegistry(IOperatorFilterRegistry registry) internal virtual {\n        _operatorFilterRegistry = registry;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/polygon/ERC2771Handler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/// @title ERC2771Handler\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Handle meta-transactions\n/// @dev minimal ERC2771 handler to keep bytecode-size down\n/// @dev based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/metatx/ERC2771Context.sol\n/// @dev with an initializer for proxies and a mutable forwarder\nabstract contract ERC2771Handler {\n    /// @notice emitted when a new trusted forwarder is set\n    /// @param newForwarder the new trusted forwarder\n    event TrustedForwarderSet(address indexed newForwarder);\n\n    /// @notice Checks if an address is a trusted forwarder\n    /// @param forwarder address to check\n    /// @return is trusted\n    function isTrustedForwarder(address forwarder) external view returns (bool) {\n        return _isTrustedForwarder(forwarder);\n    }\n\n    /// @notice Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function _setTrustedForwarder(address trustedForwarder) internal {\n        _writeTrustedForwarder(trustedForwarder);\n        emit TrustedForwarderSet(trustedForwarder);\n    }\n\n    /// @notice Get the current trusted forwarder\n    /// @return trustedForwarder address of the trusted forwarder\n    function getTrustedForwarder() external view returns (address) {\n        return _readTrustedForwarder();\n    }\n\n    /// @dev if the call comes from the trusted forwarder, it gets the real sender by checking the encoded address in the data\n    /// @return sender address of the real sender\n    function _msgSender() internal view virtual returns (address sender) {\n        if (_isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            sender = msg.sender;\n        }\n    }\n\n    /// @notice Checks if an address is a trusted forwarder\n    /// @param trustedForwarder address to check\n    /// @return is trusted\n    function _isTrustedForwarder(address trustedForwarder) internal view returns (bool) {\n        return trustedForwarder == _readTrustedForwarder();\n    }\n\n    /// @notice get the address of the ERC2771 trusted forwarder\n    /// @return the address of the trusted forwarder\n    function _readTrustedForwarder() internal view virtual returns (address);\n\n    /// @notice set the address of the ERC2771 trusted forwarder\n    /// @param trustedForwarder the address of the trusted forwarder\n    function _writeTrustedForwarder(address trustedForwarder) internal virtual;\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/polygon/PolygonLandStorageMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IOperatorFilterRegistry} from \"../interfaces/IOperatorFilterRegistry.sol\";\n\n/// @title PolygonLandStorageMixin\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Storage structure of the Polygon implementation of Land contract\n/// @dev According to hardhat-storage plugin run onto the latest deployed version (@core)\n/// @dev |          contract           │      state_variable       │ storage_slot │ offset │                       type                       │ idx │                     artifact                      │ numberOfBytes │\n/// @dev |         PolygonLand         │       _initialized        │      0       │   0    │                     t_uint8                      │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │       1       │\n/// @dev |         PolygonLand         │       _initializing       │      0       │   1    │                      t_bool                      │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │       1       │\n/// @dev |         PolygonLand         │           __gap           │      1       │   0    │           t_array(t_uint256)50_storage           │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │     1600      │\n/// @dev |         PolygonLand         │          _admin           │      51      │   0    │                    t_address                     │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      20       │\n/// @dev |         PolygonLand         │      _superOperators      │      52      │   0    │           t_mapping(t_address,t_bool)            │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │     _numNFTPerAddress     │      53      │   0    │          t_mapping(t_address,t_uint256)          │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │          _owners          │      54      │   0    │          t_mapping(t_uint256,t_uint256)          │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │     _operatorsForAll      │      55      │   0    │ t_mapping(t_address,t_mapping(t_address,t_bool)) │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │        _operators         │      56      │   0    │          t_mapping(t_uint256,t_address)          │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │         _minters          │      57      │   0    │           t_mapping(t_address,t_bool)            │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      32       │\n/// @dev |         PolygonLand         │           __gap           │      58      │   0    │           t_array(t_uint256)49_storage           │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │     1568      │\n/// @dev |         PolygonLand         │     _trustedForwarder     │     107      │   0    │                    t_address                     │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      20       │\n/// @dev |         PolygonLand         │  operatorFilterRegistry   │     108      │   0    │     t_contract(IOperatorFilterRegistry)3942      │  0  │ /build-info/3abb06944792151ded64cbcd19543bb1.json │      20       │\ncontract PolygonLandStorageMixin {\n    /// @dev Obsolete: This is the storage used by the OZ v4 Initializer, they are unused now.\n    uint8 private _initialized; // unused\n    bool private _initializing; // unused\n    uint256[50] private ___gap; // unused\n\n    /// @dev The admin of the contract\n    address internal _admin;\n\n    /// @dev super operators that can transfer tokens on behalf of all the users\n    mapping(address superOperator => bool enabled) internal _superOperators;\n\n    /// @dev Number of NFT an address own\n    mapping(address owner => uint256 numNFT) internal _numNFTPerAddress;\n\n    /// @dev mapping to store owner of lands and quads.\n    /// @dev For 1x1 lands the 255 bit is a flag that land has operator approved.\n    /// @dev For 1x1 lands the 160 bit is a flag that indicates if the token is burned.\n    mapping(uint256 owner => uint256 ownerData) internal _owners;\n\n    /// @dev Operators by owner address for all tokens\n    mapping(address owner => mapping(address operator => bool enabled)) internal _operatorsForAll;\n\n    /// @dev Operator by token id, the operator flag must be also true (see: _owners)\n    mapping(uint256 tokenId => address operator) internal _operators;\n\n    /// @dev Addresses authorized to mint tokens\n    mapping(address minter => bool enabled) internal _minters;\n\n    uint256[49] private __gap;\n\n    /// @dev meta transaction ERC2771 trusted forwarder\n    address internal _trustedForwarder;\n\n    /// @dev OpenSea operator filter registry address\n    IOperatorFilterRegistry internal _operatorFilterRegistry;\n\n    /// @notice get the admin address\n    /// @return the admin address\n    function _readAdmin() internal view virtual returns (address) {\n        return _admin;\n    }\n\n    /// @notice set the admin address\n    /// @param admin the admin address\n    function _writeAdmin(address admin) internal virtual {\n        _admin = admin;\n    }\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    function _isSuperOperator(address superOperator) internal view virtual returns (bool) {\n        return _superOperators[superOperator];\n    }\n\n    /// @notice enable an address to be super-operator\n    /// @param superOperator the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeSuperOperator(address superOperator, bool enabled) internal virtual {\n        _superOperators[superOperator] = enabled;\n    }\n\n    /// @notice get the number of nft for an address\n    /// @param owner address to check\n    /// @return the number of nfts\n    function _readNumNFTPerAddress(address owner) internal view virtual returns (uint256) {\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice set the number of nft for an address\n    /// @param owner address to set\n    /// @param quantity the number of nfts to set for the owner\n    function _writeNumNFTPerAddress(address owner, uint256 quantity) internal virtual {\n        _numNFTPerAddress[owner] = quantity;\n    }\n\n    /// @notice get the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @return the owner data\n    function _readOwnerData(uint256 tokenId) internal view virtual returns (uint256) {\n        return _owners[tokenId];\n    }\n\n    /// @notice set the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @param data the owner data\n    function _writeOwnerData(uint256 tokenId, uint256 data) internal virtual {\n        _owners[tokenId] = data;\n    }\n\n    /// @notice check if an operator was enabled by a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @return true if the operator has access\n    function _isOperatorForAll(address owner, address operator) internal view virtual returns (bool) {\n        return _operatorsForAll[owner][operator];\n    }\n\n    /// @notice Let an operator to access to all the tokens of a owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @param enabled if true give access to the operator, else disable it\n    function _writeOperatorForAll(address owner, address operator, bool enabled) internal virtual {\n        _operatorsForAll[owner][operator] = enabled;\n    }\n\n    /// @notice get the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId The id of the token.\n    /// @return the operator address\n    function _readOperator(uint256 tokenId) internal view virtual returns (address) {\n        return _operators[tokenId];\n    }\n\n    /// @notice set the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId the id of the token.\n    /// @param operator the operator address\n    function _writeOperator(uint256 tokenId, address operator) internal virtual {\n        _operators[tokenId] = operator;\n    }\n\n    /// @notice checks if an address is enabled as minter\n    /// @param minter the address to check\n    /// @return true if the address is a minter\n    function _isMinter(address minter) internal view virtual returns (bool) {\n        return _minters[minter];\n    }\n\n    /// @notice set an address as minter\n    /// @param minter the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeMinter(address minter, bool enabled) internal virtual {\n        _minters[minter] = enabled;\n    }\n\n    /// @notice get the address of the ERC2771 trusted forwarder\n    /// @return the address of the trusted forwarder\n    function _readTrustedForwarder() internal view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /// @notice set the address of the ERC2771 trusted forwarder\n    /// @param trustedForwarder the address of the trusted forwarder\n    function _writeTrustedForwarder(address trustedForwarder) internal virtual {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @notice get the OpenSea operator filter\n    /// @return the address of the OpenSea operator filter registry\n    function _readOperatorFilterRegistry() internal view virtual returns (IOperatorFilterRegistry) {\n        return _operatorFilterRegistry;\n    }\n\n    /// @notice set the OpenSea operator filter\n    /// @param registry the address of the OpenSea operator filter registry\n    function _writeOperatorFilterRegistry(IOperatorFilterRegistry registry) internal virtual {\n        _operatorFilterRegistry = registry;\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/PolygonLand.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IOperatorFilterRegistry} from \"./interfaces/IOperatorFilterRegistry.sol\";\nimport {WithAdmin} from \"./common/WithAdmin.sol\";\nimport {WithSuperOperators} from \"./common/WithSuperOperators.sol\";\nimport {OperatorFiltererUpgradeable} from \"./common/OperatorFiltererUpgradeable.sol\";\nimport {ERC721BaseToken} from \"./common/ERC721BaseToken.sol\";\nimport {LandBaseToken} from \"./common/LandBaseToken.sol\";\nimport {ERC2771Handler} from \"./polygon/ERC2771Handler.sol\";\nimport {PolygonLandStorageMixin} from \"./polygon/PolygonLandStorageMixin.sol\";\nimport {LandBase} from \"./common/LandBase.sol\";\n\n/// @title LAND token on L2\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice LAND contract on L2\n/// @dev We use the storage mixing for historical reasons.\n/// @dev There is a difference between L1 and L2 storage slots order and we want to upgrade the contract.\n/// @dev This contract uses the exact storage slots configuration that we have in `core` package so we can upgrade\n/// @dev PolygonLandStorageMixin must be the first one in the inheritance chain for subclasses\ncontract PolygonLand is PolygonLandStorageMixin, LandBase, ERC2771Handler {\n    /// @notice Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyAdmin {\n        _setTrustedForwarder(trustedForwarder);\n    }\n\n    /// @notice Implements the Context msg sender\n    /// @return the address of the message sender\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address) {\n        return ERC2771Handler._msgSender();\n    }\n\n    /// @notice get the admin address\n    /// @return the admin address\n    function _readAdmin() internal view override(PolygonLandStorageMixin, WithAdmin) returns (address) {\n        return PolygonLandStorageMixin._readAdmin();\n    }\n\n    /// @notice set the admin address\n    /// @param admin the admin address\n    function _writeAdmin(address admin) internal override(PolygonLandStorageMixin, WithAdmin) {\n        PolygonLandStorageMixin._writeAdmin(admin);\n    }\n\n    /// @notice check if an address is a super-operator\n    /// @param superOperator the operator address to check\n    /// @return true if an address is a super-operator\n    function _isSuperOperator(\n        address superOperator\n    ) internal view override(PolygonLandStorageMixin, WithSuperOperators) returns (bool) {\n        return PolygonLandStorageMixin._isSuperOperator(superOperator);\n    }\n\n    /// @notice enable an address to be super-operator\n    /// @param superOperator the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeSuperOperator(\n        address superOperator,\n        bool enabled\n    ) internal override(PolygonLandStorageMixin, WithSuperOperators) {\n        PolygonLandStorageMixin._writeSuperOperator(superOperator, enabled);\n    }\n\n    /// @notice get the number of nft for an address\n    /// @param owner address to check\n    /// @return the number of nfts\n    function _readNumNFTPerAddress(\n        address owner\n    ) internal view override(PolygonLandStorageMixin, ERC721BaseToken) returns (uint256) {\n        return PolygonLandStorageMixin._readNumNFTPerAddress(owner);\n    }\n\n    /// @notice set the number of nft for an address\n    /// @param owner address to set\n    /// @param quantity the number of nfts to set for the owner\n    function _writeNumNFTPerAddress(\n        address owner,\n        uint256 quantity\n    ) internal override(PolygonLandStorageMixin, ERC721BaseToken) {\n        PolygonLandStorageMixin._writeNumNFTPerAddress(owner, quantity);\n    }\n\n    /// @notice get the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @return the owner data\n    function _readOwnerData(\n        uint256 tokenId\n    ) internal view override(PolygonLandStorageMixin, ERC721BaseToken) returns (uint256) {\n        return PolygonLandStorageMixin._readOwnerData(tokenId);\n    }\n\n    /// @notice set the owner data, this includes: owner address, burn flag and operator flag (see: _owners declaration)\n    /// @param tokenId the token Id\n    /// @param data the owner data\n    function _writeOwnerData(\n        uint256 tokenId,\n        uint256 data\n    ) internal override(PolygonLandStorageMixin, ERC721BaseToken) {\n        PolygonLandStorageMixin._writeOwnerData(tokenId, data);\n    }\n\n    /// @notice check if an operator was enabled by a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @return true if the operator has access\n    function _isOperatorForAll(\n        address owner,\n        address operator\n    ) internal view override(PolygonLandStorageMixin, ERC721BaseToken) returns (bool) {\n        return PolygonLandStorageMixin._isOperatorForAll(owner, operator);\n    }\n\n    /// @notice set an operator for a given owner\n    /// @param owner that enabled the operator\n    /// @param operator address to check if it was enabled\n    /// @param enabled true enable the address, false disable it.\n    function _writeOperatorForAll(\n        address owner,\n        address operator,\n        bool enabled\n    ) internal override(PolygonLandStorageMixin, ERC721BaseToken) {\n        PolygonLandStorageMixin._writeOperatorForAll(owner, operator, enabled);\n    }\n\n    /// @notice get the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId The id of the token.\n    /// @return the operator address\n    function _readOperator(\n        uint256 tokenId\n    ) internal view override(PolygonLandStorageMixin, ERC721BaseToken) returns (address) {\n        return PolygonLandStorageMixin._readOperator(tokenId);\n    }\n\n    /// @notice set the operator for a specific token, the operator can transfer on the owner behalf\n    /// @param tokenId the id of the token.\n    /// @param operator the operator address\n    function _writeOperator(\n        uint256 tokenId,\n        address operator\n    ) internal override(PolygonLandStorageMixin, ERC721BaseToken) {\n        PolygonLandStorageMixin._writeOperator(tokenId, operator);\n    }\n\n    /// @notice checks if an address is enabled as minter\n    /// @param minter the address to check\n    /// @return true if the address is a minter\n    function _isMinter(address minter) internal view override(PolygonLandStorageMixin, LandBaseToken) returns (bool) {\n        return PolygonLandStorageMixin._isMinter(minter);\n    }\n\n    /// @notice set an address as minter\n    /// @param minter the address to set\n    /// @param enabled true enable the address, false disable it.\n    function _writeMinter(address minter, bool enabled) internal override(PolygonLandStorageMixin, LandBaseToken) {\n        PolygonLandStorageMixin._writeMinter(minter, enabled);\n    }\n\n    /// @notice get the address of the ERC2771 trusted forwarder\n    /// @return the address of the trusted forwarder\n    function _readTrustedForwarder() internal view override(PolygonLandStorageMixin, ERC2771Handler) returns (address) {\n        return PolygonLandStorageMixin._readTrustedForwarder();\n    }\n\n    /// @notice set the address of the ERC2771 trusted forwarder\n    /// @param trustedForwarder the address of the trusted forwarder\n    function _writeTrustedForwarder(\n        address trustedForwarder\n    ) internal virtual override(PolygonLandStorageMixin, ERC2771Handler) {\n        PolygonLandStorageMixin._writeTrustedForwarder(trustedForwarder);\n    }\n\n    /// @notice get the OpenSea operator filter\n    /// @return the address of the OpenSea operator filter registry\n    function _readOperatorFilterRegistry()\n        internal\n        view\n        override(PolygonLandStorageMixin, OperatorFiltererUpgradeable)\n        returns (IOperatorFilterRegistry)\n    {\n        return PolygonLandStorageMixin._readOperatorFilterRegistry();\n    }\n\n    /// @notice set the OpenSea operator filter\n    /// @param registry the address of the OpenSea operator filter registry\n    function _writeOperatorFilterRegistry(\n        IOperatorFilterRegistry registry\n    ) internal override(PolygonLandStorageMixin, OperatorFiltererUpgradeable) {\n        PolygonLandStorageMixin._writeOperatorFilterRegistry(registry);\n    }\n}\n"
    },
    "@sandbox-smart-contracts/land/contracts/registry/LandMetadataBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/// @title LandMetadataBase\n/// @author The Sandbox\n/// @custom:security-contact contact-blockchain@sandbox.game\n/// @notice Store information about the lands (premiumness and neighborhood)\nabstract contract LandMetadataBase {\n    /// @notice the base token id used for a batch operation is wrong\n    /// @param tokenId the id of the token\n    error InvalidBaseTokenId(uint256 tokenId);\n\n    /// @notice the neighborhoodId is invalid\n    /// @param neighborhoodId the invalid neighborhoodId\n    error InvalidNeighborhoodId(uint256 neighborhoodId);\n\n    /// @notice value returned when the neighborhood is not set yet.\n    string public constant UNKNOWN_NEIGHBORHOOD = \"unknown\";\n    /// @notice amount of land information that can be stored in one EVM word\n    uint256 public constant LANDS_PER_WORD = 16;\n    /// @notice bits of information stored for each land: for example: 16\n    uint256 public constant BITS_PER_LAND = 256 / LANDS_PER_WORD;\n    /// @notice used to mask the bits of information stored per land, for example: 0xFFFF\n    uint256 public constant LAND_MASK = (1 << BITS_PER_LAND) - 1;\n    /// @notice mask used to extract the premium bit, for example: 0x8000\n    uint256 public constant PREMIUM_MASK = 1 << (BITS_PER_LAND - 1);\n    /// @notice mask used to extract the neighborhood number, for example: 0x7FFF\n    uint256 public constant NEIGHBORHOOD_MASK = PREMIUM_MASK - 1;\n\n    struct LandMetadataStorage {\n        /// @dev tokenId / LANDS_PER_WORD => premiumness + neighborhood metadata\n        /// @dev zero means no metadata definition\n        mapping(uint256 tokenId => uint256 metadataType) _metadata;\n        /// @dev neighborhood number to string mapping\n        mapping(uint256 neighborhoodNumber => string neighborhoodName) _neighborhoodName;\n    }\n\n    /// @custom:storage-location erc7201:thesandbox.storage.land.registry.LandMetadataBase\n    bytes32 internal constant METADATA_STORAGE_LOCATION =\n        0x8cfaa91df3342c358a2782e14267fc6692d3715672a46842d54671de765d4c00;\n\n    function _getLandMetadataStorage() private pure returns (LandMetadataStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := METADATA_STORAGE_LOCATION\n        }\n    }\n\n    /// @notice set the packed metadata (premiumness + neighborhood) for a land\n    /// @param tokenId the token id\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @param premium true if is premium\n    function _setMetadataForTokenId(uint256 tokenId, uint256 neighborhoodId, bool premium) internal {\n        uint256 bits = _getBits(tokenId);\n        uint256 mask = ~(LAND_MASK << bits);\n        uint256 metadata = neighborhoodId;\n        if (premium) metadata |= PREMIUM_MASK;\n        _setMetadata(tokenId, (_getMetadata(tokenId) & mask) | (metadata << bits));\n    }\n\n    /// @notice get the packed metadata for a single land\n    /// @param tokenId the base token id floor LANDS_PER_WORD\n    /// @return neighborhoodId the number that identifies the neighborhood\n    /// @return premium true if is premium\n    function _getMetadataForTokenId(uint256 tokenId) internal view returns (uint256 neighborhoodId, bool premium) {\n        uint256 bits = _getBits(tokenId);\n        uint256 metadata = _getMetadata(tokenId) >> bits;\n        neighborhoodId = metadata & NEIGHBORHOOD_MASK;\n        premium = (metadata & PREMIUM_MASK) != 0;\n    }\n\n    /// @notice set the packed metadata for LANDS_PER_WORD lands at once\n    /// @param tokenId the base token id floor LANDS_PER_WORD\n    /// @param metadata the packed metadata for LANDS_PER_WORD lands\n    function _setMetadata(uint256 tokenId, uint256 metadata) internal {\n        LandMetadataStorage storage $ = _getLandMetadataStorage();\n        $._metadata[_getKey(tokenId)] = metadata;\n    }\n\n    /// @notice return the packed metadata for LANDS_PER_WORD lands at once\n    /// @param tokenId the base token id floor LANDS_PER_WORD\n    function _getMetadata(uint256 tokenId) internal view returns (uint256) {\n        LandMetadataStorage storage $ = _getLandMetadataStorage();\n        return $._metadata[_getKey(tokenId)];\n    }\n\n    /// @notice set neighborhood name\n    /// @param neighborhoodId the number that identifies the neighborhood\n    /// @param name human readable name\n    function _setNeighborhoodName(uint256 neighborhoodId, string memory name) internal {\n        LandMetadataStorage storage $ = _getLandMetadataStorage();\n        $._neighborhoodName[neighborhoodId] = name;\n    }\n\n    /// @notice return the neighborhood name\n    /// @param neighborhoodId the number that identifies the neighborhood\n    function _getNeighborhoodName(uint256 neighborhoodId) internal view returns (string memory) {\n        LandMetadataStorage storage $ = _getLandMetadataStorage();\n        if (neighborhoodId == 0) {\n            return UNKNOWN_NEIGHBORHOOD;\n        }\n        return $._neighborhoodName[neighborhoodId];\n    }\n\n    /// @notice return the amount of bits must be shifted to access the packed metadata for a land\n    /// @param tokenId the token id\n    function _getBits(uint256 tokenId) internal pure returns (uint256) {\n        return (tokenId % LANDS_PER_WORD) * BITS_PER_LAND;\n    }\n\n    /// @notice return the tokenId floor LANDS_PER_WORD\n    /// @param tokenId the token id\n    function _getKey(uint256 tokenId) internal pure returns (uint256) {\n        return LANDS_PER_WORD * (tokenId / LANDS_PER_WORD);\n    }\n\n    /// @notice checks if a neighborhoodId is in range\n    /// @param neighborhoodId the number that identifies the neighborhood\n    function _isValidNeighborhoodId(uint256 neighborhoodId) internal pure {\n        // Cannot set it to unknown (zero).\n        if (neighborhoodId == 0) {\n            revert InvalidNeighborhoodId(neighborhoodId);\n        }\n        // the last id: NEIGHBORHOOD_MASK is left out to use as escape char if needed in the future.\n        if (neighborhoodId >= NEIGHBORHOOD_MASK) {\n            revert InvalidNeighborhoodId(neighborhoodId);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}