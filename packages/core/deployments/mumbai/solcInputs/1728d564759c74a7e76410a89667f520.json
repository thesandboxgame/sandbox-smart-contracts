{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title ERC2771Handler\n * @author The Sandbox\n * @notice Handle meta-transactions\n * @dev minimal ERC2771 handler to keep bytecode-size down\n * based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/metatx/ERC2771Context.sol\n * with an initializer for proxies and a mutable forwarder\n */\nabstract contract ERC2771Handler {\n    address internal _trustedForwarder;\n\n    event TrustedForwarderSet(address indexed newForwarder);\n\n    /**\n     * @dev Initializes the contract\n     * @param forwarder trusted forwarder address\n     */\n    function __ERC2771Handler_initialize(address forwarder) internal {\n        _trustedForwarder = forwarder;\n        emit TrustedForwarderSet(_trustedForwarder);\n    }\n\n    /**\n     * @notice Checks if an address is a trusted forwarder\n     * @param forwarder address to check\n     * @return is trusted\n     */\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    /**\n     * @notice Get the current trusted forwarder\n     * @return trustedForwarder address of the trusted forwarder\n     */\n    function getTrustedForwarder() external view returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev if the call comes from the trusted forwarder, it gets the real sender by checking the encoded address in the data\n     * @return sender address of the real sender\n     */\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * @dev if the call comes from the trusted forwarder, it substracts the sender address from `msg.data` to get the real `msg.data`\n     * @return the real `msg.data`\n     */\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC721BaseTokenV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n/* solhint-disable func-order, code-complexity */\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {\n    IERC721ReceiverUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {WithSuperOperatorsV2} from \"./WithSuperOperatorsV2.sol\";\nimport {IERC721MandatoryTokenReceiver} from \"../interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title ERC721BaseTokenV2\n/// @author The Sandbox\n/// @notice Basic functionalities of a NFT\n/// @dev ERC721 implementation that supports meta-transactions and super operators\ncontract ERC721BaseTokenV2 is ContextUpgradeable, IERC721Upgradeable, WithSuperOperatorsV2 {\n    using AddressUpgradeable for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    uint256 internal constant NOT_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\n    uint256 internal constant OPERATOR_FLAG = (2**255);\n    uint256 internal constant NOT_OPERATOR_FLAG = OPERATOR_FLAG - 1;\n    uint256 internal constant BURNED_FLAG = (2**160);\n\n    mapping(address => uint256) internal _numNFTPerAddress;\n    /**\n     * @dev mapping to store owner of lands and quads.\n     * For 1x1 lands it also the 255 bit is 1 if that land has operator approved and is 0 if no operator is approved.\n     * For burned 1x1 Land 160 bit is set to 1.\n     */\n    mapping(uint256 => uint256) internal _owners;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    mapping(uint256 => address) internal _operators;\n\n    /// @notice Approve an operator to spend tokens on the senders behalf.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approve(address operator, uint256 id) public virtual override {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = _ownerOf(id);\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(\n            owner == msgSender || _operatorsForAll[owner][msgSender] || _superOperators[msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Approve an operator to spend tokens on the sender behalf.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public virtual {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = _ownerOf(id);\n        address msgSender = _msgSender();\n        require(sender != address(0), \"ZERO_ADDRESS_SENDER\");\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(\n            msgSender == sender || _operatorsForAll[sender][msgSender] || _superOperators[msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        require(address(uint160(ownerData)) == sender, \"OWNER_NOT_SENDER\");\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Transfer a token between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, \"\"), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual override {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public virtual {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    /// @notice Transfer many tokens between 2 addresses, while\n    /// ensuring the receiving contract has a receiver method.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external virtual {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public virtual {\n        require(sender != address(0), \"Invalid sender address\");\n        address msgSender = _msgSender();\n        require(msgSender == sender || _superOperators[msgSender], \"UNAUTHORIZED_APPROVE_FOR_ALL\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id The token which will be burnt.\n    function burn(uint256 id) external virtual {\n        _burn(_msgSender(), _ownerOf(id), id);\n    }\n\n    /// @notice Burn token `id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id The token which will be burnt.\n    function burnFrom(address from, uint256 id) external virtual {\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(\n            msgSender == from ||\n                (operatorEnabled && _operators[id] == msgSender) ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender],\n            \"UNAUTHORIZED_BURN\"\n        );\n        _burn(from, owner, id);\n    }\n\n    /// @notice Get the number of tokens owned by an address.\n    /// @param owner The address to look for.\n    /// @return The number of tokens owned by the address.\n    function balanceOf(address owner) external view override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS_OWNER\");\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice Get the owner of a token.\n    /// @param id The id of the token.\n    /// @return owner The address of the token owner.\n    function ownerOf(uint256 id) external view override returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"NONEXISTANT_TOKEN\");\n    }\n\n    /// @notice Get the approved operator for a specific token.\n    /// @param id The id of the token.\n    /// @return The address of the operator.\n    function getApproved(uint256 id) external view override returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @notice Check if the sender approved the operator.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    /// @param data Additional data.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, data), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Check if the contract supports an interface.\n    /// 0x01ffc9a7 is ERC-165.\n    /// 0x80ac58cd is ERC-721\n    /// @param id The id of the interface.\n    /// @return Whether the interface is supported.\n    function supportsInterface(bytes4 id) public pure virtual override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /// @dev By overriding this function in an implementation which inherits this contract,\n    /// you can enable versioned tokenIds without the extra overhead of writing to a new storage slot in _owners each time a version is incremented.\n    /// See GameToken._storageId() for an example, where the storageId is the tokenId minus the version number.\n    /// !!! Caution !!! Overriding this function without taking appropriate care could lead to\n    /// ownerOf() returning an owner for non-existent tokens. Tests should be written to\n    /// guard against introducing this bug.\n    /// @param id The id of a token.\n    /// @return The id used for storage mappings.\n    function _storageId(uint256 id) internal view virtual returns (uint256) {\n        return id;\n    }\n\n    function _updateOwnerData(\n        uint256 id,\n        uint256 oldData,\n        address newOwner,\n        bool hasOperator\n    ) internal virtual {\n        if (hasOperator) {\n            _owners[_storageId(id)] = (oldData & NOT_ADDRESS) | OPERATOR_FLAG | uint256(uint160(newOwner));\n        } else {\n            _owners[_storageId(id)] = ((oldData & NOT_ADDRESS) & NOT_OPERATOR_FLAG) | uint256(uint160(newOwner));\n        }\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _updateOwnerData(id, _owners[_storageId(id)], to, false);\n        emit Transfer(from, to, id);\n    }\n\n    /// @dev See approveFor.\n    function _approveFor(\n        uint256 ownerData,\n        address operator,\n        uint256 id\n    ) internal {\n        address owner = _ownerOf(id);\n        if (operator == address(0)) {\n            _updateOwnerData(id, ownerData, owner, false);\n        } else {\n            _updateOwnerData(id, ownerData, owner, true);\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /// @dev See batchTransferFrom.\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _operatorsForAll[from][msgSender] || _superOperators[msgSender];\n\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"BATCHTRANSFERFROM_NOT_OWNER\");\n            require(authorized || (operatorEnabled && _operators[id] == msgSender), \"NOT_AUTHORIZED\");\n            _updateOwnerData(id, _owners[_storageId(id)], to, false);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(_checkOnERC721BatchReceived(msgSender, from, to, ids, data), \"ERC721_BATCH_RECEIVED_REJECTED\");\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i++) {\n                    require(_checkOnERC721Received(msgSender, from, to, ids[i], data), \"ERC721_RECEIVED_REJECTED\");\n                }\n            }\n        }\n    }\n\n    /// @dev See setApprovalForAll.\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_APPROVAL_CHANGE\");\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /// @dev See burn.\n    function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) internal {\n        require(from == owner, \"NOT_OWNER\");\n        uint256 storageId = _storageId(id);\n        _owners[storageId] = (_owners[storageId] & NOT_OPERATOR_FLAG) | BURNED_FLAG; // record as non owner but keep track of last owner\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param tokenId The id of the token we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x150b7a02 is returned.\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 batch transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The address we want to transfer to.\n    /// @param ids The ids of the tokens we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x4b808c46 is returned.\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    /// @dev See ownerOf\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            return address(0);\n        }\n        return address(uint160(data));\n    }\n\n    /// @dev Get the owner and operatorEnabled status of a token.\n    /// @param id The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        virtual\n        returns (address owner, bool operatorEnabled)\n    {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n        } else {\n            owner = address(uint160(data));\n        }\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n    }\n\n    /// @dev Check whether a transfer is a meta Transaction or not.\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param to The address receiving the token.\n    /// @param id The token being transferred.\n    function _checkTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal view {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(owner == from, \"CHECKTRANSFER_NOT_OWNER\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(\n            msgSender == owner ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender] ||\n                (operatorEnabled && _operators[id] == msgSender),\n            \"UNAUTHORIZED_TRANSFER\"\n        );\n    }\n\n    /// @dev Check if there was enough gas.\n    /// @param _contract The address of the contract to check.\n    /// @param interfaceId The id of the interface we want to test.\n    /// @return Whether or not this check succeeded.\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory callData = abi.encodeWithSelector(ERC165ID, interfaceId);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, callData)\n            let call_size := mload(callData)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithAdminV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title WithAdminV2\n/// @author The Sandbox\n/// @notice Add an admin to the contract\ncontract WithAdminV2 is ContextUpgradeable {\n    address internal _admin;\n\n    /// @dev Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    modifier onlyAdmin() {\n        require(_msgSender() == _admin, \"ADMIN_ONLY\");\n        _;\n    }\n\n    /// @notice Get the current admin\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice Change the admin of the contract\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        address admin = _admin;\n        require(_msgSender() == admin, \"ADMIN_ACCESS_DENIED\");\n        emit AdminChanged(admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithSuperOperatorsV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {WithAdminV2} from \"./WithAdminV2.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title WithSuperOperatorsV2\n/// @author The Sandbox\n/// @notice Add super operators handled by an admin\ncontract WithSuperOperatorsV2 is ContextUpgradeable, WithAdminV2 {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address indexed superOperator, bool indexed enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external onlyAdmin {\n        require(_msgSender() == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title IERC721MandatoryTokenReceiver\n * @author The Sandbox\n * @notice Interface for any contract that wants to support safeBatchTransfers\n * from ERC721 asset contracts.\n * @dev The ERC-165 identifier for this interface is 0x5e8bf644.\n */\ninterface IERC721MandatoryTokenReceiver {\n    /**\n     * @notice Whenever tokens are transferred to this contract via {IERC721-safeBatchTransferFrom}\n     * by `operator` from `from`, this function is called.\n     * @param operator sender\n     * @param from owner of the tokens\n     * @param ids token ids\n     * @param data extra data\n     * @return 0x4b808c46 if the transfer is a success\n     */\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    /**\n     * @notice Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     * @param operator sender\n     * @param from owner of the token\n     * @param tokenId token id\n     * @param data extra data\n     * @return 0x4b808c46 if the transfer is a success\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n}\n"
    },
    "src/solc_0.8/common/interfaces/ILandToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/// @title ILandToken\n/// @author The Sandbox\n/// @notice Interface of the LAND token including quad methods\ninterface ILandToken {\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external;\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external;\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/solc_0.8/common/interfaces/IPolygonLand.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {ILandToken} from \"./ILandToken.sol\";\n\n/**\n * @title IPolygonLand\n * @author The Sandbox\n * @notice Interface of the LAND token on the child chain\n */\ninterface IPolygonLand is ILandToken {\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external;\n\n    /**\n     * @notice Checks if a LAND exists by its coordinates\n     * @param size size of the quad\n     * @param x x coordinate\n     * @param y y coordinate\n     * @return does the LAND exist\n     */\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) external view returns (bool);\n}\n"
    },
    "src/solc_0.8/OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {IOperatorFilterRegistry} from \"../../interfaces/IOperatorFilterRegistry.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n///@title OperatorFiltererUpgradeable\n///@author The Sandbox\n///@notice This contract would subscibe or copy or just to the subscription provided or just register to default subscription list\n///@dev This contract is the upgradeable version of the OpenSea implementation https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/OperatorFilterer.sol and adapted to the 0.5.9 solidity version\nabstract contract OperatorFiltererUpgradeable is ContextUpgradeable {\n    IOperatorFilterRegistry public operatorFilterRegistry;\n\n    event ContractRegistered(address indexed subscriptionOrRegistrant, bool subscribe);\n\n    function __OperatorFilterer_init(address subscriptionOrRegistrantToCopy, bool subscribe) internal onlyInitializing {\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /**\n     * @notice Register this contract into the registry\n     * @param subscriptionOrRegistrantToCopy address to subscribe or copy entries from\n     * @param subscribe should it subscribe\n     */\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal {\n        if (address(operatorFilterRegistry).code.length > 0) {\n            if (!operatorFilterRegistry.isRegistered(address(this))) {\n                if (subscribe) {\n                    operatorFilterRegistry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    if (subscriptionOrRegistrantToCopy != address(0)) {\n                        operatorFilterRegistry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                    } else {\n                        operatorFilterRegistry.register(address(this));\n                    }\n                }\n            }\n        }\n        emit ContractRegistered(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    modifier onlyAllowedOperator(address from) virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            // Allow spending tokens from addresses with balance\n            // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n            // from an EOA.\n            if (from == _msgSender()) {\n                _;\n                return;\n            }\n            if (!operatorFilterRegistry.isOperatorAllowed(address(this), _msgSender())) {\n                revert(\"Operator Not Allowed\");\n            }\n        }\n        _;\n    }\n\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            if (!operatorFilterRegistry.isOperatorAllowed(address(this), operator)) {\n                revert(\"Operator Not Allowed\");\n            }\n        }\n        _;\n    }\n}\n"
    },
    "src/solc_0.8/OperatorFilterer/interfaces/IOperatorFilterRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/**\n * @title IOperatorFilterRegistry\n * @author OpenSea\n * @notice Interface of the operator filter registry\n * @dev This interface comes from OpenSea https://github.com/ProjectOpenSea/operator-filter-registry/blob/main/src/IOperatorFilterRegistry.sol and adapted to the 0.5.9 solidity version\n */\ninterface IOperatorFilterRegistry {\n    /**\n     * @notice Check if the operator is allowed for the given registrant\n     * @param registrant address of the registrant\n     * @param operator operator address to check\n     * @return is the operator allowed\n     */\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n    /**\n     * @notice Register a new address\n     * @param registrant address to register\n     */\n    function register(address registrant) external;\n\n    /**\n     * @notice Register a new address & subscribe to an address\n     * @param registrant address of the registrant\n     * @param subscription address where the registrant is subscribed to\n     */\n    function registerAndSubscribe(address registrant, address subscription) external;\n\n    /**\n     * @notice Register and copy entries of another registrant\n     * @param registrant address of the registrant\n     * @param registrantToCopy address to copy from\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice update the operator for a registrant\n     * @param registrant address of the registrant\n     * @param operator operator to be updated\n     * @param filtered is it filtered\n     */\n    function updateOperator(\n        address registrant,\n        address operator,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update operators for a registrant\n     * @param registrant address of the registrant\n     * @param operators addresses of the operators\n     * @param filtered is it filtered\n     */\n    function updateOperators(\n        address registrant,\n        address[] calldata operators,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update code hash\n     * @param registrant address of the registrant\n     * @param codehash code hash\n     * @param filtered is it filtered\n     */\n    function updateCodeHash(\n        address registrant,\n        bytes32 codehash,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Update code hashes\n     * @param registrant address of the registrant\n     * @param codeHashes code hashes\n     * @param filtered is it filtered\n     */\n    function updateCodeHashes(\n        address registrant,\n        bytes32[] calldata codeHashes,\n        bool filtered\n    ) external;\n\n    /**\n     * @notice Subscribe a registrant\n     * @param registrant address of the registrant\n     * @param registrantToSubscribe address to subscribe with\n     */\n    function subscribe(address registrant, address registrantToSubscribe) external;\n\n    /**\n     * @notice Unsubscribe a registrant\n     * @param registrant address of the registrant\n     * @param copyExistingEntries copy existing entries\n     */\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n    /**\n     * @notice Get the subscription of an address\n     * @param addr address to check\n     * @return registrant the registrant address\n     */\n    function subscriptionOf(address addr) external returns (address registrant);\n\n    /**\n     * @notice Get the subscribers of the registrant\n     * @param registrant address of the registrant\n     * @return the subscribers addresses\n     */\n    function subscribers(address registrant) external returns (address[] memory);\n\n    /**\n     * @notice Get a specific subscriber\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return the ith subscriber of the registrant\n     */\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Copy the entries of a registrant\n     * @param registrant address of the registrant\n     * @param registrantToCopy address to copy\n     */\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice Is a registrant filtered\n     * @param registrant address of the registrant\n     * @param operator operator address to check\n     * @return is it filtered\n     */\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n    /**\n     * @notice Is the code hash of an operator filtered\n     * @param registrant address of the registrant\n     * @param operatorWithCode operator address to check\n     * @return is it filtered\n     */\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n    /**\n     * @notice Is the code hash filtered\n     * @param registrant address of the registrant\n     * @param codeHash code hash\n     * @return is it filtered\n     */\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n    /**\n     * @notice Get the filtered operators\n     * @param addr address to check\n     * @return filtered operators\n     */\n    function filteredOperators(address addr) external returns (address[] memory);\n\n    /**\n     * @notice Get the filtered code hashes\n     * @param addr address to check\n     * @return filtered code hashes\n     */\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n    /**\n     * @notice Get a specific operator\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return address of the operator\n     */\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Get the ith filtered code hash\n     * @param registrant address of the registrant\n     * @param index index to check\n     * @return the code hash\n     */\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n    /**\n     * @notice Is the address registered\n     * @param addr address to check\n     * @return is it registered\n     */\n    function isRegistered(address addr) external returns (bool);\n\n    /**\n     * @notice Get the code hash for this address\n     * @param addr address to check\n     * @return the code hash\n     */\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"../../../common/BaseWithStorage/ERC721BaseTokenV2.sol\";\nimport \"../../../common/interfaces/IPolygonLand.sol\";\n\n/**\n * @title PolygonLandBaseTokenV2\n * @author The Sandbox\n * @notice Implement LAND and quad functionalities on top of an ERC721 token\n * @dev This contract implements a quad tree structure to handle groups of ERC721 tokens at once\n */\nabstract contract PolygonLandBaseTokenV2 is IPolygonLand, Initializable, ERC721BaseTokenV2 {\n    using AddressUpgradeable for address;\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n\n    event Minter(address indexed minter, bool enabled);\n\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of bottom left x coordinates for each quad\n    /// @param ys list of bottom left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length, \"PolygonLandBaseTokenV2: sizes's and x's length are different\");\n        require(xs.length == ys.length, \"PolygonLandBaseTokenV2: x's and y's length are different\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(_msgSender(), from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to transfer tokens of all (minter rights).\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external onlyAdmin {\n        require(minter != address(0), \"PolygonLand: Invalid address\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data for transfer\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(_msgSender(), from, to, size, x, y, data);\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param user The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external virtual override {\n        _isValidQuad(size, x, y);\n        require(isMinter(_msgSender()), \"!AUTHORIZED\");\n        _mintQuad(user, size, x, y, data);\n    }\n\n    /**\n     * @notice Checks if a parent quad has child quads already minted.\n     *  Then mints the rest child quads and transfers the parent quad.\n     *  Should only be called by the tunnel.\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external virtual {\n        require(isMinter(msg.sender), \"!AUTHORIZED\");\n        require(to != address(0), \"to is zero address\");\n\n        if (exists(size, x, y)) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external pure returns (uint256) {\n        return _getX(id);\n    }\n\n    /// @inheritdoc ERC721BaseTokenV2\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public virtual override(ILandToken, ERC721BaseTokenV2) {\n        super.batchTransferFrom(from, to, ids, data);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external pure returns (uint256) {\n        return _getY(id);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() public pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size size of the\n    /// @param x x coordinate of the quad\n    /// @param y y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view override returns (bool) {\n        _isValidQuad(size, x, y);\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() public pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\"https://api.sandbox.game/lands/\", StringsUpgradeable.toString(id), \"/metadata.json\")\n            );\n    }\n\n    function _isValidQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure {\n        require(size == 1 || size == 3 || size == 6 || size == 12 || size == 24, \"Invalid size\");\n        require(x % size == 0, \"Invalid x coordinate\");\n        require(y % size == 0, \"Invalid y coordinate\");\n        require(x <= GRID_SIZE - size, \"x out of bounds\");\n        require(y <= GRID_SIZE - size, \"y out of bounds\");\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        _isValidQuad(size, x, y);\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(uint160(address(to)));\n        } else {\n            _regroupQuad(from, to, Land({x: x, y: y, size: size}), true, size / 2);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"to is zero address\");\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkOwner(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            require(_owners[_id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, _id);\n        }\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n\n    /**\n     * @dev checks if the child quads in the parent quad (size, x, y) are owned by msg.sender.\n     * It recursively checks child quad of every size(exculding Lands of 1x1 size) are minted or not.\n     * Quad which are minted are pushed into quadMinted to also check if every Land of size 1x1 in\n     * the parent quad is minted or not. While checking if the every child Quad and Land is minted it\n     * also checks and clear the owner for quads which are minted. Finally it checks if the new owner\n     * if is a contract can handle ERC721 tokens or not and transfers the parent quad to new owner.\n     * @param to The address to which the ownership of the quad will be transferred\n     * @param size The size of the quad being minted and transfered\n     * @param x The x-coordinate of the top-left corner of the quad being minted.\n     * @param y The y-coordinate of the top-left corner of the quad being minted.\n     * @param y The y-coordinate of the top-left corner of the quad being minted.\n     */\n    function _mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have. Would be used to push the minted Quads.\n        Land[] memory quadMinted = new Land[](64);\n        // index of last minted quad pushed on quadMinted Array\n        uint256 index;\n        uint256 landMinted;\n\n        // if size of the Quad in land struct to be transfered is greater than 3 we check recursivly if the child quads are minted or not.\n        if (size > 3) {\n            (index, landMinted) = _checkAndClearOwner(\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        // Lopping around the Quad in land struct to generate ids of 1x1 land token and checking if they are owned by msg.sender\n        {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 _id = _idInPath(i, size, x, y);\n                // checking land with token id \"_id\" is in the quadMinted array.\n                bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n                if (isAlreadyMinted) {\n                    // if land is in the quadMinted array there just emitting transfer event\n                    emit Transfer(msg.sender, to, _id);\n                } else {\n                    if (address(uint160(_owners[_id])) == msg.sender) {\n                        if (_operators[_id] != address(0)) _operators[_id] = address(0);\n                        landMinted += 1;\n                        emit Transfer(msg.sender, to, _id);\n                    } else {\n                        // else is checked if owned by the msg.sender or not. If it is not owned by msg.sender it should not have an owner.\n                        require(_owners[_id] == 0, \"Already minted\");\n\n                        emit Transfer(address(0), to, _id);\n                    }\n                }\n            }\n        }\n\n        // checking if the new owner \"to\" is a contract. If yes, checking if it could handle ERC721 tokens.\n        _checkBatchReceiverAcceptQuadAndClearOwner(quadMinted, index, landMinted, to, size, x, y, data);\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n        _numNFTPerAddress[msg.sender] -= landMinted;\n    }\n\n    /**\n     * @dev recursivly checks if the child quads are minted in land and push them to the quadMinted array.\n     * if a child quad is minted in land such quads child quads will be skipped such that there is no overlapping\n     * in quads which are minted. it clears the minted child quads owners.\n     * @param land the stuct which has the size x and y co-ordinate of Quad to be checked\n     * @param quadMinted array in which the minted child quad would be pushed\n     * @param landMinted total 1x1 land already minted\n     * @param index index of last element of quadMinted array\n     * @param quadCompareSize the size of the child quads to be checked.\n     * @return the index of last quad pushed in quadMinted array and the total land already minted\n     */\n    function _checkAndClearOwner(\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        //Lopping around the Quad in land struct to check if the child quad are minted or not\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                //checking if the child Quad is minted or not. i.e Checks if the quad is in the quadMinted array.\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                // if child quad is not already in the quadMinted array.\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = address(uint160(_owners[id]));\n                    // owner of the child quad is checked to be owned by msg.sender else should not be owned by anyone.\n                    if (owner == msg.sender) {\n                        // if child quad is minted it would be pushed in quadMinted array.\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        // index of quadMinted is increased\n                        index++;\n                        // total land minted is increase by the number if land of 1x1 in child quad\n                        landMinted += quadCompareSize * quadCompareSize;\n                        //owner is cleared\n                        _owners[id] = 0;\n                    } else {\n                        require(owner == address(0), \"Already minted\");\n                    }\n                }\n            }\n        }\n\n        // size of the child quad is set to be the next smaller child quad size (12 => 6 => 3)\n        quadCompareSize = quadCompareSize / 2;\n        // if child quad size is greater than 3 _checkAndClearOwner is checked for new child quads in the  quad in land struct.\n        if (quadCompareSize >= 3)\n            (index, landMinted) = _checkAndClearOwner(land, quadMinted, landMinted, index, quadCompareSize);\n        return (index, landMinted);\n    }\n\n    /// @dev checks the owner of land with 'tokenId' to be 'from' and clears it\n    /// @param from the address to be checked agains the owner of the land\n    /// @param tokenId th id of land\n    /// @return bool for if land is owned by 'from' or not.\n    function _checkAndClearLandOwner(address from, uint256 tokenId) internal returns (bool) {\n        uint256 currentOwner = _owners[tokenId];\n        if (currentOwner != 0) {\n            require((currentOwner & BURNED_FLAG) != BURNED_FLAG, \"not owner\");\n            require(address(uint160(currentOwner)) == from, \"not owner\");\n            _owners[tokenId] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    /// @dev checks if the receiver of the quad(size, x, y) is a contact. If yes can it handle ERC721 tokens. It also clears owner of 1x1 land's owned by msg.sender.\n    /// @param quadMinted - an array of Land structs in which the minted child quad or Quad to be transfered are.\n    /// @param landMinted - the total amount of land that has been minted\n    /// @param index - the index of the last element in the quadMinted array\n    /// @param to the address of the new owner of Quad to be transfered\n    /// @param size The size of the quad being minted and transfered\n    /// @param x The x-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    /// @param y The y-coordinate of the top-left corner of the quad being minted.\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        // checks if to is a contract and supports ERC721_MANDATORY_RECEIVER interfaces. if it doesn't it just clears the owner of 1x1 lands in quad(size, x, y)\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            // array to push minted 1x1 land\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            // index of last land pushed in idsToTransfer array\n            uint256 transferIndex;\n            // array to push ids to be minted\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            // index of last land pushed in idsToMint array\n            uint256 mintIndex;\n\n            // iterating over every 1x1 land in the quad to be pushed in the above arrays\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    // if land is in the quads already minted it just pushed in to the idsToTransfer array\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (address(uint160(_owners[id])) == msg.sender) {\n                    // if it is owned by the msg.sender owner data is removed and it is pused in to idsToTransfer array\n                    _owners[id] = 0;\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    // else it is not owned by any one and and pushed in teh idsToMint array\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n\n            // checking if \"to\" contact can handle ERC721 tokens\n            require(\n                _checkOnERC721BatchReceived(msg.sender, address(0), to, idsToMint, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n            require(\n                _checkOnERC721BatchReceived(msg.sender, msg.sender, to, idsToTransfer, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        } else {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n                if (address(uint160(_owners[id])) == msg.sender) _owners[id] = 0;\n            }\n        }\n    }\n\n    function _getX(uint256 id) internal pure returns (uint256) {\n        return (id & ~LAYER) % GRID_SIZE;\n    }\n\n    function _getY(uint256 id) internal pure returns (uint256) {\n        return (id & ~LAYER) / GRID_SIZE;\n    }\n\n    function _isQuadMinted(\n        Land[] memory mintedLand,\n        Land memory quad,\n        uint256 index\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < index; i++) {\n            Land memory land = mintedLand[i];\n            if (\n                land.size > quad.size &&\n                quad.x >= land.x &&\n                quad.x < land.x + land.size &&\n                quad.y >= land.y &&\n                quad.y < land.y + land.size\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _getQuadLayer(uint256 size)\n        internal\n        pure\n        returns (\n            uint256 layer,\n            uint256 parentSize,\n            uint256 childLayer\n        )\n    {\n        if (size == 1) {\n            layer = LAYER_1x1;\n            parentSize = 3;\n        } else if (size == 3) {\n            layer = LAYER_3x3;\n            parentSize = 6;\n        } else if (size == 6) {\n            layer = LAYER_6x6;\n            parentSize = 12;\n            childLayer = LAYER_3x3;\n        } else if (size == 12) {\n            layer = LAYER_12x12;\n            parentSize = 24;\n            childLayer = LAYER_6x6;\n        } else if (size == 24) {\n            layer = LAYER_24x24;\n            childLayer = LAYER_12x12;\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _getQuadId(\n        uint256 layer,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        return layer + x + y * GRID_SIZE;\n    }\n\n    function _checkOwner(\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        uint256 quadCompareSize\n    ) internal view {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n\n        if (size <= quadCompareSize) {\n            // when the size of the quad is smaller than the quadCompareSize(size to be compared with),\n            // then it is checked if the bigger quad which encapsulates the quad to be minted\n            // of with size equals the quadCompareSize has been minted or not\n            require(\n                _owners[\n                    _getQuadId(layer, (x / quadCompareSize) * quadCompareSize, (y / quadCompareSize) * quadCompareSize)\n                ] == 0,\n                \"Already minted\"\n            );\n        } else {\n            // when the size is smaller than the quadCompare size the owner of all the smaller quads with size\n            // quadCompare size in the quad to be minted are checked if they are minted or not\n            uint256 toX = x + size;\n            uint256 toY = y + size;\n            for (uint256 xi = x; xi < toX; xi += quadCompareSize) {\n                for (uint256 yi = y; yi < toY; yi += quadCompareSize) {\n                    require(_owners[_getQuadId(layer, xi, yi)] == 0, \"Already minted\");\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3) _checkOwner(size, x, y, quadCompareSize);\n    }\n\n    function _idInPath(\n        uint256 i,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        uint256 row = i / size;\n        if (row % 2 == 0) {\n            // allow ids to follow a path in a quad\n            return _getQuadId(LAYER_1x1, (x + (i % size)), (y + row));\n        } else {\n            return _getQuadId(LAYER_1x1, (x + size) - (1 + (i % size)), (y + row));\n        }\n    }\n\n    /// @dev checks if the Land's child quads are owned by the from address and clears all the previous owners\n    /// if all the child quads are not owned by the \"from\" address then the owner of parent quad to the land\n    /// is checked if owned by the \"from\" address. If from is the owner then land owner is set to \"to\" address\n    /// @param from address of the previous owner\n    /// @param to address of the new owner\n    /// @param land the quad to be regrouped and transferred\n    /// @param set for setting the new owner\n    /// @param childQuadSize  size of the child quad to be checked for owner in the regrouping\n    function _regroupQuad(\n        address from,\n        address to,\n        Land memory land,\n        bool set,\n        uint256 childQuadSize\n    ) internal returns (bool) {\n        (uint256 layer, , uint256 childLayer) = _getQuadLayer(land.size);\n        uint256 quadId = _getQuadId(layer, land.x, land.y);\n        bool ownerOfAll = true;\n\n        {\n            // double for loop iterates and checks owner of all the smaller quads in land\n            for (uint256 xi = land.x; xi < land.x + land.size; xi += childQuadSize) {\n                for (uint256 yi = land.y; yi < land.y + land.size; yi += childQuadSize) {\n                    uint256 ownerChild;\n                    bool ownAllIndividual;\n                    if (childQuadSize < 3) {\n                        // case when the smaller quad is 1x1,\n                        ownAllIndividual = _checkAndClearLandOwner(from, _getQuadId(LAYER_1x1, xi, yi)) && ownerOfAll;\n                    } else {\n                        // recursively calling the _regroupQuad function to check the owner of child quads.\n                        ownAllIndividual = _regroupQuad(\n                            from,\n                            to,\n                            Land({x: xi, y: yi, size: childQuadSize}),\n                            false,\n                            childQuadSize / 2\n                        );\n                        uint256 idChild = _getQuadId(childLayer, xi, yi);\n                        ownerChild = _owners[idChild];\n                        if (ownerChild != 0) {\n                            // checking the owner of child quad\n                            if (!ownAllIndividual) {\n                                require(ownerChild == uint256(uint160(from)), \"not owner of child Quad\");\n                            }\n                            // clearing owner of child quad\n                            _owners[idChild] = 0;\n                        }\n                    }\n                    // ownerOfAll should be true if \"from\" is owner of all the child quads itereated over\n                    ownerOfAll = (ownAllIndividual || ownerChild != 0) && ownerOfAll;\n                }\n            }\n        }\n\n        // if set is true it check if the \"from\" is owner of all else checks for the owner of parent quad is\n        // owned by \"from\" and sets the owner for the id of land to \"to\" address.\n        if (set) {\n            if (!ownerOfAll) {\n                require(_ownerOfQuad(land.size, land.x, land.y) == from, \"not owner of all sub quads nor parent quads\");\n            }\n            _owners[quadId] = uint256(uint160(to));\n            return true;\n        }\n\n        return ownerOfAll;\n    }\n\n    function _ownerOfQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal view returns (address) {\n        (uint256 layer, uint256 parentSize, ) = _getQuadLayer(size);\n        address owner = address(uint160(_owners[_getQuadId(layer, (x / size) * size, (y / size) * size)]));\n        if (owner != address(0)) {\n            return owner;\n        } else if (size < 24) {\n            return _ownerOfQuad(parentSize, x, y);\n        }\n        return address(0);\n    }\n\n    function _getQuadById(uint256 id)\n        internal\n        pure\n        returns (\n            uint256 size,\n            uint256 x,\n            uint256 y\n        )\n    {\n        x = _getX(id);\n        y = _getY(id);\n        uint256 layer = id & LAYER;\n        if (layer == LAYER_1x1) {\n            size = 1;\n        } else if (layer == LAYER_3x3) {\n            size = 3;\n        } else if (layer == LAYER_6x6) {\n            size = 6;\n        } else if (layer == LAYER_12x12) {\n            size = 12;\n        } else if (layer == LAYER_24x24) {\n            size = 24;\n        } else {\n            require(false, \"Invalid token id\");\n        }\n    }\n\n    function _ownerOf(uint256 id) internal view override returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        (uint256 size, uint256 x, uint256 y) = _getQuadById(id);\n        require(x % size == 0, \"x coordinate: Invalid token id\");\n        require(y % size == 0, \"y coordinate: Invalid token id\");\n        if (size == 1) {\n            uint256 owner1x1 = _owners[id];\n            return (owner1x1 & BURNED_FLAG) == BURNED_FLAG ? address(0) : _ownerOfQuad(size, x, y);\n        }\n        return _ownerOfQuad(size, x, y);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        override\n        returns (address owner, bool operatorEnabled)\n    {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if ((owner1x1 & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n            return (owner, operatorEnabled);\n        }\n\n        if (owner1x1 != 0) {\n            owner = address(uint160(owner1x1));\n            operatorEnabled = (owner1x1 & OPERATOR_FLAG) == OPERATOR_FLAG;\n        } else {\n            owner = _ownerOfQuad(3, (x * 3) / 3, (y * 3) / 3);\n            operatorEnabled = false;\n        }\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}\n"
    },
    "src/solc_0.8/polygon/child/land/PolygonLandV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./PolygonLandBaseTokenV2.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"../../../OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol\";\n\n/// @title LAND token on L2\ncontract PolygonLandV2 is PolygonLandBaseTokenV2, ERC2771Handler, OperatorFiltererUpgradeable {\n    using AddressUpgradeable for address;\n\n    event OperatorRegistrySet(address indexed registry);\n\n    function initialize(address trustedForwarder) external initializer {\n        _admin = _msgSender();\n        __ERC2771Handler_initialize(trustedForwarder);\n        emit AdminChanged(address(0), _admin);\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyAdmin {\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderSet(trustedForwarder);\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public override onlyAllowedOperatorApproval(operator) {\n        super.approveFor(sender, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) public override onlyAllowedOperatorApproval(operator) {\n        super.approve(operator, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override onlyAllowedOperator(from) {\n        super.transferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n        super.setApprovalForAll(operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public override onlyAllowedOperatorApproval(operator) {\n        super.setApprovalForAllFor(sender, operator, approved);\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.\n    /// @dev can only be called by admin.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription 'true' or to copy the list 'false'.\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAdmin {\n        require(subscriptionOrRegistrantToCopy != address(0), \"PolygonLandV2: subscription can't be zero address\");\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(address registry) external virtual onlyAdmin {\n        operatorFilterRegistry = IOperatorFilterRegistry(registry);\n        emit OperatorRegistrySet(registry);\n    }\n}\n"
    },
    "src/solc_0.8/test/MockLandV2WithMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\npragma solidity 0.8.2;\n\nimport \"../polygon/child/land/PolygonLandBaseTokenV2.sol\";\n\ncontract MockLandV2WithMint is PolygonLandBaseTokenV2 {\n    /** @notice Removed caller validations */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external override {\n        _mintQuad(user, size, x, y, data);\n    }\n\n    /** @notice Removed caller validations */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        require(to != address(0), \"to is zero address\");\n\n        if (exists(size, x, y)) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n}\n"
    },
    "src/solc_0.8/test/MockPolygonLandV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"../polygon/child/land/PolygonLandV2.sol\";\n\ncontract MockPolygonLandV2 is PolygonLandV2 {\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(address registry) external override {\n        operatorFilterRegistry = IOperatorFilterRegistry(registry);\n    }\n\n    /// @notice sets Approvals with operator filterer check in case to test the transfer.\n    /// @param operator address of the operator to be approved\n    /// @param approved bool value denoting approved (true) or not Approved(false)\n    function setApprovalForAllWithOutFilter(address operator, bool approved) external {\n        super._setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @notice Mint a new quad without a minter (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param user The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external override {\n        _mintQuad(user, size, x, y, data);\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.can only be called by admin.\n    /// @dev used to register contract and subscribe to the subscriptionOrRegistrantToCopy's black list.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription \"true\"\" or to copy the list \"false\".\n    function registerFilterer(address subscriptionOrRegistrantToCopy, bool subscribe) external {\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}