//SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {EIP712Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
import {TokenIdUtils} from "./libraries/TokenIdUtils.sol";
import {AuthValidator} from "./AuthValidator.sol";
import {ERC2771Handler} from "./ERC2771Handler.sol";
import {IAsset} from "./interfaces/IAsset.sol";
import {IAssetReveal} from "./interfaces/IAssetReveal.sol";

/// @title AssetReveal
/// @author The Sandbox
/// @notice Contract for burning and revealing assets
contract AssetReveal is IAssetReveal, Initializable, ERC2771Handler, EIP712Upgradeable {
    using TokenIdUtils for uint256;
    IAsset private assetContract;
    AuthValidator private authValidator;

    // mapping of creator to asset id to asset's reveal nonce
    mapping(address => mapping(uint256 => uint16)) internal revealIds;

    // mapping for showing whether a revealHash has been used
    // revealHashes are generated by the TSB backend from reveal burn events and are used for reveal minting
    mapping(bytes32 => bool) internal revealHashesUsed;

    bytes32 public constant REVEAL_TYPEHASH =
        keccak256(
            "Reveal(address recipient,uint256 prevTokenId,uint256[] amounts,string[] metadataHashes,bytes32[] revealHashes)"
        );
    bytes32 public constant BATCH_REVEAL_TYPEHASH =
        keccak256(
            "BatchReveal(address recipient,uint256[] prevTokenIds,uint256[][] amounts,string[][] metadataHashes,bytes32[][] revealHashes)"
        );
    bytes32 public constant INSTANT_REVEAL_TYPEHASH =
        keccak256(
            "InstantReveal(address recipient,uint256 prevTokenId,uint256[] amounts,string[] metadataHashes,bytes32[] revealHashes)"
        );

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initialize the contract
    /// @param _assetContract The address of the asset contract
    /// @param _authValidator The address of the AuthValidator contract
    /// @param _forwarder The address of the forwarder contract
    function initialize(
        string memory _name,
        string memory _version,
        address _assetContract,
        address _authValidator,
        address _forwarder
    ) public initializer {
        assetContract = IAsset(_assetContract);
        authValidator = AuthValidator(_authValidator);
        __ERC2771Handler_initialize(_forwarder);
        __EIP712_init(_name, _version);
    }

    /// @notice Reveal an asset to view its abilities and enhancements
    /// @dev the reveal mechanism works through burning the asset and minting a new one with updated tokenId
    /// @param tokenId the tokenId of id idasset to reveal
    /// @param amount the amount of tokens to reveal
    function revealBurn(uint256 tokenId, uint256 amount) public {
        _burnAsset(tokenId, amount);
    }

    /// @notice Burn multiple assets to be able to reveal them later
    /// @dev Can be used to burn multiple copies of the same token id, each copy will be revealed separately
    /// @param tokenIds the tokenIds of the assets to burn
    /// @param amounts the amounts of the assets to burn
    function revealBatchBurn(uint256[] calldata tokenIds, uint256[] calldata amounts) external {
        require(tokenIds.length == amounts.length, "Invalid input");
        for (uint256 i = 0; i < tokenIds.length; i++) {
            _burnAsset(tokenIds[i], amounts[i]);
        }
    }

    /// @notice Reveal assets to view their abilities and enhancements
    /// @dev Can be used to reveal multiple copies of the same token id
    /// @param signature Signature created on the TSB backend containing REVEAL_TYPEHASH and associated data, must be signed by authorized signer
    /// @param prevTokenId The tokenId of the unrevealed asset
    /// @param amounts The amount of assets to reveal (length reflects the number of types of reveal tokens and must be equal to the length of revealHashes)
    /// @param metadataHashes The array of hashes for revealed asset metadata
    /// @param revealHashes A revealHash array providing a random bytes32 generated by the TSB backend for each new tokenId
    function revealMint(
        bytes memory signature,
        uint256 prevTokenId,
        uint256[] calldata amounts,
        string[] calldata metadataHashes,
        bytes32[] calldata revealHashes
    ) public {
        require(amounts.length == metadataHashes.length, "Invalid amounts");
        require(amounts.length == revealHashes.length, "Invalid revealHashes");
        require(
            authValidator.verify(
                signature,
                _hashReveal(_msgSender(), prevTokenId, amounts, metadataHashes, revealHashes)
            ),
            "Invalid revealMint signature"
        );
        _revealAsset(prevTokenId, metadataHashes, amounts, revealHashes);
    }

    /// @notice Mint multiple assets with revealed abilities and enhancements
    /// @dev Can be used to reveal multiple copies of the same token id
    /// @param signature Signatures created on the TSB backend containing REVEAL_TYPEHASH and associated data, must be signed by authorized signer
    /// @param prevTokenIds The tokenId of the unrevealed asset
    /// @param amounts The amount of assets to reveal (must be equal to the length of revealHashes)
    /// @param metadataHashes The array of hashes for asset metadata
    /// @param revealHashes Array of revealHash arrays providing random bytes32 generated by the TSB backend for each new tokenId
    function revealBatchMint(
        bytes calldata signature,
        uint256[] calldata prevTokenIds,
        uint256[][] calldata amounts,
        string[][] calldata metadataHashes,
        bytes32[][] calldata revealHashes
    ) public {
        require(prevTokenIds.length == amounts.length, "Invalid amounts");
        require(amounts.length == metadataHashes.length, "Invalid metadataHashes");
        require(prevTokenIds.length == revealHashes.length, "Invalid revealHashes");
        require(
            authValidator.verify(
                signature,
                _hashBatchReveal(_msgSender(), prevTokenIds, amounts, metadataHashes, revealHashes)
            ),
            "Invalid revealBatchMint signature"
        );
        for (uint256 i = 0; i < prevTokenIds.length; i++) {
            // require(revealHashesUsed[revealHashes[i]] == false, "Invalid revealHash");
            // revealHashesUsed[revealHashes[i]] = true;
            _revealAsset(prevTokenIds[i], metadataHashes[i], amounts[i], revealHashes[i]);
        }
    }

    /// @notice Reveal assets to view their abilities and enhancements and mint them in a single transaction
    /// @dev Should be used where it is not required to keep the metadata secret, e.g. mythical assets where users select their desired abilities and enhancements
    /// @param signature Signature created on the TSB backend containing INSTANT_REVEAL_TYPEHASH and associated data, must be signed by authorized signer
    /// @param prevTokenId The tokenId of the unrevealed asset
    /// @param burnAmount The amount of assets to burn
    /// @param amounts The amount of assets to reveal (sum must be equal to the burnAmount)
    /// @param metadataHashes The array of hashes for asset metadata
    /// @param revealHashes A revealHash array providing a random bytes32 generated by the TSB backend for each new tokenId
    function burnAndReveal(
        bytes memory signature,
        uint256 prevTokenId,
        uint256 burnAmount,
        uint256[] calldata amounts,
        string[] calldata metadataHashes,
        bytes32[] calldata revealHashes
    ) external {
        require(amounts.length == metadataHashes.length, "Invalid amounts");
        require(amounts.length == revealHashes.length, "Invalid revealHashes");
        require(
            authValidator.verify(
                signature,
                _hashInstantReveal(_msgSender(), prevTokenId, amounts, metadataHashes, revealHashes)
            ),
            "Invalid burnAndReveal signature"
        );
        _burnAsset(prevTokenId, burnAmount);
        _revealAsset(prevTokenId, metadataHashes, amounts, revealHashes);
    }

    /// @notice Generate new tokenIds for revealed assets and mint them
    /// @param prevTokenId The tokenId of the unrevealed asset
    /// @param metadataHashes The array of hashes for asset metadata
    /// @param amounts The array of amounts to mint
    function _revealAsset(
        uint256 prevTokenId,
        string[] calldata metadataHashes,
        uint256[] calldata amounts,
        bytes32[] calldata revealHashes
    ) internal {
        uint256[] memory newTokenIds = getRevealedTokenIds(metadataHashes, prevTokenId);
        for (uint256 i = 0; i < revealHashes.length; i++) {
            require(revealHashesUsed[revealHashes[i]] == false, "Invalid revealHash");
            revealHashesUsed[revealHashes[i]] = true;
        }
        if (newTokenIds.length == 1) {
            assetContract.mint(_msgSender(), newTokenIds[0], amounts[0], metadataHashes[0]);
        } else {
            assetContract.mintBatch(_msgSender(), newTokenIds, amounts, metadataHashes);
        }
        emit AssetRevealMint(_msgSender(), prevTokenId, amounts, newTokenIds, revealHashes);
    }

    /// @notice Burns an asset to be able to reveal it later
    /// @param tokenId the tokenId of the asset to burn
    /// @param amount the amount of the asset to burn
    function _burnAsset(uint256 tokenId, uint256 amount) internal {
        require(amount > 0, "Amount should be greater than 0");
        IAsset.AssetData memory data = tokenId.getData();
        require(!data.revealed, "Asset is already revealed");
        assetContract.burnFrom(_msgSender(), tokenId, amount);
        emit AssetRevealBurn(_msgSender(), tokenId, data.tier, amount);
    }

    /// @notice Creates a hash of the reveal data
    /// @param recipient The address of the recipient
    /// @param prevTokenId The unrevealed token id
    /// @param amounts The amount of tokens to mint
    /// @param metadataHashes The array of hashes for new asset metadata
    /// @param revealHashes The revealHashes used for revealing this particular prevTokenId (length corresponds to the new tokenIds)
    /// @return digest The hash of the reveal data
    function _hashInstantReveal(
        address recipient,
        uint256 prevTokenId,
        uint256[] calldata amounts,
        string[] calldata metadataHashes,
        bytes32[] calldata revealHashes
    ) internal view returns (bytes32 digest) {
        digest = _hashTypedDataV4(
            keccak256(
                abi.encode(
                    INSTANT_REVEAL_TYPEHASH,
                    recipient,
                    prevTokenId,
                    keccak256(abi.encodePacked(amounts)),
                    _encodeHashes(metadataHashes),
                    keccak256(abi.encodePacked(revealHashes))
                )
            )
        );
    }

    /// @notice Creates a hash of the reveal data
    /// @param recipient The intended recipient of the revealed token
    /// @param prevTokenId The previous token id
    /// @param amounts The amount of tokens to mint
    /// @param metadataHashes The array of hashes for new asset metadata
    /// @param revealHashes The revealHashes used for revealing this particular prevTokenId (length corresponds to the new tokenIds)
    /// @return digest The hash of the reveal data
    function _hashReveal(
        address recipient,
        uint256 prevTokenId,
        uint256[] calldata amounts,
        string[] calldata metadataHashes,
        bytes32[] calldata revealHashes
    ) internal view returns (bytes32 digest) {
        digest = _hashTypedDataV4(
            keccak256(
                abi.encode(
                    REVEAL_TYPEHASH,
                    recipient,
                    prevTokenId,
                    keccak256(abi.encodePacked(amounts)),
                    _encodeHashes(metadataHashes),
                    keccak256(abi.encodePacked(revealHashes))
                )
            )
        );
    }

    /// @notice Creates a hash of the reveal data
    /// @param recipient The intended recipient of the revealed tokens
    /// @param prevTokenIds The previous token id
    /// @param amounts The amounts of tokens to mint
    /// @param metadataHashes The arrays of hashes for new asset metadata
    /// @param revealHashes The revealHashes used for these prevTokenIds, (lengths corresponds to the new tokenIds)
    /// @return digest The hash of the reveal data
    function _hashBatchReveal(
        address recipient,
        uint256[] calldata prevTokenIds,
        uint256[][] calldata amounts,
        string[][] calldata metadataHashes,
        bytes32[][] calldata revealHashes
    ) internal view returns (bytes32 digest) {
        digest = _hashTypedDataV4(
            keccak256(
                abi.encode(
                    BATCH_REVEAL_TYPEHASH,
                    recipient,
                    keccak256(abi.encodePacked(prevTokenIds)),
                    _encodeBatchAmounts(amounts),
                    _encodeBatchHashes(metadataHashes),
                    _encodeBatchRevealHashes(revealHashes)
                )
            )
        );
    }

    /// @notice Encodes the hashes of the metadata for signature verification
    /// @param metadataHashes The hashes of the metadata
    /// @return encodedHashes The encoded hashes of the metadata
    function _encodeHashes(string[] memory metadataHashes) internal pure returns (bytes32) {
        bytes32[] memory encodedHashes = new bytes32[](metadataHashes.length);
        for (uint256 i = 0; i < metadataHashes.length; i++) {
            encodedHashes[i] = keccak256((abi.encodePacked(metadataHashes[i])));
        }
        return keccak256(abi.encodePacked(encodedHashes));
    }

    /// @notice Encodes the hashes of the metadata for signature verification
    /// @param metadataHashes The hashes of the metadata
    /// @return encodedHashes The encoded hashes of the metadata
    function _encodeBatchHashes(string[][] memory metadataHashes) internal pure returns (bytes32) {
        bytes32[] memory encodedHashes = new bytes32[](metadataHashes.length);
        for (uint256 i = 0; i < metadataHashes.length; i++) {
            encodedHashes[i] = _encodeHashes(metadataHashes[i]);
        }
        return keccak256(abi.encodePacked(encodedHashes));
    }

    /// @notice Encodes the hashes of the metadata for signature verification
    /// @param revealHashes The revealHashes
    /// @return encodedRevealHashes The encoded hashes of the metadata
    function _encodeBatchRevealHashes(bytes32[][] memory revealHashes) internal pure returns (bytes32) {
        bytes32[] memory encodedHashes = new bytes32[](revealHashes.length);
        for (uint256 i = 0; i < revealHashes.length; i++) {
            encodedHashes[i] = keccak256(abi.encodePacked(revealHashes[i]));
        }
        return keccak256(abi.encodePacked(encodedHashes));
    }

    /// @notice Encodes the amounts of the tokens for signature verification
    /// @param amounts The amounts of the tokens
    /// @return encodedAmounts The encoded amounts of the tokens
    function _encodeBatchAmounts(uint256[][] memory amounts) internal pure returns (bytes32) {
        bytes32[] memory encodedAmounts = new bytes32[](amounts.length);
        for (uint256 i = 0; i < amounts.length; i++) {
            encodedAmounts[i] = keccak256(abi.encodePacked(amounts[i]));
        }
        return keccak256(abi.encodePacked(encodedAmounts));
    }

    /// @notice Checks if each metadatahash has been used before to either get the tokenId that was already created for it or generate a new one if it hasn't
    /// @dev This function also validates that we're not trying to reveal a tokenId that has already been revealed
    /// @param metadataHashes The hashes of the metadata
    /// @param prevTokenId The previous token id from which the assets are revealed
    /// @return tokenIdArray The array of tokenIds to mint
    function getRevealedTokenIds(
        string[] calldata metadataHashes,
        uint256 prevTokenId
    ) internal returns (uint256[] memory) {
        IAsset.AssetData memory data = prevTokenId.getData();
        require(!data.revealed, "Asset: already revealed");
        uint256[] memory tokenIdArray = new uint256[](metadataHashes.length);
        for (uint256 i = 0; i < metadataHashes.length; i++) {
            uint256 tokenId = assetContract.getTokenIdByMetadataHash(metadataHashes[i]);
            if (tokenId != 0) {
                tokenIdArray[i] = tokenId;
                continue;
            } else {
                uint16 revealNonce = ++revealIds[data.creator][prevTokenId];
                tokenId = TokenIdUtils.generateTokenId(
                    data.creator,
                    data.tier,
                    data.creatorNonce,
                    revealNonce,
                    data.bridged
                );
            }
            tokenIdArray[i] = tokenId;
        }

        return tokenIdArray;
    }

    /// @notice Get the status of a revealHash
    /// @return Whether it has been used
    function revealHashUsed(bytes32 revealHash) external view returns (bool) {
        return revealHashesUsed[revealHash];
    }

    /// @notice Get the asset contract address
    /// @return The asset contract address
    function getAssetContract() external view returns (address) {
        return address(assetContract);
    }

    /// @notice Get the auth validator address
    /// @return The auth validator address
    function getAuthValidator() external view returns (address) {
        return address(authValidator);
    }
}
