{
  "language": "Solidity",
  "sources": {
    "src/solc_0.8/asset/AssetAttributesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"../catalyst/GemsCatalystsRegistry.sol\";\nimport \"../common/BaseWithStorage/WithAdmin.sol\";\nimport \"../common/BaseWithStorage/WithMinter.sol\";\nimport \"../common/BaseWithStorage/WithUpgrader.sol\";\n\n/// @notice Allows setting the gems and catalysts of an asset\ncontract AssetAttributesRegistry is WithMinter, WithUpgrader, IAssetAttributesRegistry, Context {\n    uint256 internal constant MAX_NUM_GEMS = 15;\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    uint256 private constant NOT_IS_NFT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 private constant NOT_NFT_INDEX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF800000007FFFFFFFFFFFFFFF;\n\n    GemsCatalystsRegistry internal immutable _gemsCatalystsRegistry;\n    mapping(uint256 => Record) internal _records;\n\n    // used to allow migration to specify blockNumber when setting catalyst/gems\n    address public migrationContract;\n    // used to to set catalyst without burning actual ERC20 (cross layer deposit)\n    address public overLayerDepositor;\n\n    struct Record {\n        uint16 catalystId; // start at 1\n        uint16[MAX_NUM_GEMS] gemIds;\n    }\n\n    event CatalystApplied(uint256 indexed assetId, uint16 indexed catalystId, uint16[] gemIds, uint64 blockNumber);\n    event GemsAdded(uint256 indexed assetId, uint16[] gemIds, uint64 blockNumber);\n\n    /// @notice AssetAttributesRegistry depends on\n    /// @param gemsCatalystsRegistry: GemsCatalystsRegistry for fetching attributes\n    /// @param admin: for setting the migration contract address\n    /// @param minter: allowed to set gems and catalysts for a given asset\n    constructor(\n        GemsCatalystsRegistry gemsCatalystsRegistry,\n        address admin,\n        address minter,\n        address upgrader\n    ) {\n        _gemsCatalystsRegistry = gemsCatalystsRegistry;\n        _admin = admin;\n        _minter = minter;\n        _upgrader = upgrader;\n    }\n\n    function getCatalystRegistry() external view override returns (address) {\n        return address(_gemsCatalystsRegistry);\n    }\n\n    /// @notice get the record data (catalyst id, gems ids list) for an asset id\n    /// @param assetId id of the asset\n    function getRecord(uint256 assetId)\n        external\n        view\n        override\n        returns (\n            bool exists,\n            uint16 catalystId,\n            uint16[] memory gemIds\n        )\n    {\n        catalystId = _records[assetId].catalystId;\n        if (catalystId == 0 && assetId & IS_NFT != 0) {\n            // fallback on collection catalyst\n            assetId = _getCollectionId(assetId);\n            catalystId = _records[assetId].catalystId;\n        }\n        uint16[MAX_NUM_GEMS] memory fixedGemIds = _records[assetId].gemIds;\n        exists = catalystId != 0;\n        gemIds = new uint16[](MAX_NUM_GEMS);\n        uint8 i = 0;\n        while (fixedGemIds[i] != 0) {\n            gemIds[i] = (fixedGemIds[i]);\n            i++;\n        }\n    }\n\n    /// @notice getAttributes\n    /// @param assetId id of the asset\n    /// @return values The array of values(256) requested.\n    function getAttributes(uint256 assetId, GemEvent[] calldata events)\n        external\n        view\n        override\n        returns (uint32[] memory values)\n    {\n        return _gemsCatalystsRegistry.getAttributes(_records[assetId].catalystId, assetId, events);\n    }\n\n    /// @notice sets the catalyst and gems when an asset goes over layers\n    /// @param assetId id of the asset\n    /// @param catalystId id of the catalyst to set\n    /// @param gemIds list of gems ids to set\n    function setCatalystWhenDepositOnOtherLayer(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external override {\n        require(\n            _msgSender() == overLayerDepositor || _msgSender() == _admin,\n            \"AssetAttributesRegistry: not overLayerDepositor\"\n        );\n        // We have to ignore all 0 gemid in case of L2 to L1 deposit\n        // In this case we get gems data in a form of an array of MAX_NUM_GEMS padded with 0\n        if (gemIds.length == MAX_NUM_GEMS) {\n            uint256 firstZeroIndex;\n            for (firstZeroIndex = 0; firstZeroIndex < gemIds.length; firstZeroIndex++) {\n                if (gemIds[firstZeroIndex] == 0) {\n                    break;\n                }\n            }\n            uint16[] memory gemIdsWithoutZero = new uint16[](firstZeroIndex);\n            // find first 0\n            for (uint256 i = 0; i < firstZeroIndex; i++) {\n                gemIdsWithoutZero[i] = gemIds[i];\n            }\n            _setCatalyst(assetId, catalystId, gemIdsWithoutZero, _getBlockNumber(), false);\n        } else {\n            _setCatalyst(assetId, catalystId, gemIds, _getBlockNumber(), false);\n        }\n    }\n\n    /// @notice sets the catalyst and gems for an asset, minter only\n    /// @param assetId id of the asset\n    /// @param catalystId id of the catalyst to set\n    /// @param gemIds list of gems ids to set\n    function setCatalyst(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external virtual override {\n        require(_msgSender() == _minter || _msgSender() == _upgrader, \"NOT_AUTHORIZED_MINTER\");\n        _setCatalyst(assetId, catalystId, gemIds, _getBlockNumber(), true);\n    }\n\n    /// @notice sets the catalyst and gems for an asset for a given block number, migration contract only\n    /// @param assetId id of the asset\n    /// @param catalystId id of the catalyst to set\n    /// @param gemIds list of gems ids to set\n    /// @param blockNumber block number\n    function setCatalystWithBlockNumber(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        uint64 blockNumber\n    ) external override {\n        require(_msgSender() == migrationContract, \"NOT_AUTHORIZED_MIGRATION\");\n        _setCatalyst(assetId, catalystId, gemIds, blockNumber, true);\n    }\n\n    /// @notice adds gems to an existing list of gems of an asset, upgrader only\n    /// @param assetId id of the asset\n    /// @param gemIds list of gems ids to set\n    function addGems(uint256 assetId, uint16[] calldata gemIds) external virtual override {\n        require(_msgSender() == _upgrader, \"NOT_AUTHORIZED_UPGRADER\");\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\");\n        require(gemIds.length != 0, \"INVALID_GEMS_0\");\n\n        uint16 catalystId = _records[assetId].catalystId;\n        uint16[MAX_NUM_GEMS] memory gemIdsToStore;\n        if (catalystId == 0) {\n            // fallback on collection catalyst\n            uint256 collectionId = _getCollectionId(assetId);\n            catalystId = _records[collectionId].catalystId;\n            if (catalystId != 0) {\n                _records[assetId].catalystId = catalystId;\n                gemIdsToStore = _records[collectionId].gemIds;\n            }\n        } else {\n            gemIdsToStore = _records[assetId].gemIds;\n        }\n\n        require(catalystId != 0, \"NO_CATALYST_SET\");\n        uint8 j = 0;\n        uint8 i = 0;\n        for (i = 0; i < MAX_NUM_GEMS; i++) {\n            if (j == gemIds.length) {\n                break;\n            }\n            if (gemIdsToStore[i] == 0) {\n                require(gemIds[j] != 0, \"INVALID_GEM_ID\");\n                gemIdsToStore[i] = gemIds[j];\n                j++;\n            }\n        }\n        uint8 maxGems = _gemsCatalystsRegistry.getMaxGems(catalystId);\n        require(i <= maxGems, \"GEMS_TOO_MANY\");\n        _records[assetId].gemIds = gemIdsToStore;\n        uint64 blockNumber = _getBlockNumber();\n        emit GemsAdded(assetId, gemIds, blockNumber);\n    }\n\n    /// @notice set the migratcion contract address, admin or migration contract only\n    /// @param _migrationContract address of the migration contract\n    function setMigrationContract(address _migrationContract) external override {\n        address currentMigrationContract = migrationContract;\n        if (currentMigrationContract == address(0)) {\n            require(_msgSender() == _admin, \"NOT_AUTHORIZED\");\n            migrationContract = _migrationContract;\n        } else {\n            require(_msgSender() == currentMigrationContract, \"NOT_AUTHORIZED_MIGRATION\");\n            migrationContract = _migrationContract;\n        }\n    }\n\n    function setOverLayerDepositor(address overLayerDepositor_) external {\n        require(_msgSender() == _admin, \"NOT_AUTHORIZED\");\n        overLayerDepositor = overLayerDepositor_;\n    }\n\n    /// @dev Set a catalyst for the given asset.\n    /// @param assetId The asset to set a catalyst on.\n    /// @param catalystId The catalyst to set.\n    /// @param gemIds The gems to embed in the catalyst.\n    /// @param blockNumber The blocknumber to emit in the event.\n    /// @param hasToEmitEvent boolean to indicate if we want to emit an event\n    function _setCatalyst(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] memory gemIds,\n        uint64 blockNumber,\n        bool hasToEmitEvent\n    ) internal virtual {\n        require(gemIds.length <= MAX_NUM_GEMS, \"GEMS_MAX_REACHED\");\n        uint8 maxGems = _gemsCatalystsRegistry.getMaxGems(catalystId);\n        require(gemIds.length <= maxGems, \"GEMS_TOO_MANY\");\n        uint16[MAX_NUM_GEMS] memory gemIdsToStore;\n        for (uint8 i = 0; i < gemIds.length; i++) {\n            require(gemIds[i] != 0, \"INVALID_GEM_ID\");\n            gemIdsToStore[i] = gemIds[i];\n        }\n        _records[assetId] = Record(catalystId, gemIdsToStore);\n        if (hasToEmitEvent) {\n            emit CatalystApplied(assetId, catalystId, gemIds, blockNumber);\n        }\n    }\n\n    /// @dev Get the collection Id for an asset.\n    /// @param assetId The asset to get the collection id for.\n    /// @return The id of the collection the asset belongs to.\n    function _getCollectionId(uint256 assetId) internal pure returns (uint256) {\n        return assetId & NOT_NFT_INDEX & NOT_IS_NFT; // compute the same as Asset to get collectionId\n    }\n\n    /// @dev Get a blocknumber for use when querying attributes.\n    /// @return blockNumber The current blocknumber + 1.\n    function _getBlockNumber() internal view returns (uint64 blockNumber) {\n        blockNumber = uint64(block.number + 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/GemsCatalystsRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"./Gem.sol\";\nimport \"./Catalyst.sol\";\nimport \"./interfaces/IGemsCatalystsRegistry.sol\";\nimport \"../common/BaseWithStorage/WithSuperOperators.sol\";\nimport \"../common/BaseWithStorage/ERC2771Handler.sol\";\n\n/// @notice Contract managing the Gems and Catalysts\n/// Each Gems and Catalyst must be registered here.\n/// Each new Gem get assigned a new id (starting at 1)\n/// Each new Catalyst get assigned a new id (starting at 1)\ncontract GemsCatalystsRegistry is WithSuperOperators, ERC2771Handler, IGemsCatalystsRegistry, Ownable {\n    Gem[] internal _gems;\n    Catalyst[] internal _catalysts;\n\n    constructor(address admin, address trustedForwarder) {\n        _admin = admin;\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @notice Returns the values for each gem included in a given asset.\n    /// @param catalystId The catalyst identifier.\n    /// @param assetId The asset tokenId.\n    /// @param events An array of GemEvents. Be aware that only gemEvents from the last CatalystApplied event onwards should be used to populate a query. If gemEvents from multiple CatalystApplied events are included the output values will be incorrect.\n    /// @return values An array of values for each gem present in the asset.\n    function getAttributes(\n        uint16 catalystId,\n        uint256 assetId,\n        IAssetAttributesRegistry.GemEvent[] calldata events\n    ) external view override returns (uint32[] memory values) {\n        Catalyst catalyst = getCatalyst(catalystId);\n        require(catalyst != Catalyst(address(0)), \"CATALYST_DOES_NOT_EXIST\");\n        return catalyst.getAttributes(assetId, events);\n    }\n\n    /// @notice Returns the maximum number of gems for a given catalyst\n    /// @param catalystId catalyst identifier\n    function getMaxGems(uint16 catalystId) external view override returns (uint8) {\n        Catalyst catalyst = getCatalyst(catalystId);\n        require(catalyst != Catalyst(address(0)), \"CATALYST_DOES_NOT_EXIST\");\n        return catalyst.getMaxGems();\n    }\n\n    /// @notice Burns one gem unit from each gem id on behalf of a beneficiary\n    /// @param from address of the beneficiary to burn on behalf of\n    /// @param gemIds list of gems to burn one gem from each\n    /// @param amount amount units to burn\n    function burnDifferentGems(\n        address from,\n        uint16[] calldata gemIds,\n        uint256 amount\n    ) external override {\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            burnGem(from, gemIds[i], amount);\n        }\n    }\n\n    /// @notice Burns one catalyst unit from each catalyst id on behalf of a beneficiary\n    /// @param from address of the beneficiary to burn on behalf of\n    /// @param catalystIds list of catalysts to burn one catalyst from each\n    /// @param amount amount to burn\n    function burnDifferentCatalysts(\n        address from,\n        uint16[] calldata catalystIds,\n        uint256 amount\n    ) external override {\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            burnCatalyst(from, catalystIds[i], amount);\n        }\n    }\n\n    /// @notice Burns few gem units from each gem id on behalf of a beneficiary\n    /// @param from address of the beneficiary to burn on behalf of\n    /// @param gemIds list of gems to burn gem units from each\n    /// @param amounts list of amounts of units to burn\n    function batchBurnGems(\n        address from,\n        uint16[] calldata gemIds,\n        uint256[] calldata amounts\n    ) public override {\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            if (gemIds[i] != 0 && amounts[i] != 0) {\n                burnGem(from, gemIds[i], amounts[i]);\n            }\n        }\n    }\n\n    /// @notice Burns few catalyst units from each catalyst id on behalf of a beneficiary\n    /// @param from address of the beneficiary to burn on behalf of\n    /// @param catalystIds list of catalysts to burn catalyst units from each\n    /// @param amounts list of amounts of units to burn\n    function batchBurnCatalysts(\n        address from,\n        uint16[] calldata catalystIds,\n        uint256[] calldata amounts\n    ) public override {\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            if (catalystIds[i] != 0 && amounts[i] != 0) {\n                burnCatalyst(from, catalystIds[i], amounts[i]);\n            }\n        }\n    }\n\n    /// @notice Adds both arrays of gems and catalysts to registry\n    /// @param gems array of gems to be added\n    /// @param catalysts array of catalysts to be added\n    function addGemsAndCatalysts(Gem[] calldata gems, Catalyst[] calldata catalysts) external override {\n        require(_msgSender() == _admin, \"NOT_AUTHORIZED\");\n        for (uint256 i = 0; i < gems.length; i++) {\n            Gem gem = gems[i];\n            uint16 gemId = gem.gemId();\n            require(gemId == _gems.length + 1, \"GEM_ID_NOT_IN_ORDER\");\n            _gems.push(gem);\n        }\n\n        for (uint256 i = 0; i < catalysts.length; i++) {\n            Catalyst catalyst = catalysts[i];\n            uint16 catalystId = catalyst.catalystId();\n            require(catalystId == _catalysts.length + 1, \"CATALYST_ID_NOT_IN_ORDER\");\n            _catalysts.push(catalyst);\n        }\n    }\n\n    /// @notice Query whether a given gem exists.\n    /// @param gemId The gem being queried.\n    /// @return Whether the gem exists.\n    function doesGemExist(uint16 gemId) external view override returns (bool) {\n        return getGem(gemId) != Gem(address(0));\n    }\n\n    /// @notice Query whether a giving catalyst exists.\n    /// @param catalystId The catalyst being queried.\n    /// @return Whether the catalyst exists.\n    function doesCatalystExist(uint16 catalystId) external view returns (bool) {\n        return getCatalyst(catalystId) != Catalyst(address(0));\n    }\n\n    /// @notice Burn a catalyst.\n    /// @param from The signing address for the tx.\n    /// @param catalystId The id of the catalyst to burn.\n    /// @param amount The number of catalyst tokens to burn.\n    function burnCatalyst(\n        address from,\n        uint16 catalystId,\n        uint256 amount\n    ) public override {\n        _checkAuthorization(from);\n        Catalyst catalyst = getCatalyst(catalystId);\n        require(catalyst != Catalyst(address(0)), \"CATALYST_DOES_NOT_EXIST\");\n        catalyst.burnFor(from, amount);\n    }\n\n    /// @notice Burn a gem.\n    /// @param from The signing address for the tx.\n    /// @param gemId The id of the gem to burn.\n    /// @param amount The number of gem tokens to burn.\n    function burnGem(\n        address from,\n        uint16 gemId,\n        uint256 amount\n    ) public override {\n        _checkAuthorization(from);\n        Gem gem = getGem(gemId);\n        require(gem != Gem(address(0)), \"GEM_DOES_NOT_EXIST\");\n        gem.burnFor(from, amount);\n    }\n\n    function getNumberOfCatalystContracts() external view returns (uint256 number) {\n        number = _catalysts.length;\n    }\n\n    function getNumberOfGemContracts() external view returns (uint256 number) {\n        number = _gems.length;\n    }\n\n    function setGemsandCatalystsMaxAllowance() external {\n        for (uint256 i = 0; i < _gems.length; i++) {\n            _gems[i].approveFor(_msgSender(), address(this), ~uint256(0));\n        }\n\n        for (uint256 i = 0; i < _catalysts.length; i++) {\n            _catalysts[i].approveFor(_msgSender(), address(this), ~uint256(0));\n        }\n    }\n\n    // //////////////////// INTERNALS ////////////////////\n\n    /// @dev Get the catalyst contract corresponding to the id.\n    /// @param catalystId The catalyst id to use to retrieve the contract.\n    /// @return The requested Catalyst contract.\n    function getCatalyst(uint16 catalystId) internal view returns (Catalyst) {\n        if (catalystId > 0 && catalystId <= _catalysts.length) {\n            return _catalysts[catalystId - 1];\n        } else {\n            return Catalyst(address(0));\n        }\n    }\n\n    /// @dev Get the gem contract corresponding to the id.\n    /// @param gemId The gem id to use to retrieve the contract.\n    /// @return The requested Gem contract.\n    function getGem(uint16 gemId) internal view returns (Gem) {\n        if (gemId > 0 && gemId <= _gems.length) {\n            return _gems[gemId - 1];\n        } else {\n            return Gem(address(0));\n        }\n    }\n\n    /// @dev verify that the caller is authorized for this function call.\n    /// @param from The original signer of the transaction.\n    function _checkAuthorization(address from) internal view {\n        require(_msgSender() == from || isSuperOperator(_msgSender()), \"AUTH_ACCESS_DENIED\");\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\ncontract WithAdmin {\n    address internal _admin;\n\n    /// @dev Emits when the contract administrator is changed.\n    /// @param oldAdmin The address of the previous administrator.\n    /// @param newAdmin The address of the new administrator.\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"ADMIN_ONLY\");\n        _;\n    }\n\n    /// @dev Get the current administrator of this contract.\n    /// @return The current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev Change the administrator to be `newAdmin`.\n    /// @param newAdmin The address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"ADMIN_ACCESS_DENIED\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithMinter.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./WithAdmin.sol\";\n\ncontract WithMinter is WithAdmin {\n    address internal _minter;\n\n    /// @dev Emits when the Minter address is changed\n    /// @param oldMinter The previous Minter address\n    /// @param newMinter The new Minter address\n    event MinterChanged(address oldMinter, address newMinter);\n\n    modifier onlyMinter() {\n        require(msg.sender == _minter, \"MINTER_ACCESS_DENIED\");\n        _;\n    }\n\n    /// @dev Get the current minter of this contract.\n    /// @return The current minter of this contract.\n    function getMinter() external view returns (address) {\n        return _minter;\n    }\n\n    /// @dev Change the minter to be `newMinter`.\n    /// @param newMinter The address of the new minter.\n    function changeMinter(address newMinter) external onlyAdmin() {\n        emit MinterChanged(_minter, newMinter);\n        _minter = newMinter;\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithUpgrader.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./WithAdmin.sol\";\n\ncontract WithUpgrader is WithAdmin {\n    address internal _upgrader;\n\n    /// @dev Emits when the Upgrader address is changed\n    /// @param oldUpgrader The previous Upgrader address\n    /// @param newUpgrader The new Upgrader address\n    event UpgraderChanged(address oldUpgrader, address newUpgrader);\n\n    modifier onlyUpgrader() {\n        require(msg.sender == _upgrader, \"UPGRADER_ACCESS_DENIED\");\n        _;\n    }\n\n    /// @dev Get the current upgrader of this contract.\n    /// @return The current upgrader of this contract.\n    function getUpgrader() external view returns (address) {\n        return _upgrader;\n    }\n\n    /// @dev Change the upgrader to be `newUpgrader`.\n    /// @param newUpgrader The address of the new upgrader.\n    function changeUpgrader(address newUpgrader) external onlyAdmin() {\n        emit UpgraderChanged(_upgrader, newUpgrader);\n        _upgrader = newUpgrader;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/Gem.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/ERC20Token.sol\";\n\ncontract Gem is ERC20Token {\n    uint16 public immutable gemId;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address admin,\n        uint16 _gemId,\n        address operator\n    ) ERC20Token(name, symbol, admin, operator) {\n        gemId = _gemId;\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/Catalyst.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"../common/BaseWithStorage/ERC20/ERC20Token.sol\";\nimport \"../common/interfaces/IAttributes.sol\";\n\ncontract Catalyst is ERC20Token, IAttributes {\n    uint16 public immutable catalystId;\n    uint8 internal immutable _maxGems;\n\n    IAttributes internal _attributes;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address admin,\n        uint8 maxGems,\n        uint16 _catalystId,\n        IAttributes attributes,\n        address operator\n    ) ERC20Token(name, symbol, admin, operator) {\n        _maxGems = maxGems;\n        catalystId = _catalystId;\n        _attributes = attributes;\n    }\n\n    /// @notice Used by Admin to update the attributes contract.\n    /// @param attributes The new attributes contract.\n    function changeAttributes(IAttributes attributes) external onlyAdmin {\n        _attributes = attributes;\n    }\n\n    /// @notice Get the value of _maxGems(the max number of gems that can be embeded in this type of catalyst).\n    /// @return The value of _maxGems.\n    function getMaxGems() external view returns (uint8) {\n        return _maxGems;\n    }\n\n    /// @notice Get the attributes for each gem in an asset.\n    /// See DefaultAttributes.getAttributes for more.\n    /// @return values An array of values representing the \"level\" of each gem. ie: Power=14, speed=45, etc...\n    function getAttributes(uint256 assetId, IAssetAttributesRegistry.GemEvent[] calldata events)\n        external\n        view\n        override\n        returns (uint32[] memory values)\n    {\n        return _attributes.getAttributes(assetId, events);\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/interfaces/IGemsCatalystsRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"../../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"../Gem.sol\";\nimport \"../Catalyst.sol\";\n\ninterface IGemsCatalystsRegistry {\n    function getAttributes(\n        uint16 catalystId,\n        uint256 assetId,\n        IAssetAttributesRegistry.GemEvent[] calldata events\n    ) external view returns (uint32[] memory values);\n\n    function getMaxGems(uint16 catalystId) external view returns (uint8);\n\n    function burnDifferentGems(\n        address from,\n        uint16[] calldata gemIds,\n        uint256 amount\n    ) external;\n\n    function burnDifferentCatalysts(\n        address from,\n        uint16[] calldata catalystIds,\n        uint256 amount\n    ) external;\n\n    function batchBurnGems(\n        address from,\n        uint16[] calldata gemIds,\n        uint256[] calldata amounts\n    ) external;\n\n    function batchBurnCatalysts(\n        address from,\n        uint16[] calldata catalystIds,\n        uint256[] calldata amounts\n    ) external;\n\n    function addGemsAndCatalysts(Gem[] calldata gems, Catalyst[] calldata catalysts) external;\n\n    function doesGemExist(uint16 gemId) external view returns (bool);\n\n    function burnCatalyst(\n        address from,\n        uint16 catalystId,\n        uint256 amount\n    ) external;\n\n    function burnGem(\n        address from,\n        uint16 gemId,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithSuperOperators.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./WithAdmin.sol\";\n\ncontract WithSuperOperators is WithAdmin {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/// @dev minimal ERC2771 handler to keep bytecode-size down.\n/// based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\n\ncontract ERC2771Handler {\n    address internal _trustedForwarder;\n\n    function __ERC2771Handler_initialize(address forwarder) internal {\n        _trustedForwarder = forwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function getTrustedForwarder() external view returns (address trustedForwarder) {\n        return _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC20/ERC20Token.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./ERC20BaseToken.sol\";\nimport \"./extensions/ERC20BasicApproveExtension.sol\";\nimport \"../WithPermit.sol\";\nimport \"../ERC677/extensions/ERC677Extension.sol\";\nimport \"../../interfaces/IERC677Receiver.sol\";\n\ncontract ERC20Token is ERC20BasicApproveExtension, ERC677Extension, WithPermit, ERC20BaseToken {\n    // /////////////////// CONSTRUCTOR ////////////////////\n    constructor(\n        string memory name,\n        string memory symbol,\n        address admin,\n        address operator\n    )\n        ERC20BaseToken(name, symbol, admin, operator) // solhint-disable-next-line no-empty-blocks\n    {}\n\n    function mint(address to, uint256 amount) external onlyAdmin {\n        _mint(to, amount);\n    }\n\n    /// @notice Function to permit the expenditure of ERC20 token by a nominated spender\n    /// @param owner The owner of the ERC20 tokens\n    /// @param spender The nominated spender of the ERC20 tokens\n    /// @param value The value (allowance) of the ERC20 tokens that the nominated spender will be allowed to spend\n    /// @param deadline The deadline for granting permission to the spender\n    /// @param v The final 1 byte of signature\n    /// @param r The first 32 bytes of signature\n    /// @param s The second 32 bytes of signature\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        checkApproveFor(owner, spender, value, deadline, v, r, s);\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC20/ERC20BaseToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"./extensions/ERC20Internal.sol\";\nimport \"../../interfaces/IERC20Extended.sol\";\nimport \"../WithSuperOperators.sol\";\n\nabstract contract ERC20BaseToken is WithSuperOperators, IERC20, IERC20Extended, ERC20Internal, Context {\n    string internal _name;\n    string internal _symbol;\n    address internal immutable _operator;\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address admin,\n        address operator\n    ) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _admin = admin;\n        _operator = operator;\n    }\n\n    /// @notice Transfer `amount` tokens to `to`.\n    /// @param to The recipient address of the tokens being transfered.\n    /// @param amount The number of tokens being transfered.\n    /// @return success Whether or not the transfer succeeded.\n    function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(_msgSender(), to, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `from` to `to`.\n    /// @param from The origin address  of the tokens being transferred.\n    /// @param to The recipient address of the tokensbeing  transfered.\n    /// @param amount The number of tokens transfered.\n    /// @return success Whether or not the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (_msgSender() != from && !_superOperators[_msgSender()] && _msgSender() != _operator) {\n            uint256 currentAllowance = _allowances[from][_msgSender()];\n            if (currentAllowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHORIZED_ALLOWANCE\");\n                _allowances[from][_msgSender()] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Burn `amount` tokens.\n    /// @param amount The number of tokens to burn.\n    function burn(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    /// @notice Burn `amount` tokens from `owner`.\n    /// @param from The address whose token to burn.\n    /// @param amount The number of tokens to burn.\n    function burnFor(address from, uint256 amount) external override {\n        _burn(from, amount);\n    }\n\n    /// @notice Approve `spender` to transfer `amount` tokens.\n    /// @param spender The address to be given rights to transfer.\n    /// @param amount The number of tokens allowed.\n    /// @return success Whether or not the call succeeded.\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        _approveFor(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /// @notice Get the name of the token collection.\n    /// @return The name of the token collection.\n    function name() external view virtual returns (string memory) {\n        //added virtual\n        return _name;\n    }\n\n    /// @notice Get the symbol for the token collection.\n    /// @return The symbol of the token collection.\n    function symbol() external view virtual returns (string memory) {\n        //added virtual\n        return _symbol;\n    }\n\n    /// @notice Get the total number of tokens in existence.\n    /// @return The total number of tokens in existence.\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Get the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    /// @notice Get the allowance of `spender` for `owner`'s tokens.\n    /// @param owner The address whose token is allowed.\n    /// @param spender The address allowed to transfer.\n    /// @return remaining The amount of token `spender` is allowed to transfer on behalf of `owner`.\n    function allowance(address owner, address spender) external view override returns (uint256 remaining) {\n        return _allowances[owner][spender];\n    }\n\n    /// @notice Get the number of decimals for the token collection.\n    /// @return The number of decimals.\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @notice Approve `spender` to transfer `amount` tokens from `owner`.\n    /// @param owner The address whose token is allowed.\n    /// @param spender The address to be given rights to transfer.\n    /// @param amount The number of tokens allowed.\n    /// @return success Whether or not the call succeeded.\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) public override returns (bool success) {\n        require(_msgSender() == owner || _superOperators[_msgSender()] || _msgSender() == _operator, \"NOT_AUTHORIZED\");\n        _approveFor(owner, spender, amount);\n        return true;\n    }\n\n    /// @notice Increase the allowance for the spender if needed\n    /// @param owner The address of the owner of the tokens\n    /// @param spender The address wanting to spend tokens\n    /// @param amountNeeded The amount requested to spend\n    /// @return success Whether or not the call succeeded.\n    function addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded\n    ) public returns (bool success) {\n        require(_msgSender() == owner || _superOperators[_msgSender()] || _msgSender() == _operator, \"INVALID_SENDER\");\n        _addAllowanceIfNeeded(owner, spender, amountNeeded);\n        return true;\n    }\n\n    /// @dev See addAllowanceIfNeeded.\n    function _addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded /*(ERC20Internal, ERC20ExecuteExtension, ERC20BasicApproveExtension)*/\n    ) internal virtual override {\n        if (amountNeeded > 0 && !isSuperOperator(spender) && spender != _operator) {\n            uint256 currentAllowance = _allowances[owner][spender];\n            if (currentAllowance < amountNeeded) {\n                _approveFor(owner, spender, amountNeeded);\n            }\n        }\n    }\n\n    /// @dev See approveFor.\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount /*(ERC20BasicApproveExtension, ERC20Internal)*/\n    ) internal virtual override {\n        require(owner != address(0) && spender != address(0), \"INVALID_OWNER_||_SPENDER\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /// @dev See transfer.\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount /*(ERC20Internal, ERC20ExecuteExtension)*/\n    ) internal virtual override {\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(to != address(this), \"NOT_TO_THIS\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"INSUFFICIENT_FUNDS\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    /// @dev Mint tokens for a recipient.\n    /// @param to The recipient address.\n    /// @param amount The number of token to mint.\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(amount > 0, \"MINT_O_TOKENS\");\n        uint256 currentTotalSupply = _totalSupply;\n        uint256 newTotalSupply = currentTotalSupply + amount;\n        require(newTotalSupply > currentTotalSupply, \"OVERFLOW\");\n        _totalSupply = newTotalSupply;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    /// @dev Burn tokens from an address.\n    /// @param from The address whose tokens to burn.\n    /// @param amount The number of token to burn.\n    function _burn(address from, uint256 amount) internal {\n        require(amount > 0, \"BURN_O_TOKENS\");\n        if (_msgSender() != from && !_superOperators[_msgSender()] && _msgSender() != _operator) {\n            uint256 currentAllowance = _allowances[from][_msgSender()];\n            if (currentAllowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"INSUFFICIENT_ALLOWANCE\");\n                _allowances[from][_msgSender()] = currentAllowance - amount;\n            }\n        }\n\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"INSUFFICIENT_FUNDS\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC20/extensions/ERC20BasicApproveExtension.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"./ERC20Internal.sol\";\nimport \"../../../Libraries/BytesUtil.sol\";\n\nabstract contract ERC20BasicApproveExtension is ERC20Internal, Context {\n    /// @notice Approve `target` to spend `amount` and call it with data.\n    /// @param target The address to be given rights to transfer and destination of the call.\n    /// @param amount The number of tokens allowed.\n    /// @param data The bytes for the call.\n    /// @return The data of the call.\n    function approveAndCall(\n        address target,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes memory) {\n        require(BytesUtil.doFirstParamEqualsAddress(data, _msgSender()), \"FIRST_PARAM_NOT_SENDER\");\n\n        _approveFor(_msgSender(), target, amount);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, string(returnData));\n        return returnData;\n    }\n\n    /// @notice Temporarily approve `target` to spend `amount` and call it with data.\n    /// Previous approvals remains unchanged.\n    /// @param target The destination of the call, allowed to spend the amount specified\n    /// @param amount The number of tokens allowed to spend.\n    /// @param data The bytes for the call.\n    /// @return The data of the call.\n    function paidCall(\n        address target,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes memory) {\n        require(BytesUtil.doFirstParamEqualsAddress(data, _msgSender()), \"FIRST_PARAM_NOT_SENDER\");\n\n        if (amount > 0) {\n            _addAllowanceIfNeeded(_msgSender(), target, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, string(returnData));\n\n        return returnData;\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/WithPermit.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../../common/interfaces/IERC20Extended.sol\";\nimport \"../../common/Base/TheSandbox712.sol\";\n\n/// @title Permit contract\n/// @notice This contract manages approvals of SAND via signature\nabstract contract WithPermit is TheSandbox712, IERC20Permit {\n    mapping(address => uint256) public _nonces;\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /// @notice Function to permit the expenditure of ERC20 token by a nominated spender\n    /// @param owner The owner of the ERC20 tokens\n    /// @param spender The nominated spender of the ERC20 tokens\n    /// @param value The value (allowance) of the ERC20 tokens that the nominated spender will be allowed to spend\n    /// @param deadline The deadline for granting permission to the spender\n    /// @param v The final 1 byte of signature\n    /// @param r The first 32 bytes of signature\n    /// @param s The second 32 bytes of signature\n    function checkApproveFor(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(deadline >= block.timestamp, \"PAST_DEADLINE\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    _DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _nonces[owner]++, deadline))\n                )\n            );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\n    }\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC677/extensions/ERC677Extension.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../../interfaces/IERC677.sol\";\nimport \"../../../interfaces/IERC677Receiver.sol\";\nimport \"../../ERC20/extensions/ERC20Internal.sol\";\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\n\nabstract contract ERC677Extension is ERC20Internal, IERC677 {\n    using Address for address;\n\n    /// @notice Transfers tokens to an address with _data if the recipient is a contact.\n    /// @param _to The address to transfer to.\n    /// @param _value The amount to be transferred.\n    /// @param _data The extra data to be passed to the receiving contract.\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external override returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        if (_to.isContract()) {\n            IERC677Receiver receiver = IERC677Receiver(_to);\n            receiver.onTokenTransfer(msg.sender, _value, _data);\n        }\n        return true;\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC677Receiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ninterface IERC677Receiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC20/extensions/ERC20Internal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nabstract contract ERC20Internal {\n    function _approveFor(\n        address owner,\n        address target,\n        uint256 amount\n    ) internal virtual;\n\n    function _addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual;\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Extended is IERC20 {\n    function burnFor(address from, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool success);\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20 {\n    /// @notice emitted when tokens are transfered from one address to another.\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\n    /// @param value amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice emitted when owner grant transfer rights to another address\n    /// @param owner address allowing its token to be transferred.\n    /// @param spender address allowed to spend on behalf of `owner`\n    /// @param value amount of tokens allowed.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice return the current total amount of tokens owned by all holders.\n    /// @return supply total number of tokens held.\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @notice return the number of tokens held by a particular address.\n    /// @param who address being queried.\n    /// @return balance number of token held by that address.\n    function balanceOf(address who) external view returns (uint256 balance);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    /// @notice approve an address to spend on your behalf.\n    /// @param spender address entitled to transfer on your behalf.\n    /// @param value amount allowed to be transfered.\n    /// @param success whether the approval succeeded.\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /// @notice return the current allowance for a particular owner/spender pair.\n    /// @param owner address allowing spender.\n    /// @param spender address allowed to spend.\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) external view returns (uint256 amount);\n}\n"
    },
    "src/solc_0.8/common/Libraries/BytesUtil.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nlibrary BytesUtil {\n    uint256 private constant DATA_MIN_LENGTH = 68;\n\n    /// @dev Check if the data == _address.\n    /// @param data The bytes passed to the function.\n    /// @param _address The address to compare to.\n    /// @return Whether the first param == _address.\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\n        if (data.length < DATA_MIN_LENGTH) {\n            return false;\n        }\n        uint256 value;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(uint160(_address));\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/solc_0.8/common/Base/TheSandbox712.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ncontract TheSandbox712 {\n    bytes32 internal constant EIP712DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\");\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public immutable _DOMAIN_SEPARATOR;\n\n    constructor() {\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(EIP712DOMAIN_TYPEHASH, keccak256(\"The Sandbox\"), keccak256(\"1\"), address(this))\n        );\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC677.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ninterface IERC677 {\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success);\n    //TODO: decide whether we use that event, as it collides with ERC20 Transfer event\n    //event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IAssetAttributesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\ninterface IAssetAttributesRegistry {\n    struct GemEvent {\n        uint16[] gemIds;\n        bytes32 blockHash;\n    }\n\n    struct AssetGemsCatalystData {\n        uint256 assetId;\n        uint16 catalystContractId;\n        uint16[] gemContractIds;\n    }\n\n    function getRecord(uint256 assetId)\n        external\n        view\n        returns (\n            bool exists,\n            uint16 catalystId,\n            uint16[] memory gemIds\n        );\n\n    function getAttributes(uint256 assetId, GemEvent[] calldata events) external view returns (uint32[] memory values);\n\n    function setCatalyst(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external;\n\n    function setCatalystWhenDepositOnOtherLayer(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external;\n\n    function setCatalystWithBlockNumber(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        uint64 blockNumber\n    ) external;\n\n    function addGems(uint256 assetId, uint16[] calldata gemIds) external;\n\n    function setMigrationContract(address _migrationContract) external;\n\n    function getCatalystRegistry() external view returns (address);\n}\n"
    },
    "src/solc_0.8/common/interfaces/IAttributes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IAssetAttributesRegistry.sol\";\n\ninterface IAttributes {\n    function getAttributes(uint256 assetId, IAssetAttributesRegistry.GemEvent[] calldata events)\n        external\n        view\n        returns (uint32[] memory values);\n}\n"
    },
    "src/solc_0.8/test/MockAssetAttributesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"../asset/AssetAttributesRegistry.sol\";\n\n/// @notice Allows setting the gems and catalysts of an asset\ncontract MockAssetAttributesRegistry is AssetAttributesRegistry {\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n\n    constructor(\n        GemsCatalystsRegistry gemsCatalystsRegistry,\n        address admin,\n        address minter,\n        address upgrader\n    )\n        AssetAttributesRegistry(gemsCatalystsRegistry, admin, minter, upgrader)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function setCatalyst(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external override {\n        // @note access control removed for testing\n        _setCatalyst(assetId, catalystId, gemIds, _getBlockNumber(), true);\n    }\n\n    function _setCatalyst(\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] memory gemIds,\n        uint64 blockNumber,\n        bool hasToEmitEvent\n    ) internal override {\n        // @note access control removed for testing\n        require(gemIds.length <= MAX_NUM_GEMS, \"GEMS_MAX_REACHED\");\n        uint8 maxGems = _gemsCatalystsRegistry.getMaxGems(catalystId);\n        require(gemIds.length <= maxGems, \"GEMS_TOO_MANY\");\n        uint16[MAX_NUM_GEMS] memory gemIdsToStore;\n        for (uint8 i = 0; i < gemIds.length; i++) {\n            require(gemIds[i] != 0, \"INVALID_GEM_ID\");\n            gemIdsToStore[i] = gemIds[i];\n        }\n        _records[assetId] = Record(catalystId, gemIdsToStore);\n        if (hasToEmitEvent) {\n            emit CatalystApplied(assetId, catalystId, gemIds, blockNumber);\n        }\n    }\n\n    function addGems(uint256 assetId, uint16[] calldata gemIds) external override {\n        // @note removed access control for ease of testing.\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\");\n        require(gemIds.length != 0, \"INVALID_GEMS_0\");\n\n        uint16 catalystId = _records[assetId].catalystId;\n        uint16[MAX_NUM_GEMS] memory gemIdsToStore;\n        if (catalystId == 0) {\n            // fallback on collection catalyst\n            uint256 collectionId = _getCollectionId(assetId);\n            catalystId = _records[collectionId].catalystId;\n            if (catalystId != 0) {\n                _records[assetId].catalystId = catalystId;\n                gemIdsToStore = _records[collectionId].gemIds;\n            }\n        } else {\n            gemIdsToStore = _records[assetId].gemIds;\n        }\n\n        require(catalystId != 0, \"NO_CATALYST_SET\");\n        uint8 j = 0;\n        uint8 i = 0;\n        for (i = 0; i < MAX_NUM_GEMS; i++) {\n            if (j == gemIds.length) {\n                break;\n            }\n            if (gemIdsToStore[i] == 0) {\n                require(gemIds[j] != 0, \"INVALID_GEM_ID\");\n                gemIdsToStore[i] = gemIds[j];\n                j++;\n            }\n        }\n        uint8 maxGems = _gemsCatalystsRegistry.getMaxGems(catalystId);\n        require(i <= maxGems, \"GEMS_TOO_MANY\");\n        _records[assetId].gemIds = gemIdsToStore;\n        uint64 blockNumber = _getBlockNumber();\n        emit GemsAdded(assetId, gemIds, blockNumber);\n    }\n}\n"
    },
    "src/solc_0.8/claims/MultiGiveaway/MultiGiveaway.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./ClaimERC1155ERC721ERC20.sol\";\nimport \"../../common/BaseWithStorage/WithAdmin.sol\";\n\n/// @title MultiGiveaway contract.\n/// @notice This contract manages claims for multiple token types.\ncontract MultiGiveaway is WithAdmin, ClaimERC1155ERC721ERC20 {\n    ///////////////////////////////  Data //////////////////////////////\n\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    mapping(address => mapping(bytes32 => bool)) public claimed;\n    mapping(bytes32 => uint256) internal _expiryTime;\n\n    ///////////////////////////////  Events //////////////////////////////\n\n    event NewGiveaway(bytes32 merkleRoot, uint256 expiryTime);\n\n    ///////////////////////////////  Constructor /////////////////////////\n\n    constructor(address admin) {\n        _admin = admin;\n    }\n\n    ///////////////////////////////  Functions ///////////////////////////\n\n    /// @notice Function to add a new giveaway.\n    /// @param merkleRoot The merkle root hash of the claim data.\n    /// @param expiryTime The expiry time for the giveaway.\n    function addNewGiveaway(bytes32 merkleRoot, uint256 expiryTime) external onlyAdmin {\n        _expiryTime[merkleRoot] = expiryTime;\n        emit NewGiveaway(merkleRoot, expiryTime);\n    }\n\n    /// @notice Function to check which giveaways have been claimed by a particular user.\n    /// @param user The user (intended token destination) address.\n    /// @param rootHashes The array of giveaway root hashes to check.\n    /// @return claimedGiveaways The array of bools confirming whether or not the giveaways relating to the root hashes provided have been claimed.\n    function getClaimedStatus(address user, bytes32[] calldata rootHashes) external view returns (bool[] memory) {\n        bool[] memory claimedGiveaways = new bool[](rootHashes.length);\n        for (uint256 i = 0; i < rootHashes.length; i++) {\n            claimedGiveaways[i] = claimed[user][rootHashes[i]];\n        }\n        return claimedGiveaways;\n    }\n\n    /// @notice Function to permit the claiming of multiple tokens from multiple giveaways to a reserved address.\n    /// @param claims The array of claim structs, each containing a destination address, the giveaway items to be claimed and an optional salt param.\n    /// @param proofs The proofs submitted for verification.\n    function claimMultipleTokensFromMultipleMerkleTree(\n        bytes32[] calldata rootHashes,\n        Claim[] memory claims,\n        bytes32[][] calldata proofs\n    ) external {\n        require(claims.length == rootHashes.length, \"INVALID_INPUT\");\n        require(claims.length == proofs.length, \"INVALID_INPUT\");\n        for (uint256 i = 0; i < rootHashes.length; i++) {\n            claimMultipleTokens(rootHashes[i], claims[i], proofs[i]);\n        }\n    }\n\n    /// @dev Public function used to perform validity checks and progress to claim multiple token types in one claim.\n    /// @param merkleRoot The merkle root hash for the specific set of items being claimed.\n    /// @param claim The claim struct containing the destination address, all items to be claimed and optional salt param.\n    /// @param proof The proof provided by the user performing the claim function.\n    function claimMultipleTokens(\n        bytes32 merkleRoot,\n        Claim memory claim,\n        bytes32[] calldata proof\n    ) public {\n        uint256 giveawayExpiryTime = _expiryTime[merkleRoot];\n        require(claim.to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(claim.to != address(this), \"DESTINATION_MULTIGIVEAWAY_CONTRACT\");\n        require(giveawayExpiryTime != 0, \"GIVEAWAY_DOES_NOT_EXIST\");\n        require(block.timestamp < giveawayExpiryTime, \"CLAIM_PERIOD_IS_OVER\");\n        require(claimed[claim.to][merkleRoot] == false, \"DESTINATION_ALREADY_CLAIMED\");\n        claimed[claim.to][merkleRoot] = true;\n        _claimERC1155ERC721ERC20(merkleRoot, claim, proof);\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC721_RECEIVED;\n    }\n\n    function onERC721BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC721_BATCH_RECEIVED;\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_RECEIVED;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_BATCH_RECEIVED;\n    }\n}\n"
    },
    "src/solc_0.8/claims/MultiGiveaway/ClaimERC1155ERC721ERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../common/interfaces/IERC721Extended.sol\";\nimport \"../../common/Libraries/Verify.sol\";\n\ncontract ClaimERC1155ERC721ERC20 {\n    ///////////////////////////////  Libs //////////////////////////////\n\n    using SafeERC20 for IERC20;\n\n    ///////////////////////////////  Data //////////////////////////////\n\n    struct Claim {\n        address to;\n        ERC1155Claim[] erc1155;\n        ERC721Claim[] erc721;\n        ERC20Claim erc20;\n        bytes32 salt;\n    }\n\n    struct ERC1155Claim {\n        uint256[] ids;\n        uint256[] values;\n        address contractAddress;\n    }\n\n    struct ERC721Claim {\n        uint256[] ids;\n        address contractAddress;\n    }\n\n    struct ERC20Claim {\n        uint256[] amounts;\n        address[] contractAddresses;\n    }\n\n    ///////////////////////////////  Events //////////////////////////////\n\n    /// @dev Emits when a successful claim occurs.\n    /// @param to The destination address for the claimed ERC1155, ERC721 and ERC20 tokens.\n    /// @param erc1155 The array of ERC1155Claim structs containing the ids, values and ERC1155 contract address.\n    /// @param erc721 The array of ERC721Claim structs containing the ids and ERC721 contract address.\n    /// @param erc20 The ERC20Claim struct containing the amounts and ERC20 contract addresses.\n    /// @param merkleRoot The merkle root hash for the specific set of items being claimed.\n    event ClaimedMultipleTokens(\n        address to,\n        ERC1155Claim[] erc1155,\n        ERC721Claim[] erc721,\n        ERC20Claim erc20,\n        bytes32 merkleRoot\n    );\n\n    ///////////////////////////////  Functions ///////////////////////////\n\n    /// @dev Internal function used to claim multiple token types in one claim.\n    /// @param merkleRoot The merkle root hash for the specific set of items being claimed.\n    /// @param claim The claim struct containing the destination address, all items to be claimed and optional salt param.\n    /// @param proof The proof provided by the user performing the claim function.\n    function _claimERC1155ERC721ERC20(\n        bytes32 merkleRoot,\n        Claim memory claim,\n        bytes32[] calldata proof\n    ) internal {\n        _checkValidity(merkleRoot, claim, proof);\n        for (uint256 i = 0; i < claim.erc1155.length; i++) {\n            require(claim.erc1155[i].ids.length == claim.erc1155[i].values.length, \"INVALID_INPUT\");\n            _transferERC1155(claim.to, claim.erc1155[i].ids, claim.erc1155[i].values, claim.erc1155[i].contractAddress);\n        }\n        for (uint256 i = 0; i < claim.erc721.length; i++) {\n            _transferERC721(claim.to, claim.erc721[i].ids, claim.erc721[i].contractAddress);\n        }\n        if (claim.erc20.amounts.length != 0) {\n            require(claim.erc20.amounts.length == claim.erc20.contractAddresses.length, \"INVALID_INPUT\");\n            _transferERC20(claim.to, claim.erc20.amounts, claim.erc20.contractAddresses);\n        }\n        emit ClaimedMultipleTokens(claim.to, claim.erc1155, claim.erc721, claim.erc20, merkleRoot);\n    }\n\n    /// @dev Private function used to check the validity of a specific claim.\n    /// @param merkleRoot The merkle root hash for the specific set of items being claimed.\n    /// @param claim The claim struct containing the destination address, all items to be claimed and optional salt param.\n    /// @param proof The proof provided by the user performing the claim function.\n    function _checkValidity(\n        bytes32 merkleRoot,\n        Claim memory claim,\n        bytes32[] memory proof\n    ) private pure {\n        bytes32 leaf = _generateClaimHash(claim);\n        require(Verify.doesComputedHashMatchMerkleRootHash(merkleRoot, proof, leaf), \"INVALID_CLAIM\");\n    }\n\n    /// @dev Private function used to generate a hash from an encoded claim.\n    /// @param claim The claim struct.\n    function _generateClaimHash(Claim memory claim) private pure returns (bytes32) {\n        return keccak256(abi.encode(claim));\n    }\n\n    /// @dev Private function used to transfer the ERC1155 tokens specified in a specific claim.\n    /// @param to The destination address for the claimed tokens.\n    /// @param ids The array of ERC1155 ids.\n    /// @param values The amount of ERC1155 tokens of each id to be transferred.\n    /// @param contractAddress The ERC1155 token contract address.\n    function _transferERC1155(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        address contractAddress\n    ) private {\n        require(contractAddress != address(0), \"INVALID_CONTRACT_ZERO_ADDRESS\");\n        IERC1155(contractAddress).safeBatchTransferFrom(address(this), to, ids, values, \"\");\n    }\n\n    /// @dev Private function used to transfer the ERC721tokens specified in a specific claim.\n    /// @param to The destination address for the claimed tokens.\n    /// @param ids The array of ERC721 ids.\n    /// @param contractAddress The ERC721 token contract address.\n    function _transferERC721(\n        address to,\n        uint256[] memory ids,\n        address contractAddress\n    ) private {\n        require(contractAddress != address(0), \"INVALID_CONTRACT_ZERO_ADDRESS\");\n        IERC721Extended(contractAddress).safeBatchTransferFrom(address(this), to, ids, \"\");\n    }\n\n    /// @dev Private function used to transfer the ERC20 tokens specified in a specific claim.\n    /// @param to The destination address for the claimed tokens.\n    /// @param amounts The array of amounts of ERC20 tokens to be transferred.\n    /// @param contractAddresses The array of ERC20 token contract addresses.\n    function _transferERC20(\n        address to,\n        uint256[] memory amounts,\n        address[] memory contractAddresses\n    ) private {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            address erc20ContractAddress = contractAddresses[i];\n            uint256 erc20Amount = amounts[i];\n            require(erc20ContractAddress != address(0), \"INVALID_CONTRACT_ZERO_ADDRESS\");\n            IERC20(erc20ContractAddress).safeTransferFrom(address(this), to, erc20Amount);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721Extended.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC721/IERC721.sol\";\n\ninterface IERC721Extended is IERC721 {\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external;\n\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external;\n\n    function burn(uint256 id) external;\n\n    function burnFrom(address from, uint256 id) external;\n}\n"
    },
    "src/solc_0.8/common/Libraries/Verify.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/**\n * @title Verify\n * @dev Merkle root comparison function.\n */\nlibrary Verify {\n    /// @dev Check if the computedHash == comparisonHash.\n    /// @param comparisonHash The merkle root hash passed to the function.\n    /// @param proof The proof provided by the user.\n    /// @param leaf The generated hash.\n    /// @return Whether the computedHash == comparisonHash.\n    function doesComputedHashMatchMerkleRootHash(\n        bytes32 comparisonHash,\n        bytes32[] memory proof,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash == comparisonHash;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"./extensions/IERC721Enumerable.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "src/solc_0.8/test/FakeERC1155Predicate.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {IERC1155} from \"@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol\";\nimport {ERC1155Receiver} from \"@openzeppelin/contracts-0.8/token/ERC1155/utils/ERC1155Receiver.sol\";\n\ninterface IMintableERC1155 is IERC1155 {\n    function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n\n/// @dev This is NOT a secure ChildChainManager contract implementation!\n/// DO NOT USE in production.\n\ncontract FakeERC1155Predicate is ERC1155Receiver {\n    address private asset;\n\n    function setAsset(address _asset) external {\n        asset = _asset;\n    }\n\n    function lockTokens(\n        address depositor,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        IMintableERC1155(asset).safeBatchTransferFrom(depositor, address(this), ids, amounts, data);\n    }\n\n    function exitTokens(\n        address withdrawer,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public {\n        IMintableERC1155 token = IMintableERC1155(asset);\n        uint256[] memory balances = token.balanceOfBatch(makeArrayWithAddress(address(this), ids.length), ids);\n        (uint256[] memory toBeMinted, bool needMintStep, bool needTransferStep) =\n            calculateAmountsToBeMinted(balances, amounts);\n        if (needMintStep) {\n            token.mintBatch(\n                withdrawer,\n                ids,\n                toBeMinted,\n                data // passing data when minting to withdrawer\n            );\n        }\n        if (needTransferStep) {\n            token.safeBatchTransferFrom(\n                address(this),\n                withdrawer,\n                ids,\n                balances,\n                data // passing data when transferring unlocked tokens to withdrawer\n            );\n        }\n    }\n\n    function calculateAmountsToBeMinted(uint256[] memory balances, uint256[] memory exitAmounts)\n        internal\n        pure\n        returns (\n            uint256[] memory,\n            bool,\n            bool\n        )\n    {\n        uint256 count = balances.length;\n        require(count == exitAmounts.length, \"ChainExitERC1155Predicate: Array length mismatch found\");\n        uint256[] memory toBeMinted = new uint256[](count);\n        bool needMintStep;\n        bool needTransferStep;\n        for (uint256 i = 0; i < count; i++) {\n            if (balances[i] < exitAmounts[i]) {\n                toBeMinted[i] = exitAmounts[i] - balances[i];\n                needMintStep = true;\n            }\n            if (balances[i] != 0) {\n                needTransferStep = true;\n            }\n        }\n        return (toBeMinted, needMintStep, needTransferStep);\n    }\n\n    function makeArrayWithAddress(address addr, uint256 size) internal pure returns (address[] memory) {\n        require(addr != address(0), \"MintableERC1155Predicate: Invalid address\");\n        require(size > 0, \"MintableERC1155Predicate: Invalid resulting array length\");\n        address[] memory addresses = new address[](size);\n        for (uint256 i = 0; i < size; i++) {\n            addresses[i] = addr;\n        }\n        return addresses;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return ERC1155Receiver(address(0)).onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "src/solc_0.8/claims/AssetGiveaway/ClaimERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol\";\n\ncontract ClaimERC1155 {\n    bytes32 internal _merkleRoot;\n    IERC1155 internal immutable _asset;\n    address internal immutable _assetsHolder;\n    event ClaimedAssets(address to, uint256[] assetIds, uint256[] assetValues);\n\n    constructor(IERC1155 asset, address assetsHolder) {\n        _asset = asset;\n        if (assetsHolder == address(0)) {\n            assetsHolder = address(this);\n        }\n        _assetsHolder = assetsHolder;\n    }\n\n    /// @dev See for example AssetGiveaway.sol claimAssets.\n    function _claimERC1155(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata assetValues,\n        bytes32[] calldata proof,\n        bytes32 salt\n    ) internal {\n        _checkValidity(to, assetIds, assetValues, proof, salt);\n        _sendAssets(to, assetIds, assetValues);\n        emit ClaimedAssets(to, assetIds, assetValues);\n    }\n\n    function _checkValidity(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues,\n        bytes32[] memory proof,\n        bytes32 salt\n    ) internal view {\n        require(assetIds.length == assetValues.length, \"INVALID_INPUT\");\n        bytes32 leaf = _generateClaimHash(to, assetIds, assetValues, salt);\n        require(_verify(proof, leaf), \"INVALID_CLAIM\");\n    }\n\n    function _generateClaimHash(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues,\n        bytes32 salt\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(to, assetIds, assetValues, salt));\n    }\n\n    function _verify(bytes32[] memory proof, bytes32 computedHash) internal view returns (bool) {\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        return computedHash == _merkleRoot;\n    }\n\n    function _sendAssets(\n        address to,\n        uint256[] memory assetIds,\n        uint256[] memory assetValues\n    ) internal {\n        _asset.safeBatchTransferFrom(_assetsHolder, to, assetIds, assetValues, \"\");\n    }\n}\n"
    },
    "src/solc_0.8/claims/AssetGiveaway/AssetGiveaway.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC1155/IERC1155.sol\";\nimport \"./ClaimERC1155.sol\";\nimport \"../../common/BaseWithStorage/WithAdmin.sol\";\n\n/// @title AssetGiveaway contract.\n/// @notice This contract manages ERC1155 claims.\ncontract AssetGiveaway is WithAdmin, ClaimERC1155 {\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    uint256 internal immutable _expiryTime;\n    mapping(address => bool) public claimed;\n\n    constructor(\n        address asset,\n        address admin,\n        bytes32 merkleRoot,\n        address assetsHolder,\n        uint256 expiryTime\n    ) ClaimERC1155(IERC1155(asset), assetsHolder) {\n        _admin = admin;\n        _merkleRoot = merkleRoot;\n        _expiryTime = expiryTime;\n    }\n\n    /// @notice Function to set the merkle root hash for the asset data, if it is 0.\n    /// @param merkleRoot The merkle root hash of the asset data.\n    function setMerkleRoot(bytes32 merkleRoot) external onlyAdmin {\n        require(_merkleRoot == 0, \"MERKLE_ROOT_ALREADY_SET\");\n        _merkleRoot = merkleRoot;\n    }\n\n    /// @notice Function to permit the claiming of an asset to a reserved address.\n    /// @param to The intended recipient (reserved address) of the ERC1155 tokens.\n    /// @param assetIds The array of IDs of the asset tokens.\n    /// @param assetValues The amounts of each token ID to transfer.\n    /// @param proof The proof submitted for verification.\n    /// @param salt The salt submitted for verification.\n    function claimAssets(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata assetValues,\n        bytes32[] calldata proof,\n        bytes32 salt\n    ) external {\n        require(block.timestamp < _expiryTime, \"CLAIM_PERIOD_IS_OVER\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(claimed[to] == false, \"DESTINATION_ALREADY_CLAIMED\");\n        claimed[to] = true;\n        _claimERC1155(to, assetIds, assetValues, proof, salt);\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_RECEIVED;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC1155_BATCH_RECEIVED;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "src/solc_0.8/defi/SandRewardPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport {Context} from \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport {Address} from \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts-0.8/access/AccessControl.sol\";\nimport {ERC2771Handler} from \"../common/BaseWithStorage/ERC2771Handler.sol\";\nimport {StakeTokenWrapper} from \"./StakeTokenWrapper.sol\";\nimport {IContributionCalculator} from \"./interfaces/IContributionCalculator.sol\";\nimport {IRewardCalculator} from \"./interfaces/IRewardCalculator.sol\";\n\n/// @title A pool that distributes rewards between users that stake sand (or any erc20 token)\n/// @notice The contributions are updated passively, an external call to computeContribution from a backend is needed.\n/// @notice After initialization the reward calculator must be set by the admin.\n/// @dev The contract has two plugins that affect the behaviour: contributionCalculator and rewardCalculator\n/// @dev contributionCalculator instead of using the stake directly the result of computeContribution is used\n/// @dev this way some users can get an extra share of the rewards\n/// @dev rewardCalculator is used to manage the rate at which the rewards are distributed.\n/// @dev This way we can build different types of pools by mixing in the plugins we want with this contract.\n/// @dev default behaviour (address(0)) for contributionCalculator is to use the stacked amount as contribution.\n/// @dev default behaviour (address(0)) for rewardCalculator is that no rewards are giving\ncontract SandRewardPool is StakeTokenWrapper, AccessControl, ReentrancyGuard, ERC2771Handler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Staked(address indexed account, uint256 stakeAmount);\n    event Withdrawn(address indexed account, uint256 stakeAmount);\n    event Exit(address indexed account);\n    event RewardPaid(address indexed account, uint256 rewardAmount);\n    event ContributionUpdated(address indexed account, uint256 newContribution, uint256 oldContribution);\n\n    // This value multiplied by the user contribution is the share of accumulated rewards (from the start of time\n    // until the last call to restartRewards) for the user taking into account the value of totalContributions.\n    uint256 public rewardPerTokenStored;\n\n    // This value multiplied by the user contribution is the share of reward from the the last time\n    // the user changed his contribution and called restartRewards\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    // This value is the accumulated rewards won by the user when he called the contract.\n    mapping(address => uint256) public rewards;\n\n    IERC20 public rewardToken;\n    IContributionCalculator public contributionCalculator;\n    IRewardCalculator public rewardCalculator;\n\n    uint256 internal _totalContributions;\n    mapping(address => uint256) internal _contributions;\n\n    struct AntiCompound {\n        uint256 lockPeriodInSecs;\n        mapping(address => uint256) lastClaim;\n    }\n    // This is used to implement a time buffer for reward retrieval, so the used cannot re-stake the rewards too fast.\n    AntiCompound public antiCompound;\n\n    constructor(\n        IERC20 stakeToken_,\n        IERC20 rewardToken_,\n        address trustedForwarder\n    ) StakeTokenWrapper(stakeToken_) {\n        rewardToken = rewardToken_;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    modifier antiCompoundCheck(address account) {\n        // We use lockPeriodInSecs == 0 to disable this check\n        if (antiCompound.lockPeriodInSecs != 0) {\n            require(\n                block.timestamp > antiCompound.lastClaim[account] + antiCompound.lockPeriodInSecs,\n                \"SandRewardPool: must wait\"\n            );\n        }\n        antiCompound.lastClaim[account] = block.timestamp;\n        _;\n    }\n\n    modifier isContractAndAdmin(address contractAddress) {\n        require(contractAddress.isContract(), \"SandRewardPool: not a contract\");\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"SandRewardPool: not admin\");\n        _;\n    }\n\n    /// @notice set the lockPeriodInSecs for the anti-compound buffer\n    /// @param lockPeriodInSecs amount of time the user must wait between reward withdrawal\n    function setAntiCompoundLockPeriod(uint256 lockPeriodInSecs) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"SandRewardPool: not admin\");\n        antiCompound.lockPeriodInSecs = lockPeriodInSecs;\n    }\n\n    /// @notice set the contribution calculator\n    /// @param contractAddress address of a plugin that calculates the contribution of the user based on his stake\n    function setContributionCalculator(address contractAddress) external isContractAndAdmin(contractAddress) {\n        contributionCalculator = IContributionCalculator(contractAddress);\n    }\n\n    /// @notice set the reward token\n    /// @param contractAddress address token used to pay rewards\n    function setRewardToken(address contractAddress) external isContractAndAdmin(contractAddress) {\n        rewardToken = IERC20(contractAddress);\n    }\n\n    /// @notice set the stake token\n    /// @param contractAddress address token used to stake funds\n    function setStakeToken(address contractAddress) external isContractAndAdmin(contractAddress) {\n        _stakeToken = IERC20(contractAddress);\n    }\n\n    /// @notice set the trusted forwarder\n    /// @param trustedForwarder address of the contract that is enabled to send meta-tx on behalf of the user\n    function setTrustedForwarder(address trustedForwarder) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"SandRewardPool: not admin\");\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @notice set the reward calculator\n    /// @param contractAddress address of a plugin that calculates absolute rewards at any point in time\n    /// @param restartRewards if true the rewards from the previous calculator are accumulated before changing it\n    function setRewardCalculator(address contractAddress, bool restartRewards)\n        external\n        isContractAndAdmin(contractAddress)\n    {\n        // We process the rewards of the current reward calculator before the switch.\n        if (restartRewards) {\n            _restartRewards();\n        }\n        rewardCalculator = IRewardCalculator(contractAddress);\n    }\n\n    /// @notice the admin recover is able to recover reward funds\n    /// @param receiver address of the beneficiary of the recovered funds\n    /// @dev this function must be called in an emergency situation only.\n    /// @dev Calling it is risky specially when rewardToken == stakeToken\n    function recoverFunds(address receiver) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"SandRewardPool: not admin\");\n        require(receiver != address(0), \"SandRewardPool: invalid receiver\");\n        rewardToken.safeTransfer(receiver, rewardToken.balanceOf(address(this)));\n    }\n\n    /// @notice return the total supply of staked tokens\n    /// @return the total supply of staked tokens\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice return the balance of staked tokens for a user\n    /// @param account the address of the account\n    /// @return balance of staked tokens\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @notice return the address of the stake token contract\n    /// @return address of the stake token contract\n    function stakeToken() external view returns (IERC20) {\n        return _stakeToken;\n    }\n\n    /// @notice return the amount of rewards deposited in the contract that can be distributed by different campaigns\n    /// @return the total amount of deposited rewards\n    /// @dev this function can be called by a reward calculator to throw if a campaign doesn't have\n    /// @dev enough rewards to start\n    function getRewardsAvailable() external view returns (uint256) {\n        if (address(rewardToken) != address(_stakeToken)) {\n            return rewardToken.balanceOf(address(this));\n        }\n        return _stakeToken.balanceOf(address(this)) - _totalSupply;\n    }\n\n    /// @notice return the sum of the values returned by the contribution calculator\n    /// @return total contributions of the users\n    /// @dev this is the same than the totalSupply only if the contribution calculator\n    /// @dev uses the staked amount as the contribution of the user which is the default behaviour\n    function totalContributions() external view returns (uint256) {\n        return _totalContributions;\n    }\n\n    /// @notice return the contribution of some user\n    /// @param account the address of the account\n    /// @return contribution of the users\n    /// @dev this is the same than the balanceOf only if the contribution calculator\n    /// @dev uses the staked amount as the contribution of the user which is the default behaviour\n    function contributionOf(address account) external view returns (uint256) {\n        return _contributions[account];\n    }\n\n    /// @notice accumulated rewards taking into account the totalContribution (see: rewardPerTokenStored)\n    /// @return the accumulated total rewards\n    /// @dev This value multiplied by the user contribution is the share of accumulated rewards for the user. Taking\n    /// @dev into account the value of totalContributions.\n    function rewardPerToken() external view returns (uint256) {\n        return rewardPerTokenStored + _rewardPerToken();\n    }\n\n    /// @notice available earnings for some user\n    /// @param account the address of the account\n    /// @return the available earnings for the user\n    function earned(address account) external view returns (uint256) {\n        return rewards[account] + _earned(account, _rewardPerToken());\n    }\n\n    /// @notice accumulates the current rewards into rewardPerTokenStored and restart the reward calculator\n    /// @dev calling this function make no difference. It is useful for testing and when the reward calculator\n    /// @dev is changed.\n    function restartRewards() external {\n        _restartRewards();\n    }\n\n    /// @notice update the contribution for a user\n    /// @param account the address of the account\n    /// @dev if the user change his holdings (or any other parameter that affect the contribution calculation),\n    /// @dev he can the reward distribution to his favor. This function must be called by an external agent ASAP to\n    /// @dev update the contribution for the user. We understand the risk but the rewards are distributes slowly so\n    /// @dev the user cannot affect the reward distribution heavily.\n    function computeContribution(address account) external {\n        require(account != address(0), \"SandRewardPool: invalid address\");\n        // We decide to give the user the accumulated rewards even if he cheated a little bit.\n        _processRewards(account);\n        _updateContribution(account);\n    }\n\n    /// @notice update the contribution for a sef of users\n    /// @param accounts the addresses of the accounts to update\n    /// @dev see: computeContribution\n    function computeContributionInBatch(address[] calldata accounts) external {\n        _restartRewards();\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            if (account == address(0)) {\n                continue;\n            }\n            _processAccountRewards(account);\n            _updateContribution(account);\n        }\n    }\n\n    /// @notice stake some amount into the contract\n    /// @param amount the amount of tokens to stake\n    /// @dev the user must approve in the stack token before calling this function\n    function stake(uint256 amount) external nonReentrant {\n        require(amount > 0, \"SandRewardPool: Cannot stake 0\");\n\n        // The first time a user stakes he cannot remove his rewards immediately.\n        if (antiCompound.lastClaim[_msgSender()] == 0) {\n            antiCompound.lastClaim[_msgSender()] = block.timestamp;\n        }\n\n        uint256 earlierRewards = 0;\n\n        if (_totalContributions == 0 && rewardCalculator != IRewardCalculator(address(0))) {\n            earlierRewards = rewardCalculator.getRewards();\n        }\n\n        _processRewards(_msgSender());\n        super._stake(amount);\n        _updateContribution(_msgSender());\n        require(_contributions[_msgSender()] > 0, \"SandRewardPool: not enough contributions\");\n\n        if (earlierRewards != 0) {\n            rewards[_msgSender()] = rewards[_msgSender()] + earlierRewards;\n        }\n        emit Staked(_msgSender(), amount);\n    }\n\n    /// @notice withdraw the stake from the contract\n    /// @param amount the amount of tokens to withdraw\n    /// @dev the user can withdraw his stake independently from the rewards\n    function withdraw(uint256 amount) external nonReentrant {\n        _processRewards(_msgSender());\n        _withdrawStake(_msgSender(), amount);\n        _updateContribution(_msgSender());\n    }\n\n    /// @notice withdraw the stake and the rewards from the contract\n    function exit() external nonReentrant {\n        _processRewards(_msgSender());\n        _withdrawStake(_msgSender(), _balances[_msgSender()]);\n        _withdrawRewards(_msgSender());\n        _updateContribution(_msgSender());\n        emit Exit(_msgSender());\n    }\n\n    /// @notice withdraw the rewards from the contract\n    /// @dev the user can withdraw his stake independently from the rewards\n    function getReward() external nonReentrant {\n        _processRewards(_msgSender());\n        _withdrawRewards(_msgSender());\n        _updateContribution(_msgSender());\n    }\n\n    function _withdrawStake(address account, uint256 amount) internal {\n        require(amount > 0, \"SandRewardPool: Cannot withdraw 0\");\n        super._withdraw(amount);\n        emit Withdrawn(account, amount);\n    }\n\n    function _withdrawRewards(address account) internal antiCompoundCheck(account) {\n        uint256 reward = rewards[account];\n        if (reward > 0) {\n            rewards[account] = 0;\n            rewardToken.safeTransfer(account, reward);\n            emit RewardPaid(account, reward);\n        }\n    }\n\n    function _updateContribution(address account) internal {\n        uint256 oldContribution = _contributions[account];\n        _totalContributions = _totalContributions - oldContribution;\n        uint256 contribution = _computeContribution(account);\n        _totalContributions = _totalContributions + contribution;\n        _contributions[account] = contribution;\n        emit ContributionUpdated(account, contribution, oldContribution);\n    }\n\n    function _computeContribution(address account) internal returns (uint256) {\n        if (contributionCalculator == IContributionCalculator(address(0))) {\n            return _balances[account];\n        } else {\n            return contributionCalculator.computeContribution(account, _balances[account]);\n        }\n    }\n\n    // Something changed (stake, withdraw, etc), we distribute current accumulated rewards and start from zero.\n    // Called each time there is a change in contract state (stake, withdraw, etc).\n    function _processRewards(address account) internal {\n        _restartRewards();\n        _processAccountRewards(account);\n    }\n\n    // Update the earnings for this specific user with what he earned until now\n    function _processAccountRewards(address account) internal {\n        // usually _earned takes _rewardPerToken() but in this method is zero because _restartRewards must be\n        // called before _processAccountRewards\n        rewards[account] = rewards[account] + _earned(account, 0);\n        // restart rewards for this specific user, now earned(account) = 0\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n\n    function _restartRewards() internal {\n        if (rewardCalculator != IRewardCalculator(address(0))) {\n            // Distribute the accumulated rewards\n            rewardPerTokenStored = rewardPerTokenStored + _rewardPerToken();\n            // restart rewards so now the rewardCalculator return zero rewards\n            rewardCalculator.restartRewards();\n        }\n    }\n\n    function _earned(address account, uint256 rewardPerToken) internal view returns (uint256) {\n        // - userRewardPerTokenPaid[account] * _contributions[account]  / _totalContributions is the portion of\n        //      rewards the last time the user changed his contribution and called _restartRewards\n        //      (_totalContributions corresponds to previous value of that moment).\n        // - rewardPerTokenStored * _contributions[account] is the share of the user from the\n        //      accumulated rewards (from the start of time until the last call to _restartRewards) with the\n        //      current value of _totalContributions\n        // - _rewardPerToken() * _contributions[account]  / _totalContributions is the share of the user of the\n        //      rewards from the last time anybody called _restartRewards until this moment\n        //\n        // The important thing to note is that at any moment in time _contributions[account] / _totalContributions is\n        // the share of the user even if _totalContributions changes because of other users activity.\n        return\n            ((rewardPerToken + rewardPerTokenStored - userRewardPerTokenPaid[account]) * _contributions[account]) /\n            1e24;\n    }\n\n    // This function gives the proportion of the total contribution that corresponds to each user from\n    // last restartRewards call.\n    // _rewardsPerToken() * _contributions[account] is the amount of extra rewards gained from last restartRewards.\n    function _rewardPerToken() internal view returns (uint256) {\n        if (rewardCalculator == IRewardCalculator(address(0)) || _totalContributions == 0) {\n            return 0;\n        }\n        return (rewardCalculator.getRewards() * 1e24) / _totalContributions;\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/solc_0.8/defi/StakeTokenWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Context.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract StakeTokenWrapper is Context {\n    using SafeERC20 for IERC20;\n    IERC20 internal _stakeToken;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    constructor(IERC20 stakeToken) {\n        _stakeToken = stakeToken;\n    }\n\n    function _stake(uint256 amount) internal virtual {\n        _totalSupply = _totalSupply + amount;\n        _balances[_msgSender()] = _balances[_msgSender()] + amount;\n        _stakeToken.safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    function _withdraw(uint256 amount) internal virtual {\n        _totalSupply = _totalSupply - amount;\n        _balances[_msgSender()] = _balances[_msgSender()] - amount;\n        _stakeToken.safeTransfer(_msgSender(), amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "src/solc_0.8/defi/interfaces/IContributionCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\n/// @title Plugins for the SandRewardPool that calculate the contributions must implement this interface\ninterface IContributionCalculator {\n    /// @notice based on the user stake and address calculate the contribution\n    /// @param account address of the user that is staking tokens\n    /// @param amountStaked the amount of tokens stacked\n    function computeContribution(address account, uint256 amountStaked) external returns (uint256);\n}\n"
    },
    "src/solc_0.8/defi/interfaces/IRewardCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\n/// @title Plugins for the SandRewardPool that calculate the rewards must implement this interface\ninterface IRewardCalculator {\n    /// @dev At any point in time this function must return the accumulated rewards from the last call to restartRewards\n    function getRewards() external view returns (uint256);\n\n    /// @dev The main contract has distributed the rewards (getRewards()) until this point, this must start\n    /// @dev from scratch => getRewards() == 0\n    function restartRewards() external;\n}\n"
    },
    "src/solc_0.8/test/RewardCalculatorMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"../defi/interfaces/IRewardCalculator.sol\";\n\ncontract RewardCalculatorMock is IRewardCalculator {\n    event RewardRestarted();\n\n    uint256 public reward;\n    bool public skipRestart;\n\n    // At any point in time this function must return the accumulated rewards from last call to restartRewards\n    function getRewards() external view override returns (uint256) {\n        return reward;\n    }\n\n    function restartRewards() external override {\n        if (!skipRestart) {\n            reward = 0;\n        }\n        emit RewardRestarted();\n    }\n\n    function setReward(uint256 reward_) external {\n        reward = reward_;\n    }\n\n    function setSkipRestart(bool val) external {\n        skipRestart = val;\n    }\n}\n"
    },
    "src/solc_0.8/defi/rewardCalculation/TwoPeriodsRewardCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport {Math} from \"@openzeppelin/contracts-0.8/utils/math/Math.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts-0.8/access/AccessControl.sol\";\nimport {IRewardCalculator} from \"../interfaces/IRewardCalculator.sol\";\n\ncontract TwoPeriodsRewardCalculator is IRewardCalculator, AccessControl {\n    event InitialCampaign(\n        uint256 reward,\n        uint256 duration,\n        uint256 finish1,\n        uint256 rate1,\n        uint256 finish2,\n        uint256 rate2\n    );\n    event NextCampaign(\n        uint256 reward,\n        uint256 duration,\n        uint256 finish1,\n        uint256 rate1,\n        uint256 finish2,\n        uint256 rate2\n    );\n    event UpdateCampaign(\n        uint256 reward,\n        uint256 duration,\n        uint256 finish1,\n        uint256 rate1,\n        uint256 finish2,\n        uint256 rate2\n    );\n\n    // This role is in charge of configuring reward distribution\n    bytes32 public constant REWARD_DISTRIBUTION = keccak256(\"REWARD_DISTRIBUTION\");\n    // Each time a parameter that affects the reward distribution is changed the rewards are distributed by the reward\n    // pool contract this is the restart time.\n    uint256 public lastUpdateTime;\n    // This variable is only used when a new campaign starts (notifyRewardAmount is called)\n    // We need to save the rewards accumulated between the last call to restartRewards and the call to notifyRewardAmount\n    uint256 public savedRewards;\n    // The reward distribution is divided in two periods with two different rated\n    //                   |            |            |************|*\n    //                   |            |          **|            |*\n    //                   |            |        **  |            |*\n    //                   |            |      **    |            |*\n    //                   |            |    **      |            |*\n    //                   |            |  **        |            |*\n    //                   |            |**          |            |*\n    //                   |        ****|            |            |*\n    //                   |    ****    |            |            |*\n    //                   |****        |            |            |*\n    // zero -> **********|            |            |            |********************\n    //                   |<-perido1-> |<-period2-> |<-restart-> |\n    uint256 public finish1;\n    uint256 public rate1;\n    uint256 public finish2;\n    uint256 public rate2;\n\n    // The address of the reward pool, the only one authorized to restart rewards\n    address public immutable rewardPool;\n\n    constructor(address rewardPool_) {\n        rewardPool = rewardPool_;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    // For the UI\n    function getRate() external view returns (uint256) {\n        return rate1;\n    }\n\n    // For the UI\n    function getFinish() external view returns (uint256) {\n        return finish1;\n    }\n\n    // At any point in time this function must return the accumulated rewards from last call to restartRewards\n    function getRewards() external view override returns (uint256) {\n        return savedRewards + _getRewards();\n    }\n\n    // The main contract has distributed the rewards until this point, this must start from scratch => getRewards() == 0\n    function restartRewards() external override {\n        require(msg.sender == rewardPool, \"not reward pool\");\n        lastUpdateTime = block.timestamp;\n        savedRewards = 0;\n    }\n\n    // Useful when switching reward calculators to set an initial reward.\n    function setSavedRewards(uint256 reward) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"not reward distribution\");\n        savedRewards = reward;\n        lastUpdateTime = block.timestamp;\n    }\n\n    // This is a helper function, it is better to call setInitialCampaign or updateNextCampaign directly\n    function runCampaign(uint256 reward, uint256 duration) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"not reward distribution\");\n        if (block.timestamp >= finish2) {\n            _initialCampaign(reward, duration);\n        } else {\n            _updateNextCampaign(reward, duration);\n        }\n    }\n\n    // Start an initial campaign, set the period1 of reward distribution, period2 rate is zero\n    function setInitialCampaign(uint256 reward, uint256 duration) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"not reward distribution\");\n        require(block.timestamp >= finish2, \"initial campaign running\");\n        _initialCampaign(reward, duration);\n    }\n\n    // Update the period2 of rate distribution, must be called after an initial campaign is set\n    // If period1 is running, period2 is set with the rate reward/duration.\n    // If period1 is finished it is updated with the values of period2 and period2 is set with the rate reward/duration.\n    function updateNextCampaign(uint256 reward, uint256 duration) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"not reward distribution\");\n        require(block.timestamp < finish2, \"initial campaign not running\");\n        _updateNextCampaign(reward, duration);\n    }\n\n    function updateCurrentCampaign(uint256 reward, uint256 duration) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"not reward distribution\");\n        require(block.timestamp < finish2, \"initial campaign not running\");\n        _updateCurrentCampaign(reward, duration);\n    }\n\n    // Check if both periods already ended => campaign is finished\n    function isCampaignFinished() external view returns (bool) {\n        return (block.timestamp >= finish2);\n    }\n\n    // Check if some of the periods are still running\n    function isCampaignRunning() external view returns (bool) {\n        return (block.timestamp < finish2);\n    }\n\n    function _initialCampaign(uint256 reward, uint256 duration) internal {\n        // block.timestamp >= finish2\n        _saveRewards();\n        finish1 = block.timestamp + duration;\n        rate1 = reward / duration;\n        finish2 = block.timestamp + duration;\n        rate2 = 0;\n        emit InitialCampaign(reward, duration, finish1, rate1, finish2, rate2);\n    }\n\n    function _updateNextCampaign(uint256 reward, uint256 duration) internal {\n        // block.timestamp < finish2\n        _saveRewards();\n        if (block.timestamp >= finish1) {\n            // The next campaign is new.\n            finish1 = finish2;\n            rate1 = rate2;\n        }\n        finish2 = finish1 + duration;\n        rate2 = reward / duration;\n        emit NextCampaign(reward, duration, finish1, rate1, finish2, rate2);\n    }\n\n    // TODO: we need to check the logic for this one, what to do with the remainder rewards and the next campaign duration ?\n    // TODO: Right now we restart the current campaign forgetting the old values and leaving next one untouched.\n    function _updateCurrentCampaign(uint256 reward, uint256 duration) internal {\n        _saveRewards();\n        if (block.timestamp >= finish1) {\n            // The next campaign is new.\n            finish1 = finish2;\n            rate1 = rate2;\n            rate2 = 0;\n        }\n        assert(finish1 <= finish2);\n        uint256 duration2 = finish2 - finish1;\n        finish1 = block.timestamp + duration;\n        finish2 = finish1 + duration2;\n        rate1 = reward / duration;\n        emit UpdateCampaign(reward, duration, finish1, rate1, finish2, rate2);\n    }\n\n    function _saveRewards() internal {\n        savedRewards = savedRewards + _getRewards();\n        lastUpdateTime = block.timestamp;\n    }\n\n    function _getRewards() internal view returns (uint256) {\n        assert(lastUpdateTime <= block.timestamp);\n        assert(finish1 <= finish2);\n        if (lastUpdateTime >= finish2) {\n            return 0;\n        }\n        if (block.timestamp <= finish1) {\n            return (block.timestamp - lastUpdateTime) * rate1;\n        }\n        // block.timestamp > finish1\n        uint256 rewards2 = (Math.min(block.timestamp, finish2) - Math.max(lastUpdateTime, finish1)) * rate2;\n        if (lastUpdateTime < finish1) {\n            // add reward1 + reward2\n            return (finish1 - lastUpdateTime) * rate1 + rewards2;\n        }\n        return rewards2;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "src/solc_0.8/polygon/LiquidityMining/PolygonSANDRewardPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.8/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport \"./IRewardDistributionRecipient.sol\";\nimport \"../../common/interfaces/IERC721.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 internal _stakeToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    constructor(IERC20 stakeToken) {\n        _stakeToken = stakeToken;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract PolygonSANDRewardPool is LPTokenWrapper, IRewardDistributionRecipient {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DURATION = 30 days; // Reward period\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    IERC20 internal _rewardToken;\n\n    constructor(IERC20 stakeToken, IERC20 rewardToken) LPTokenWrapper(stakeToken) {\n        _rewardToken = rewardToken;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            _rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }\n\n    // Add Setter functions for every external contract\n\n    function SetRewardLPToken(address newRewardToken) external onlyOwner {\n        require(newRewardToken != address(0), \"Bad RewardToken address\");\n\n        _rewardToken = IERC20(newRewardToken);\n    }\n\n    function SetStakeLPToken(address newStakeLPToken) external onlyOwner {\n        require(newStakeLPToken != address(0), \"Bad StakeToken address\");\n\n        _stakeToken = IERC20(newStakeLPToken);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "src/solc_0.8/polygon/LiquidityMining/IRewardDistributionRecipient.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    address public rewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(_msgSender() == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    modifier onlyRewardDistributionOrAccount(address account) {\n        require(\n            _msgSender() == rewardDistribution || _msgSender() == account,\n            \"Caller is not reward distribution or account\"\n        );\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution) external onlyOwner {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721Events.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\n/*interface*/\ninterface IERC721 is IERC165, IERC721Events {\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    //   function exists(uint256 tokenId) external view returns (bool exists);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC165.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title ERC165\n * @dev https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements interface `interfaceId`\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721Events.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Events {\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    // Duplicate event, ERC1155 ApprovalForAll\n    // event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n}\n"
    },
    "src/solc_0.8/polygon/LiquidityMining/PolygonLandWeightedSANDRewardPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.8/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../common/Libraries/SafeMathWithRequire.sol\";\nimport \"./IRewardDistributionRecipient.sol\";\nimport \"../../common/interfaces/IERC721.sol\";\n\ncontract PolygonLPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n\n    IERC20 internal _stakeToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    constructor(IERC20 stakeToken) {\n        _stakeToken = stakeToken;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\n///@notice Reward Pool based on unipool contract : https://github.com/Synthetixio/Unipool/blob/master/contracts/Unipool.sol\n//with the addition of NFT multiplier reward\ncontract PolygonLandWeightedSANDRewardPool is PolygonLPTokenWrapper, IRewardDistributionRecipient, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeMathWithRequire for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event MultiplierComputed(address indexed user, uint256 multiplier, uint256 contribution);\n\n    uint256 public immutable duration;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 internal constant DECIMALS_9 = 1000000000;\n    uint256 internal constant MIDPOINT_9 = 500000000;\n    uint256 internal constant NFT_FACTOR_6 = 10000;\n    uint256 internal constant NFT_CONSTANT_3 = 9000;\n    uint256 internal constant ROOT3_FACTOR = 697;\n\n    IERC20 internal _rewardToken;\n    IERC721 internal _multiplierNFToken;\n\n    uint256 internal _totalContributions;\n    mapping(address => uint256) internal _multipliers;\n    mapping(address => uint256) internal _contributions;\n\n    constructor(\n        IERC20 stakeToken,\n        IERC20 rewardToken,\n        IERC721 multiplierNFToken,\n        uint256 rewardDuration\n    ) PolygonLPTokenWrapper(stakeToken) {\n        _rewardToken = rewardToken;\n        _multiplierNFToken = multiplierNFToken;\n        duration = rewardDuration;\n    }\n\n    function totalContributions() public view returns (uint256) {\n        return _totalContributions;\n    }\n\n    function contributionOf(address account) public view returns (uint256) {\n        return _contributions[account];\n    }\n\n    function multiplierOf(address account) public view returns (uint256) {\n        return _multipliers[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n\n        if (block.timestamp >= periodFinish || _totalContributions != 0) {\n            // ensure reward past the first staker do not get lost\n            lastUpdateTime = lastTimeRewardApplicable();\n        }\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalContributions() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e24).div(totalContributions())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            contributionOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e24).add(\n                rewards[account]\n            );\n    }\n\n    function computeContribution(uint256 amountStaked, uint256 numLands) public pure returns (uint256) {\n        if (numLands == 0) {\n            return amountStaked;\n        }\n        uint256 nftContrib = NFT_FACTOR_6.mul(NFT_CONSTANT_3.add(numLands.sub(1).mul(ROOT3_FACTOR).add(1).cbrt3()));\n        if (nftContrib > MIDPOINT_9) {\n            nftContrib = MIDPOINT_9.add(nftContrib.sub(MIDPOINT_9).div(10));\n        }\n        return amountStaked.add(amountStaked.mul(nftContrib).div(DECIMALS_9));\n    }\n\n    function updateContribution(address account) internal {\n        _totalContributions = _totalContributions.sub(contributionOf(account));\n        _multipliers[account] = _multiplierNFToken.balanceOf(account);\n\n        uint256 contribution = computeContribution(balanceOf(account), multiplierOf(account));\n\n        _totalContributions = _totalContributions.add(contribution);\n        _contributions[account] = contribution;\n    }\n\n    function computeMultiplier(address account) public onlyRewardDistributionOrAccount(account) updateReward(account) {\n        updateContribution(account);\n\n        emit MultiplierComputed(account, multiplierOf(account), contributionOf(account));\n    }\n\n    function stake(uint256 amount) public override nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n\n        super.stake(amount);\n\n        updateContribution(msg.sender);\n\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n\n        super.withdraw(amount);\n\n        updateContribution(msg.sender);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            _rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    ///@notice to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract\n    // Note that the reward should be divisible by the duration to avoid reward token lost\n    ///@param reward number of token to be distributed over the duration\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    // Add Setter functions for every external contract\n\n    function SetRewardToken(address newRewardToken) external onlyOwner {\n        require(newRewardToken.isContract(), \"Bad RewardToken address\");\n\n        _rewardToken = IERC20(newRewardToken);\n    }\n\n    function SetStakeLPToken(address newStakeLPToken) external onlyOwner {\n        require(newStakeLPToken.isContract(), \"Bad StakeToken address\");\n\n        _stakeToken = IERC20(newStakeLPToken);\n    }\n\n    function SetNFTMultiplierToken(address newNFTMultiplierToken) external onlyOwner {\n        require(newNFTMultiplierToken.isContract(), \"Bad NFTMultiplierToken address\");\n\n        _multiplierNFToken = IERC721(newNFTMultiplierToken);\n    }\n}\n"
    },
    "src/solc_0.8/common/Libraries/SafeMathWithRequire.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMathWithRequire {\n    using SafeMath for uint256;\n\n    uint256 private constant DECIMALS_18 = 1000000000000000000;\n    uint256 private constant DECIMALS_12 = 1000000000000;\n    uint256 private constant DECIMALS_9 = 1000000000;\n    uint256 private constant DECIMALS_6 = 1000000;\n\n    function sqrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_12);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function sqrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_6);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function cbrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_18);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n\n    function cbrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_9);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n}\n"
    },
    "src/solc_0.8/test/PolygonLandWeightedSANDRewardPoolNFTTest.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../polygon/LiquidityMining/PolygonLandWeightedSANDRewardPool.sol\";\n\ncontract PolygonLandWeightedSANDRewardPoolNFTTest is PolygonLandWeightedSANDRewardPool {\n    constructor(\n        address stakeTokenContract,\n        address rewardTokenContract,\n        address nftContract,\n        uint256 rewardDuration\n    )\n        PolygonLandWeightedSANDRewardPool(\n            IERC20(stakeTokenContract),\n            IERC20(rewardTokenContract),\n            IERC721(nftContract),\n            rewardDuration\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}\n"
    },
    "src/solc_0.8/polygon/child/sand/PolygonSandClaim.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPolygonSand.sol\";\n\ncontract PolygonSandClaim is Ownable, ReentrancyGuard {\n    IPolygonSand internal immutable _polygonSand;\n    IERC20 internal immutable _fakePolygonSand;\n\n    event SandClaimed(address indexed user, uint256 amount);\n\n    constructor(IPolygonSand polygonSand, IERC20 fakePolygonSand) {\n        _polygonSand = polygonSand;\n        _fakePolygonSand = fakePolygonSand;\n    }\n\n    /**\n     * @notice Swaps fake sand with the new polygonSand\n     * @param amount the amount of tokens to be swapped\n     */\n    function claim(uint256 amount) external nonReentrant {\n        require(unclaimedSand() >= amount, \"Not enough sand for claim\");\n        bool success = _fakePolygonSand.transferFrom(msg.sender, address(this), amount);\n        if (success) {\n            _polygonSand.transfer(msg.sender, amount);\n            emit SandClaimed(msg.sender, amount);\n        }\n    }\n\n    // Getters\n\n    /**\n     * @notice Getter for amount of sand which is still locked in this contract\n     */\n    function unclaimedSand() public returns (uint256) {\n        return _polygonSand.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Getter for amount of fake Sand swapped\n     */\n    function claimedSand() external view returns (uint256) {\n        return _fakePolygonSand.balanceOf(address(this));\n    }\n}\n"
    },
    "src/solc_0.8/polygon/child/sand/interfaces/IPolygonSand.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ninterface IPolygonSand {\n    /// @notice update the ChildChainManager Proxy address\n    /// @param newChildChainManagerProxy address of the new childChainManagerProxy\n    function updateChildChainManager(address newChildChainManagerProxy) external;\n\n    /// @notice called when tokens are deposited on root chain\n    /// @param user user address for whom deposit is being done\n    /// @param depositData abi encoded amount\n    function deposit(address user, bytes calldata depositData) external;\n\n    /// @notice called when user wants to withdraw tokens back to root chain\n    /// @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n    /// @param amount amount to withdraw\n    function withdraw(uint256 amount) external;\n\n    /// @notice Get the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    function balanceOf(address owner) external returns (uint256);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param amount number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 amount) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param amount number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success);\n\n    function setTrustedForwarder(address trustedForwarder) external;\n}\n"
    },
    "src/solc_0.8/test/MockERC20BasicApprovalTarget.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\n\ncontract MockERC20BasicApprovalTarget {\n    event LogOnCall(address);\n\n    function logOnCall(address sender) external returns (address) {\n        emit LogOnCall(sender);\n        return sender;\n    }\n\n    function revertOnCall() external pure {\n        revert(\"REVERT_ON_CALL\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return IERC20(msg.sender).transferFrom(sender, recipient, amount);\n    }\n}\n"
    },
    "src/solc_0.8/test/FakeERC20Predicate.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {SafeERC20} from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\n\n/// @dev This is NOT a secure ERC20 Predicate contract implementation!\n/// DO NOT USE in production.\n\ncontract FakeERC20Predicate {\n    address private token;\n    using SafeERC20 for IERC20;\n\n    event LockedERC20(\n        address indexed depositor,\n        address indexed depositReceiver,\n        address indexed rootToken,\n        uint256 amount\n    );\n\n    function setToken(address _token) external {\n        token = _token;\n    }\n\n    function lockTokens(\n        address depositor,\n        address depositReceiver,\n        bytes calldata depositData\n    ) external {\n        uint256 amount = abi.decode(depositData, (uint256));\n        emit LockedERC20(depositor, depositReceiver, token, amount);\n        IERC20(token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    function exitTokens(address withdrawer, uint256 amount) public {\n        IERC20(token).safeTransfer(withdrawer, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "src/solc_0.8/test/ERC20Mintable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {ERC20} from \"@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol\";\n\n/// @dev This is NOT a secure ERC20\n/// DO NOT USE in production.\ncontract ERC20Mintable is ERC20 {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n}\n"
    },
    "src/solc_0.8/Sand/SandBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/extensions/ERC20BasicApproveExtension.sol\";\nimport \"../common/BaseWithStorage/ERC20/ERC20BaseToken.sol\";\n\ncontract SandBaseToken is ERC20BaseToken, ERC20BasicApproveExtension {\n    constructor(\n        address sandAdmin,\n        address executionAdmin,\n        address beneficiary,\n        uint256 amount\n    ) ERC20BaseToken(\"SAND\", \"SAND\", sandAdmin, executionAdmin) {\n        _admin = sandAdmin;\n        if (beneficiary != address(0)) {\n            uint256 initialSupply = amount * (1 ether);\n            _mint(beneficiary, initialSupply);\n        }\n    }\n}\n"
    },
    "src/solc_0.8/test/FakePolygonSand.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/ERC20BaseToken.sol\";\n\ncontract FakePolygonSand is ERC20BaseToken {\n    constructor() ERC20BaseToken(\"FakePolygonSand\", \"FPS\", msg.sender, msg.sender) {\n        _mint(msg.sender, 3000000000 * 10**18);\n    }\n}\n"
    },
    "src/solc_0.8/test/FakePolygonLand.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/ERC20BaseToken.sol\";\n\ncontract FakePolygonLand is ERC20BaseToken {\n    constructor() ERC20BaseToken(\"FakePolygonLand\", \"FPL\", msg.sender, msg.sender) {\n        _mint(msg.sender, 3000000000 * 10**18);\n    }\n}\n"
    },
    "src/solc_0.8/test/FakeLPSandMatic.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ERC20/ERC20BaseToken.sol\";\n\ncontract FakeLPSandMatic is ERC20BaseToken {\n    constructor() ERC20BaseToken(\"LPSandMatic\", \"LPSM\", msg.sender, msg.sender) {\n        _mint(msg.sender, 3000000000 * 10**18);\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ERC721BaseToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n/* solhint-disable func-order, code-complexity */\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC721/IERC721Receiver.sol\";\nimport \"./WithSuperOperators.sol\";\nimport \"../interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC721/IERC721.sol\";\nimport \"./ERC2771Handler.sol\";\n\ncontract ERC721BaseToken is IERC721, WithSuperOperators, ERC2771Handler {\n    using Address for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    uint256 internal constant NOT_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\n    uint256 internal constant OPERATOR_FLAG = (2**255);\n    uint256 internal constant NOT_OPERATOR_FLAG = OPERATOR_FLAG - 1;\n    uint256 internal constant BURNED_FLAG = (2**160);\n\n    mapping(address => uint256) internal _numNFTPerAddress;\n    mapping(uint256 => uint256) internal _owners;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    mapping(uint256 => address) internal _operators;\n\n    /// @notice Approve an operator to spend tokens on the senders behalf.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approve(address operator, uint256 id) external override {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = address(uint160(ownerData));\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(\n            owner == msgSender || _superOperators[msgSender] || _operatorsForAll[owner][msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Approve an operator to spend tokens on the sender behalf.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param id The id of the token.\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        uint256 ownerData = _owners[_storageId(id)];\n        address msgSender = _msgSender();\n        require(sender != address(0), \"ZERO_ADDRESS_SENDER\");\n        require(\n            msgSender == sender || _superOperators[msgSender] || _operatorsForAll[sender][msgSender],\n            \"UNAUTHORIZED_APPROVAL\"\n        );\n        require(address(uint160(ownerData)) == sender, \"OWNER_NOT_SENDER\");\n        _approveFor(ownerData, operator, id);\n    }\n\n    /// @notice Transfer a token between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, \"\"), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n    /// @param from The send of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external override {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /// @notice Transfer many tokens between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    /// @notice Transfer many tokens between 2 addresses, while\n    /// ensuring the receiving contract has a receiver method.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param ids The ids of the tokens.\n    /// @param data Additional data.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param sender The address giving the approval.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        address msgSender = _msgSender();\n        require(msgSender == sender || _superOperators[msgSender], \"UNAUTHORIZED_APPROVE_FOR_ALL\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAll(address operator, bool approved) external override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id The token which will be burnt.\n    function burn(uint256 id) external virtual {\n        _burn(_msgSender(), _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id The token which will be burnt.\n    function burnFrom(address from, uint256 id) external virtual {\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(\n            msgSender == from ||\n                (operatorEnabled && _operators[id] == msgSender) ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender],\n            \"UNAUTHORIZED_BURN\"\n        );\n        _burn(from, owner, id);\n    }\n\n    /// @notice Get the number of tokens owned by an address.\n    /// @param owner The address to look for.\n    /// @return The number of tokens owned by the address.\n    function balanceOf(address owner) external view override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS_OWNER\");\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice Get the owner of a token.\n    /// @param id The id of the token.\n    /// @return owner The address of the token owner.\n    function ownerOf(uint256 id) external view override returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"NONEXISTANT_TOKEN\");\n    }\n\n    /// @notice Get the approved operator for a specific token.\n    /// @param id The id of the token.\n    /// @return The address of the operator.\n    function getApproved(uint256 id) external view override returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @notice Check if the sender approved the operator.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function isApprovedForAll(address owner, address operator) external view override returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param id The id of the token.\n    /// @param data Additional data.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override {\n        _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(_msgSender(), from, to, id, data), \"ERC721_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @notice Check if the contract supports an interface.\n    /// 0x01ffc9a7 is ERC-165.\n    /// 0x80ac58cd is ERC-721\n    /// @param id The id of the interface.\n    /// @return Whether the interface is supported.\n    function supportsInterface(bytes4 id) public pure virtual override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /// @dev By overriding this function in an implementation which inherits this contract, you can enable versioned tokenIds without the extra overhead of writing to a new storage slot in _owners each time a version is incremented. See GameToken._storageId() for an example, where the storageId is the tokenId minus the version number.\n    /// !!! Caution !!! Overriding this function without taking appropriate care could lead to\n    /// ownerOf() returning an owner for non-existent tokens. Tests should be written to\n    /// guard against introducing this bug.\n    /// @param id The id of a token.\n    /// @return The id used for storage mappings.\n    function _storageId(uint256 id) internal view virtual returns (uint256) {\n        return id;\n    }\n\n    function _updateOwnerData(\n        uint256 id,\n        uint256 oldData,\n        address newOwner,\n        bool hasOperator\n    ) internal virtual {\n        if (hasOperator) {\n            _owners[_storageId(id)] = (oldData & NOT_ADDRESS) | OPERATOR_FLAG | uint256(uint160(newOwner));\n        } else {\n            _owners[_storageId(id)] = ((oldData & NOT_ADDRESS) & NOT_OPERATOR_FLAG) | uint256(uint160(newOwner));\n        }\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _updateOwnerData(id, _owners[_storageId(id)], to, false);\n        emit Transfer(from, to, id);\n    }\n\n    /// @dev See approveFor.\n    function _approveFor(\n        uint256 ownerData,\n        address operator,\n        uint256 id\n    ) internal {\n        address owner = address(uint160(ownerData));\n        if (operator == address(0)) {\n            _updateOwnerData(id, ownerData, owner, false);\n        } else {\n            _updateOwnerData(id, ownerData, owner, true);\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /// @dev See batchTransferFrom.\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        address msgSender = _msgSender();\n        bool authorized = msgSender == from || _superOperators[msgSender] || _operatorsForAll[from][msgSender];\n\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"BATCHTRANSFERFROM_NOT_OWNER\");\n            require(authorized || (operatorEnabled && _operators[id] == msgSender), \"NOT_AUTHORIZED\");\n            _updateOwnerData(id, _owners[_storageId(id)], to, false);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\n            require(_checkOnERC721BatchReceived(msgSender, from, to, ids, data), \"ERC721_BATCH_TRANSFER_REJECTED\");\n        }\n    }\n\n    /// @dev See setApprovalForAll.\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_APPROVAL_CHANGE\");\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /// @dev See burn.\n    function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) internal {\n        require(from == owner, \"NOT_OWNER\");\n        uint256 storageId = _storageId(id);\n        _owners[storageId] = (_owners[storageId] & NOT_OPERATOR_FLAG) | BURNED_FLAG; // record as non owner but keep track of last owner\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The adddress we want to transfer to.\n    /// @param tokenId The id of the token we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x150b7a02 is returned.\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 batch transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The adddress we want to transfer to.\n    /// @param ids The ids of the tokens we would like to transfer.\n    /// @param _data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x4b808c46 is returned.\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    /// @dev See ownerOf\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            return address(0);\n        }\n        return address(uint160(data));\n    }\n\n    /// @dev Get the owner and operatorEnabled status of a token.\n    /// @param id The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        virtual\n        returns (address owner, bool operatorEnabled)\n    {\n        uint256 data = _owners[_storageId(id)];\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\n            owner = address(0);\n        } else {\n            owner = address(uint160(data));\n        }\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n    }\n\n    /// @dev Check whether a transfer is a meta Transaction or not.\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\n    /// @param to The address recieving the token.\n    /// @param id The token being transferred.\n    /// @return isMetaTx Whether or not the transaction is a MetaTx.\n    function _checkTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        address msgSender = _msgSender();\n        require(owner != address(0), \"NONEXISTENT_TOKEN\");\n        require(owner == from, \"CHECKTRANSFER_NOT_OWNER\");\n        require(to != address(0), \"NOT_TO_ZEROADDRESS\");\n        require(\n            msgSender == owner ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender] ||\n                (operatorEnabled && _operators[id] == msgSender),\n            \"UNAUTHORIZED_TRANSFER\"\n        );\n        return true;\n    }\n\n    /// @dev Check if there was enough gas.\n    /// @param _contract The address of the contract to check.\n    /// @param interfaceId The id of the interface we want to test.\n    /// @return Whether or not this check succeeded.\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory callData = abi.encodeWithSelector(ERC165ID, interfaceId);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, callData)\n            let call_size := mload(callData)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/// @dev Note: The ERC-165 identifier for this interface is 0x5e8bf644.\ninterface IERC721MandatoryTokenReceiver {\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n\n    // needs to implements EIP-165\n    // function supportsInterface(bytes4 interfaceId)\n    //     external\n    //     view\n    //     returns (bool);\n}\n"
    },
    "src/solc_0.8/polygon/child/land/PolygonLandBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport \"../../../common/BaseWithStorage/ERC721BaseToken.sol\";\n\ncontract PolygonLandBaseToken is ERC721BaseToken {\n    using Address for address;\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() public view returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() public view returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() public view returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public view returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function x(uint256 id) public view returns (uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id % GRID_SIZE;\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function y(uint256 id) public view returns (uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id / GRID_SIZE;\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return string(abi.encodePacked(\"https://api.sandbox.game/lands/\", uint2str(id), \"/metadata.json\"));\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        bool metaTx = msg.sender != from && isTrustedForwarder(msg.sender);\n        if (msg.sender != from && !metaTx) {\n            require(\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        bool metaTx = msg.sender != from && isTrustedForwarder(msg.sender);\n        if (msg.sender != from && !metaTx) {\n            require(\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(metaTx ? from : msg.sender, from, to, size, x, y, data);\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        if (size == 1) {\n            uint256 id1x1 = x + y * GRID_SIZE;\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(uint160(address(to)));\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _idInPath(\n        uint256 i,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256) {\n        uint256 row = i / size;\n        if (row % 2 == 0) {\n            // alow ids to follow a path in a quad\n            return (x + (i % size)) + ((y + row) * GRID_SIZE);\n        } else {\n            return ((x + size) - (1 + (i % size))) + ((y + row) * GRID_SIZE);\n        }\n    }\n\n    function _regroup(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        if (size == 3) {\n            _regroup3x3(from, to, x, y, true);\n        } else if (size == 6) {\n            _regroup6x6(from, to, x, y, true);\n        } else if (size == 12) {\n            _regroup12x12(from, to, x, y, true);\n        } else if (size == 24) {\n            _regroup24x24(from, to, x, y, true);\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _regroup3x3(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_3x3 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 3; xi++) {\n            for (uint256 yi = y; yi < y + 3; yi++) {\n                ownerOfAll = _checkAndClear(from, xi + yi * GRID_SIZE) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(uint160(address(from))) ||\n                        _owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE] ==\n                        uint256(uint160(address(from))) ||\n                        _owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] ==\n                        uint256(uint160(address(from))) ||\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] ==\n                        uint256(uint160(address(from))),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup6x6(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_6x6 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 6; xi += 3) {\n            for (uint256 yi = y; yi < y + 6; yi += 3) {\n                bool ownAllIndividual = _regroup3x3(from, to, xi, yi, false);\n                uint256 id3x3 = LAYER_3x3 + xi + yi * GRID_SIZE;\n                uint256 owner3x3 = _owners[id3x3];\n                if (owner3x3 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner3x3 == uint256(uint160(address(from))), \"not owner of 3x3 quad\");\n                    }\n                    _owners[id3x3] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner3x3 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(uint160(address(from))) ||\n                        _owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] ==\n                        uint256(uint160(address(from))) ||\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] ==\n                        uint256(uint160(address(from))),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup12x12(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_12x12 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 12; xi += 6) {\n            for (uint256 yi = y; yi < y + 12; yi += 6) {\n                bool ownAllIndividual = _regroup6x6(from, to, xi, yi, false);\n                uint256 id6x6 = LAYER_6x6 + xi + yi * GRID_SIZE;\n                uint256 owner6x6 = _owners[id6x6];\n                if (owner6x6 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner6x6 == uint256(uint160(address(from))), \"not owner of 6x6 quad\");\n                    }\n                    _owners[id6x6] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner6x6 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(uint160(address(from))) ||\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] ==\n                        uint256(uint160(address(from))),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll;\n    }\n\n    function _regroup24x24(\n        address from,\n        address to,\n        uint256 x,\n        uint256 y,\n        bool set\n    ) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_24x24 + id;\n        bool ownerOfAll = true;\n        for (uint256 xi = x; xi < x + 24; xi += 12) {\n            for (uint256 yi = y; yi < y + 24; yi += 12) {\n                bool ownAllIndividual = _regroup12x12(from, to, xi, yi, false);\n                uint256 id12x12 = LAYER_12x12 + xi + yi * GRID_SIZE;\n                uint256 owner12x12 = _owners[id12x12];\n                if (owner12x12 != 0) {\n                    if (!ownAllIndividual) {\n                        require(owner12x12 == uint256(uint160(address(from))), \"not owner of 12x12 quad\");\n                    }\n                    _owners[id12x12] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner12x12 != 0) && ownerOfAll;\n            }\n        }\n        if (set) {\n            if (!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(uint160(address(from))),\n                    \"not owner of all sub quads not parent quad\"\n                );\n            }\n            _owners[quadId] = uint256(uint160(address(to)));\n            return true;\n        }\n        return ownerOfAll || _owners[quadId] == uint256(uint160(address(from)));\n    }\n\n    function _ownerOf(uint256 id) internal view override returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            return address(uint160(owner1x1)); //we check if the quad exists as an 1x1 quad, then 3x3, and so on..\n        } else {\n            address owner3x3 = address(uint160(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]));\n            if (owner3x3 != address(0)) {\n                return owner3x3;\n            } else {\n                address owner6x6 = address(uint160(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]));\n                if (owner6x6 != address(0)) {\n                    return owner6x6;\n                } else {\n                    address owner12x12 =\n                        address(uint160(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]));\n                    if (owner12x12 != address(0)) {\n                        return owner12x12;\n                    } else {\n                        return address(uint160(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]));\n                    }\n                }\n            }\n        }\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require(address(uint160(owner)) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id)\n        internal\n        view\n        override\n        returns (address owner, bool operatorEnabled)\n    {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            owner = address(uint160(owner1x1));\n            operatorEnabled = (owner1x1 / 2**255) == 1;\n        } else {\n            address owner3x3 = address(uint160(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]));\n            if (owner3x3 != address(uint160(0))) {\n                owner = owner3x3;\n                operatorEnabled = false;\n            } else {\n                address owner6x6 = address(uint160(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]));\n                if (owner6x6 != address(uint160(0))) {\n                    owner = owner6x6;\n                    operatorEnabled = false;\n                } else {\n                    address owner12x12 =\n                        address(uint160(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]));\n                    if (owner12x12 != address(uint160(0))) {\n                        owner = owner12x12;\n                        operatorEnabled = false;\n                    } else {\n                        owner = address(uint160(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]));\n                        operatorEnabled = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "src/solc_0.8/test/MockLandWithMint.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\npragma solidity 0.8.2;\n\nimport \"../polygon/child/land/PolygonLandBaseToken.sol\";\n\ncontract MockLandWithMint is PolygonLandBaseToken {\n    using Address for address;\n\n    /***\n     **\n     * @notice Mint a new quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external {\n        require(to != address(0), \"to is zero address\");\n        //require(isMinter(msg.sender), \"Only a minter can mint\");\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        uint256 quadId;\n        uint256 id = x + y * GRID_SIZE;\n\n        if (size == 1) {\n            quadId = id;\n        } else if (size == 3) {\n            quadId = LAYER_3x3 + id;\n        } else if (size == 6) {\n            quadId = LAYER_6x6 + id;\n        } else if (size == 12) {\n            quadId = LAYER_12x12 + id;\n        } else if (size == 24) {\n            quadId = LAYER_24x24 + id;\n        } else {\n            require(false, \"Invalid size\");\n        }\n\n        require(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] == 0, \"Already minted as 24x24\");\n\n        uint256 toX = x + size;\n        uint256 toY = y + size;\n        if (size <= 12) {\n            require(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] == 0, \"Already minted as 12x12\");\n        } else {\n            for (uint256 x12i = x; x12i < toX; x12i += 12) {\n                for (uint256 y12i = y; y12i < toY; y12i += 12) {\n                    uint256 id12x12 = LAYER_12x12 + x12i + y12i * GRID_SIZE;\n                    require(_owners[id12x12] == 0, \"Already minted as 12x12\");\n                }\n            }\n        }\n\n        if (size <= 6) {\n            require(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE] == 0, \"Already minted as 6x6\");\n        } else {\n            for (uint256 x6i = x; x6i < toX; x6i += 6) {\n                for (uint256 y6i = y; y6i < toY; y6i += 6) {\n                    uint256 id6x6 = LAYER_6x6 + x6i + y6i * GRID_SIZE;\n                    require(_owners[id6x6] == 0, \"Already minted as 6x6\");\n                }\n            }\n        }\n\n        if (size <= 3) {\n            require(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE] == 0, \"Already minted as 3x3\");\n        } else {\n            for (uint256 x3i = x; x3i < toX; x3i += 3) {\n                for (uint256 y3i = y; y3i < toY; y3i += 3) {\n                    uint256 id3x3 = LAYER_3x3 + x3i + y3i * GRID_SIZE;\n                    require(_owners[id3x3] == 0, \"Already minted as 3x3\");\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 idPath = _idInPath(i, size, x, y);\n            require(_owners[id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, idPath);\n        }\n\n        _owners[quadId] = uint256(uint160(address(to)));\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n}\n"
    },
    "src/solc_0.8/Utils/Batch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\n\ncontract Batch {\n    using Address for address;\n\n    struct Execution {\n        address target;\n        bytes callData;\n    }\n\n    struct ExecutionWithETH {\n        address target;\n        bytes callData;\n        uint256 value;\n    }\n\n    struct SingleTargetExecutionWithETH {\n        bytes callData;\n        uint256 value;\n    }\n\n    address public immutable executor;\n\n    constructor(address _executor) {\n        executor = _executor;\n    }\n\n    modifier onlyExecutor() {\n        require(msg.sender == executor, \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function atomicBatchWithETH(ExecutionWithETH[] calldata executions) external payable onlyExecutor {\n        for (uint256 i = 0; i < executions.length; i++) {\n            executions[i].target.functionCallWithValue(executions[i].callData, executions[i].value);\n        }\n    }\n\n    function nonAtomicBatchWithETH(ExecutionWithETH[] calldata executions) external payable onlyExecutor {\n        for (uint256 i = 0; i < executions.length; i++) {\n            _call(executions[i].target, executions[i].callData, executions[i].value);\n        }\n    }\n\n    function atomicBatch(Execution[] calldata executions) external onlyExecutor {\n        for (uint256 i = 0; i < executions.length; i++) {\n            executions[i].target.functionCall(executions[i].callData);\n        }\n    }\n\n    function nonAtomicBatch(Execution[] calldata executions) external onlyExecutor {\n        for (uint256 i = 0; i < executions.length; i++) {\n            _call(executions[i].target, executions[i].callData, 0);\n        }\n    }\n\n    function singleTargetAtomicBatchWithETH(address target, SingleTargetExecutionWithETH[] calldata executions)\n        external\n        payable\n        onlyExecutor\n    {\n        for (uint256 i = 0; i < executions.length; i++) {\n            target.functionCallWithValue(executions[i].callData, executions[i].value);\n        }\n    }\n\n    function singleTargetNonAtomicBatchWithETH(address target, SingleTargetExecutionWithETH[] calldata executions)\n        external\n        payable\n        onlyExecutor\n    {\n        for (uint256 i = 0; i < executions.length; i++) {\n            _call(target, executions[i].callData, executions[i].value);\n        }\n    }\n\n    function singleTargetAtomicBatch(address target, bytes[] calldata callDatas) external onlyExecutor {\n        for (uint256 i = 0; i < callDatas.length; i++) {\n            target.functionCall(callDatas[i]);\n        }\n    }\n\n    function singleTargetNonAtomicBatch(address target, bytes[] calldata callDatas) external onlyExecutor {\n        for (uint256 i = 0; i < callDatas.length; i++) {\n            _call(target, callDatas[i], 0);\n        }\n    }\n\n    function _call(\n        address target,\n        bytes calldata data,\n        uint256 value\n    ) internal returns (bool) {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call{value: value}(data);\n        return success;\n    }\n\n    // ----------------------------------------------------------------------------------------------------\n    // TOKEN RECEPTION\n    // ----------------------------------------------------------------------------------------------------\n\n    // ERC1155\n    bytes4 private constant ERC1155_IS_RECEIVER = 0x4e2312e0;\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return ERC1155_RECEIVED;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return ERC1155_BATCH_RECEIVED;\n    }\n\n    // ERC721\n\n    bytes4 private constant ERC721_IS_RECEIVER = 0x150b7a02;\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return ERC721_RECEIVED;\n    }\n\n    // ERC165\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return _interfaceId == 0x01ffc9a7 || _interfaceId == ERC1155_IS_RECEIVER || _interfaceId == ERC721_IS_RECEIVER;\n    }\n}\n"
    },
    "src/solc_0.8/test/FakeChildChainManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../polygon/child/asset/PolygonAssetV2.sol\";\nimport \"../polygon/child/sand/PolygonSand.sol\";\n\n/// @dev This is NOT a secure ChildChainManager contract implementation!\n/// DO NOT USE in production.\n\ncontract FakeChildChainManager {\n    address public polygonAsset;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() {}\n\n    function setPolygonAsset(address _polygonAsset) external {\n        polygonAsset = _polygonAsset;\n    }\n\n    function callDeposit(address user, bytes calldata depositData) external {\n        PolygonAssetV2(polygonAsset).deposit(user, depositData);\n    }\n\n    function callSandDeposit(\n        address polygonSand,\n        address user,\n        bytes calldata depositData\n    ) external {\n        PolygonSand(polygonSand).deposit(user, depositData);\n    }\n}\n"
    },
    "src/solc_0.8/polygon/child/asset/PolygonAssetV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport \"../../../asset/ERC1155ERC721.sol\";\nimport \"../../../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"../../../asset/libraries/AssetHelper.sol\";\n\ncontract PolygonAssetV2 is ERC1155ERC721 {\n    address private _childChainManager;\n    AssetHelper.AssetRegistryData private assetRegistryData;\n\n    event ChainExit(address indexed to, uint256[] tokenIds, uint256[] amounts, bytes data);\n\n    /// @notice fulfills the purpose of a constructor in upgradeabale contracts\n    function initialize(\n        address trustedForwarder,\n        address admin,\n        address bouncerAdmin,\n        address childChainManager,\n        uint8 chainIndex,\n        address assetRegistry\n    ) external {\n        initV2(trustedForwarder, admin, bouncerAdmin, address(0), chainIndex);\n        _childChainManager = childChainManager;\n        assetRegistryData.assetRegistry = IAssetAttributesRegistry(assetRegistry);\n    }\n\n    /// @notice called when tokens are deposited on root chain\n    /// @dev Should be callable only by ChildChainManager\n    /// @dev Should handle deposit by minting the required tokens for user\n    /// @dev Make sure minting is done only by this function\n    /// @param user user address for whom deposit is being done\n    /// @param depositData abi encoded ids array and amounts array\n    function deposit(address user, bytes calldata depositData) external {\n        require(_msgSender() == _childChainManager, \"!DEPOSITOR\");\n        require(user != address(0), \"INVALID_DEPOSIT_USER\");\n        (uint256[] memory ids, uint256[] memory amounts, bytes32[] memory hashes) =\n            AssetHelper.decodeAndSetCatalystDataL1toL2(assetRegistryData, depositData);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _metadataHash[ids[i] & ERC1155ERC721Helper.URI_ID] = hashes[i];\n            _rarityPacks[ids[i] & ERC1155ERC721Helper.URI_ID] = \"0x00\";\n            if ((ids[i] & ERC1155ERC721Helper.IS_NFT) > 0) {\n                _mintNFTFromAnotherLayer(user, ids[i]);\n            } else {\n                _mintFTFromAnotherLayer(amounts[i], user, ids[i]);\n            }\n        }\n        _completeMultiMint(_msgSender(), user, ids, amounts, depositData);\n    }\n\n    /// @notice called when user wants to withdraw tokens back to root chain\n    /// @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n    /// @param ids ids to withdraw\n    /// @param amounts amounts to withdraw\n    function withdraw(uint256[] calldata ids, uint256[] calldata amounts) external {\n        bytes32[] memory hashes = new bytes32[](ids.length);\n        IAssetAttributesRegistry.AssetGemsCatalystData[] memory gemsCatalystDatas =\n            AssetHelper.getGemsAndCatalystData(assetRegistryData, ids);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            hashes[i] = _metadataHash[ids[i] & ERC1155ERC721Helper.URI_ID];\n        }\n\n        if (ids.length == 1) {\n            _burn(_msgSender(), ids[0], amounts[0]);\n        } else {\n            _burnBatch(_msgSender(), ids, amounts);\n        }\n        emit ChainExit(_msgSender(), ids, amounts, abi.encode(hashes, gemsCatalystDatas));\n    }\n}\n"
    },
    "src/solc_0.8/polygon/child/sand/PolygonSand.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"../../../Sand/SandBaseToken.sol\";\n\ncontract PolygonSand is SandBaseToken, Ownable, ERC2771Handler {\n    address public childChainManagerProxy;\n\n    constructor(\n        address _childChainManagerProxy,\n        address trustedForwarder,\n        address sandAdmin,\n        address executionAdmin\n    ) SandBaseToken(sandAdmin, executionAdmin, address(0), 0) {\n        require(_childChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        childChainManagerProxy = _childChainManagerProxy;\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @notice update the ChildChainManager Proxy address\n    /// @param newChildChainManagerProxy address of the new childChainManagerProxy\n    function updateChildChainManager(address newChildChainManagerProxy) external onlyOwner {\n        require(newChildChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        childChainManagerProxy = newChildChainManagerProxy;\n    }\n\n    /// @notice called when tokens are deposited on root chain\n    /// @param user user address for whom deposit is being done\n    /// @param depositData abi encoded amount\n    function deposit(address user, bytes calldata depositData) external {\n        require(_msgSender() == childChainManagerProxy, \"You're not allowed to deposit\");\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /// @notice called when user wants to withdraw tokens back to root chain\n    /// @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n    /// @param amount amount to withdraw\n    function withdraw(uint256 amount) external {\n        _burn(_msgSender(), amount);\n    }\n\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "src/solc_0.8/asset/ERC1155ERC721.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport \"../common/interfaces/IERC1155.sol\";\nimport \"../common/interfaces/IERC1155TokenReceiver.sol\";\nimport \"../common/Libraries/ObjectLib32.sol\";\nimport \"../common/interfaces/IERC721.sol\";\nimport \"../common/interfaces/IERC721TokenReceiver.sol\";\nimport \"../common/BaseWithStorage/WithSuperOperators.sol\";\nimport \"./libraries/ERC1155ERC721Helper.sol\";\n\n// solhint-disable max-states-count\n// !!! DO NOT ADD MORE INHERITED CLASS !!!\n// This class is used by asset and is upgradable, if you add more INHERITED class, storage will be mixed up\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\ncontract ERC1155ERC721 is WithSuperOperators, IERC1155, IERC721 {\n    using Address for address;\n    using ObjectLib32 for ObjectLib32.Operations;\n    using ObjectLib32 for uint256;\n\n    bytes4 private constant ERC1155_IS_RECEIVER = 0x4e2312e0;\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n\n    mapping(address => uint256) private _numNFTPerAddress; // erc721\n    mapping(uint256 => uint256) private _owners; // erc721\n    mapping(address => mapping(uint256 => uint256)) private _packedTokenBalance; // erc1155\n    mapping(address => mapping(address => bool)) private _operatorsForAll; // erc721 and erc1155\n    mapping(uint256 => address) private _erc721operators; // erc721\n    mapping(uint256 => bytes32) internal _metadataHash; // erc721 and erc1155\n    mapping(uint256 => bytes) internal _rarityPacks; // rarity configuration per packs (2 bits per Asset)\n    mapping(uint256 => uint32) private _nextCollectionIndex; // extraction\n\n    mapping(address => address) private _creatorship; // creatorship transfer\n\n    mapping(address => bool) private _bouncers; // the contracts allowed to mint\n    // @note : Deprecated.\n    mapping(address => bool) private _metaTransactionContracts;\n\n    address private _bouncerAdmin;\n\n    bool internal _init;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n\n    uint256 internal _initBits;\n    address internal _predicate; // used in place of polygon's `PREDICATE_ROLE`\n\n    uint8 internal _chainIndex; // modify this for l2\n    uint256 private constant CHAIN_INDEX_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 1 - 32);\n    uint256 private constant CHAIN_INDEX_MASK = 0x00000000000000000000000000000000000000000000007F8000000000000000;\n\n    address internal _trustedForwarder;\n\n    uint256[20] private __gap;\n    // solhint-enable max-states-count\n\n    event BouncerAdminChanged(address oldBouncerAdmin, address newBouncerAdmin);\n    event Bouncer(address bouncer, bool enabled);\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n    event CreatorshipTransfer(address indexed original, address indexed from, address indexed to);\n    event Extraction(uint256 indexed fromId, uint256 toId);\n    event AssetUpdate(uint256 indexed fromId, uint256 toId);\n\n    function initV2(\n        address trustedForwarder,\n        address admin,\n        address bouncerAdmin,\n        address predicate,\n        uint8 chainIndex\n    ) public {\n        // one-time init of bitfield's previous versions\n        _checkInit(0);\n        _admin = admin;\n        _bouncerAdmin = bouncerAdmin;\n        _predicate = predicate;\n        __ERC2771Handler_initialize(trustedForwarder);\n        _chainIndex = chainIndex;\n    }\n\n    /// @notice Change the minting administrator to be `newBouncerAdmin`.\n    /// @param newBouncerAdmin address of the new minting administrator.\n    function changeBouncerAdmin(address newBouncerAdmin) external {\n        require(_msgSender() == _bouncerAdmin, \"!BOUNCER_ADMIN\");\n        emit BouncerAdminChanged(_bouncerAdmin, newBouncerAdmin);\n        _bouncerAdmin = newBouncerAdmin;\n    }\n\n    /// @notice Enable or disable the ability of `bouncer` to mint tokens (minting bouncer rights).\n    /// @param bouncer address that will be given/removed minting bouncer rights.\n    /// @param enabled set whether the address is enabled or disabled as a minting bouncer.\n    function setBouncer(address bouncer, bool enabled) external {\n        require(_msgSender() == _bouncerAdmin, \"!BOUNCER_ADMIN\");\n        _bouncers[bouncer] = enabled;\n        emit Bouncer(bouncer, enabled);\n    }\n\n    /// @notice Mint a token type for `creator` on slot `packId`.\n    /// @param creator address of the creator of the token.\n    /// @param packId unique packId for that token.\n    /// @param hash hash of an IPFS cidv1 folder that contains the metadata of the token type in the file 0.json.\n    /// @param supply number of tokens minted for that token type.\n    /// @param rarity rarity power of the token.\n    /// @param owner address that will receive the tokens.\n    /// @param data extra data to accompany the minting call.\n    /// @return id the id of the newly minted token type.\n    function mint(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256 supply,\n        uint8 rarity,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256 id) {\n        require(hash != 0, \"HASH==0\");\n        require(_bouncers[_msgSender()], \"!BOUNCER\");\n        require(owner != address(0), \"TO==0\");\n        id = _generateTokenId(creator, supply, packId, supply == 1 ? 0 : 1, 0);\n        _mint(hash, supply, rarity, _msgSender(), owner, id, data, false);\n    }\n\n    /// @notice Mint multiple token types for `creator` on slot `packId`.\n    /// @param creator address of the creator of the tokens.\n    /// @param packId unique packId for the tokens.\n    /// @param hash hash of an IPFS cidv1 folder that contains the metadata of each token type in the files: 0.json, 1.json, 2.json, etc...\n    /// @param supplies number of tokens minted for each token type.\n    /// @param rarityPack rarity power of each token types packed into 2 bits each.\n    /// @param owner address that will receive the tokens.\n    /// @param data extra data to accompany the minting call.\n    /// @return ids the ids of each newly minted token types.\n    function mintMultiple(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256[] calldata supplies,\n        bytes calldata rarityPack,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256[] memory ids) {\n        require(hash != 0, \"HASH==0\");\n        require(_bouncers[_msgSender()], \"!BOUNCER\");\n        require(owner != address(0), \"TO==0\");\n        uint16 numNFTs;\n        (ids, numNFTs) = _allocateIds(creator, supplies, rarityPack, packId, hash);\n        _mintBatches(supplies, owner, ids, numNFTs);\n        _completeMultiMint(_msgSender(), owner, ids, supplies, data);\n    }\n\n    /// @notice Transfers `value` tokens of type `id` from  `from` to `to`  (with safety call).\n    /// @param from address from which tokens are transfered.\n    /// @param to address to which the token will be transfered.\n    /// @param id the token type transfered.\n    /// @param value amount of token transfered.\n    /// @param data aditional data accompanying the transfer.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        if (id & ERC1155ERC721Helper.IS_NFT > 0) {\n            require(_ownerOf(id) == from, \"OWNER!=FROM\");\n        }\n        bool metaTx = _transferFrom(from, to, id, value);\n        require(\n            _checkERC1155AndCallSafeTransfer(metaTx ? from : msg.sender, from, to, id, value, data, false, false),\n            \"1155_TRANSFER_REJECTED\"\n        );\n    }\n\n    /// @notice Transfers `values` tokens of type `ids` from  `from` to `to` (with safety call).\n    /// @dev call data should be optimized to order ids so packedBalance can be used efficiently.\n    /// @param from address from which tokens are transfered.\n    /// @param to address to which the token will be transfered.\n    /// @param ids ids of each token type transfered.\n    /// @param values amount of each token type transfered.\n    /// @param data aditional data accompanying the transfer.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override {\n        // @review should we also check the length of data.URIs[] if we use something like that?\n        // not sure if we want to try to set/update all URIs at once(both for newly-minted tokens & unlock tokens? Or do we rely on a second TX to update URIs for tokens that were locked in the predicate and may have new metaData from L2 to be set?)\n        // metadataHash updates only applicable to erc721 tokens\n        require(ids.length == values.length, \"MISMATCHED_ARR_LEN\");\n        require(to != address(0), \"TO==0\");\n        require(from != address(0), \"FROM==0\");\n        bool metaTx = isTrustedForwarder(msg.sender);\n        bool authorized = from == _msgSender() || isApprovedForAll(from, _msgSender());\n\n        _batchTransferFrom(from, to, ids, values, authorized);\n        emit TransferBatch(metaTx ? from : _msgSender(), from, to, ids, values);\n        require(\n            _checkERC1155AndCallSafeBatchTransfer(metaTx ? from : _msgSender(), from, to, ids, values, data),\n            \"1155_TRANSFER_REJECTED\"\n        );\n    }\n\n    /// @notice Transfers creatorship of `original` from `sender` to `to`.\n    /// @param sender address of current registered creator.\n    /// @param original address of the original creator whose creation are saved in the ids themselves.\n    /// @param to address which will be given creatorship for all tokens originally minted by `original`.\n    function transferCreatorship(\n        address sender,\n        address original,\n        address to\n    ) external {\n        require(sender == _msgSender() || _superOperators[_msgSender()], \"!AUTHORIZED\");\n        require(sender != address(0), \"SENDER==0\");\n        require(to != address(0), \"TO==0\");\n        address current = _creatorship[original];\n        if (current == address(0)) {\n            current = original;\n        }\n        require(current != to, \"CURRENT==TO\");\n        require(current == sender, \"CURRENT!=SENDER\");\n        if (to == original) {\n            _creatorship[original] = address(0);\n        } else {\n            _creatorship[original] = to;\n        }\n        emit CreatorshipTransfer(original, current, to);\n    }\n\n    /// @notice Enable or disable approval for `operator` to manage all `sender`'s tokens.\n    /// @dev used for Meta Transaction (from metaTransactionContract).\n    /// @param sender address which grant approval.\n    /// @param operator address which will be granted rights to transfer all token owned by `sender`.\n    /// @param approved whether to approve or revoke.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender == _msgSender() || _superOperators[_msgSender()], \"!AUTHORIZED\");\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice Enable or disable approval for `operator` to manage all of the caller's tokens.\n    /// @param operator address which will be granted rights to transfer all tokens of the caller.\n    /// @param approved whether to approve or revoke\n    function setApprovalForAll(address operator, bool approved) external override(IERC1155, IERC721) {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @notice Change or reaffirm the approved address for an NFT.\n    /// @param operator the address to approve as NFT controller.\n    /// @param id the id of the NFT to approve.\n    function approve(address operator, uint256 id) external override {\n        require(_ownerOf(id) != address(0), \"NFT_!EXIST\");\n        require(_ownerOf(id) == _msgSender() || isApprovedForAll(_ownerOf(id), _msgSender()), \"!AUTHORIZED\");\n        _erc721operators[id] = operator;\n        emit Approval(_ownerOf(id), operator, id);\n    }\n\n    /// @notice Transfers ownership of an NFT.\n    /// @param from the current owner of the NFT.\n    /// @param to the new owner.\n    /// @param id the NFT to transfer.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external override {\n        require(_ownerOf(id) == from, \"OWNER!=FROM\");\n        bool metaTx = _transferFrom(from, to, id, 1);\n        require(\n            _checkERC1155AndCallSafeTransfer(metaTx ? from : _msgSender(), from, to, id, 1, \"\", true, false),\n            \"1155_TRANSFER_REJECTED\"\n        );\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address.\n    /// @param from the current owner of the NFT.\n    /// @param to the new owner.\n    /// @param id the NFT to transfer.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external override {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /// @notice Burns `amount` tokens of type `id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token type which will be burnt.\n    /// @param amount amount of token to burn.\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(from == _msgSender() || isApprovedForAll(from, _msgSender()), \"!AUTHORIZED\");\n        _burn(from, id, amount);\n    }\n\n    /// @notice Upgrades an NFT with new metadata and rarity.\n    /// @param from address which own the NFT to be upgraded.\n    /// @param id the NFT that will be burnt to be upgraded.\n    /// @param packId unqiue packId for the token.\n    /// @param hash hash of an IPFS cidv1 folder that contains the metadata of the new token type in the file 0.json.\n    /// @param newRarity rarity power of the new NFT.\n    /// @param to address which will receive the NFT.\n    /// @param data bytes to be transmitted as part of the minted token.\n    /// @return the id of the newly minted NFT.\n    function updateERC721(\n        address from,\n        uint256 id,\n        uint40 packId,\n        bytes32 hash,\n        uint8 newRarity,\n        address to,\n        bytes calldata data\n    ) external returns (uint256) {\n        require(hash != 0, \"HASH==0\");\n        require(_bouncers[_msgSender()], \"!BOUNCER\");\n        require(to != address(0), \"TO==0\");\n        require(from != address(0), \"FROM==0\");\n\n        _burnERC721(_msgSender(), from, id);\n\n        uint256 newId = _generateTokenId(from, 1, packId, 0, 0);\n        _mint(hash, 1, newRarity, _msgSender(), to, newId, data, false);\n        emit AssetUpdate(id, newId);\n        return newId;\n    }\n\n    /// @notice Extracts an EIP-721 NFT from an EIP-1155 token.\n    /// @param sender address which own the token to be extracted.\n    /// @param id the token type to extract from.\n    /// @param to address which will receive the token.\n    /// @return newId the id of the newly minted NFT.\n    function extractERC721From(\n        address sender,\n        uint256 id,\n        address to\n    ) external returns (uint256 newId) {\n        bool metaTx = isTrustedForwarder(msg.sender);\n        require(sender == _msgSender() || isApprovedForAll(sender, _msgSender()), \"!AUTHORIZED\");\n        return _extractERC721From(metaTx ? sender : _msgSender(), sender, id, to);\n    }\n\n    /// @notice Returns the current administrator in charge of minting rights.\n    /// @return the current minting administrator in charge of minting rights.\n    function getBouncerAdmin() external view returns (address) {\n        return _bouncerAdmin;\n    }\n\n    /// @notice check whether address `who` is given minting bouncer rights.\n    /// @param who The address to query.\n    /// @return whether the address has minting rights.\n    function isBouncer(address who) external view returns (bool) {\n        return _bouncers[who];\n    }\n\n    /// @notice Get the balance of `owners` for each token type `ids`.\n    /// @param owners the addresses of the token holders queried.\n    /// @param ids ids of each token type to query.\n    /// @return the balance of each `owners` for each token type `ids`.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(owners.length == ids.length, \"ARG_LENGTH_MISMATCH\");\n        uint256[] memory balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n        return balances;\n    }\n\n    /// @notice Get the creator of the token type `id`.\n    /// @param id the id of the token to get the creator of.\n    /// @return the creator of the token type `id`.\n    function creatorOf(uint256 id) external view returns (address) {\n        require(wasEverMinted(id), \"TOKEN_!MINTED\");\n        address newCreator = _creatorship[address(uint160(id / ERC1155ERC721Helper.CREATOR_OFFSET_MULTIPLIER))];\n        if (newCreator != address(0)) {\n            return newCreator;\n        }\n        return address(uint160(id / ERC1155ERC721Helper.CREATOR_OFFSET_MULTIPLIER));\n    }\n\n    /// @notice Count all NFTs assigned to `owner`.\n    /// @param owner address for whom to query the balance.\n    /// @return balance the number of NFTs owned by `owner`, possibly zero.\n    function balanceOf(address owner) external view override returns (uint256 balance) {\n        require(owner != address(0), \"OWNER==0\");\n        return _numNFTPerAddress[owner];\n    }\n\n    /// @notice Find the owner of an NFT.\n    /// @param id the identifier for an NFT.\n    /// @return owner the address of the owner of the NFT.\n    function ownerOf(uint256 id) external view override returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"NFT_!EXIST\");\n    }\n\n    /// @notice Get the approved address for a single NFT.\n    /// @param id the NFT to find the approved address for.\n    /// @return operator the approved address for this NFT, or the zero address if there is none.\n    function getApproved(uint256 id) external view override returns (address operator) {\n        require(_ownerOf(id) != address(0), \"NFT_!EXIST\");\n        return _erc721operators[id];\n    }\n\n    /// @notice check whether a packId/numFT tupple has been used\n    /// @param creator for which creator\n    /// @param packId the packId to check\n    /// @param numFTs number of Fungible Token in that pack (can reuse packId if different)\n    /// @return whether the pack has already been used\n    function isPackIdUsed(\n        address creator,\n        uint40 packId,\n        uint16 numFTs\n    ) external view returns (bool) {\n        return\n            _metadataHash[\n                uint256(uint160(creator)) *\n                    ERC1155ERC721Helper.CREATOR_OFFSET_MULTIPLIER + // CREATOR\n                    uint256(packId) *\n                    ERC1155ERC721Helper.PACK_ID_OFFSET_MULTIPLIER + // packId (unique pack) // ERC1155ERC721Helper.URI_ID\n                    numFTs *\n                    ERC1155ERC721Helper.PACK_NUM_FT_TYPES_OFFSET_MULTIPLIER\n            ] != 0;\n    }\n\n    /// @notice A descriptive name for the collection of tokens in this contract.\n    /// @return _name the name of the tokens.\n    function name() external pure returns (string memory _name) {\n        return \"Sandbox's ASSETs\";\n    }\n\n    /// @notice An abbreviated name for the collection of tokens in this contract.\n    /// @return _symbol the symbol of the tokens.\n    function symbol() external pure returns (string memory _symbol) {\n        return \"ASSET\";\n    }\n\n    /// @notice Query if a contract implements interface `id`.\n    /// @param id the interface identifier, as specified in ERC-165.\n    /// @return `true` if the contract implements `id`.\n    function supportsInterface(bytes4 id) external pure override returns (bool) {\n        return\n            id == 0x01ffc9a7 || //ERC165\n            id == 0xd9b67a26 || // ERC1155\n            id == 0x80ac58cd || // ERC721\n            id == 0x5b5e139f || // ERC721 metadata\n            id == 0x0e89341c; // ERC1155 metadata\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address.\n    /// @param from the current owner of the NFT.\n    /// @param to the new owner.\n    /// @param id the NFT to transfer.\n    /// @param data additional data with no specified format, sent in call to `to`.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override {\n        require(_ownerOf(id) == from, \"OWNER!=FROM\");\n        bool metaTx = _transferFrom(from, to, id, 1);\n        require(\n            _checkERC1155AndCallSafeTransfer(metaTx ? from : _msgSender(), from, to, id, 1, data, true, true),\n            \"721/1155_TRANSFER_REJECTED\"\n        );\n    }\n\n    /// @notice Gives the collection a specific token belongs to.\n    /// @param id the token to get the collection of.\n    /// @return the collection the NFT is part of.\n    function collectionOf(uint256 id) public view returns (uint256) {\n        require(_ownerOf(id) != address(0), \"NFT_!EXIST\");\n        uint256 collectionId = id & ERC1155ERC721Helper.NOT_NFT_INDEX & ERC1155ERC721Helper.NOT_IS_NFT;\n        require(wasEverMinted(collectionId), \"UNMINTED_COLLECTION\");\n        return collectionId;\n    }\n\n    /// @notice Return wether the id is a collection\n    /// @param id collectionId to check.\n    /// @return whether the id is a collection.\n    function isCollection(uint256 id) public view returns (bool) {\n        uint256 collectionId = id & ERC1155ERC721Helper.NOT_NFT_INDEX & ERC1155ERC721Helper.NOT_IS_NFT;\n        return wasEverMinted(collectionId);\n    }\n\n    /// @notice Gives the index at which an NFT was minted in a collection : first of a collection get the zero index.\n    /// @param id the token to get the index of.\n    /// @return the index/order at which the token `id` was minted in a collection.\n    function collectionIndexOf(uint256 id) public view returns (uint256) {\n        collectionOf(id); // this check if id and collection indeed was ever minted\n        return uint32((id & ERC1155ERC721Helper.NFT_INDEX) >> ERC1155ERC721Helper.NFT_INDEX_OFFSET);\n    }\n\n    function wasEverMinted(uint256 id) public view returns (bool) {\n        if ((id & ERC1155ERC721Helper.IS_NFT) > 0) {\n            return _owners[id] != 0;\n        } else {\n            return\n                ((id & ERC1155ERC721Helper.PACK_INDEX) <\n                    ((id & ERC1155ERC721Helper.PACK_NUM_FT_TYPES) /\n                        ERC1155ERC721Helper.PACK_NUM_FT_TYPES_OFFSET_MULTIPLIER)) &&\n                _metadataHash[id & ERC1155ERC721Helper.URI_ID] != 0;\n        }\n    }\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// This supports both erc721 & erc1155 tokens.\n    /// @param id token to get the uri of.\n    /// @return URI string\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0) || wasEverMinted(id), \"NFT_!EXIST_||_FT_!MINTED\");\n        return ERC1155ERC721Helper.toFullURI(_metadataHash[id & ERC1155ERC721Helper.URI_ID], id);\n    }\n\n    /// @notice Get the balance of `owner` for the token type `id`.\n    /// @param owner The address of the token holder.\n    /// @param id the token type of which to get the balance of.\n    /// @return the balance of `owner` for the token type `id`.\n    function balanceOf(address owner, uint256 id) public view override returns (uint256) {\n        // do not check for existence, balance is zero if never minted\n        // require(wasEverMinted(id), \"token was never minted\");\n        if (id & ERC1155ERC721Helper.IS_NFT > 0) {\n            if (_ownerOf(id) == owner) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }\n\n    /// @notice Queries the approval status of `operator` for owner `owner`.\n    /// @param owner the owner of the tokens.\n    /// @param operator address of authorized operator.\n    /// @return isOperator true if the operator is approved, false if not.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override(IERC1155, IERC721)\n        returns (bool isOperator)\n    {\n        require(owner != address(0), \"OWNER==0\");\n        require(operator != address(0), \"OPERATOR==0\");\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function __ERC2771Handler_initialize(address forwarder) internal {\n        _trustedForwarder = forwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function getTrustedForwarder() external view returns (address trustedForwarder) {\n        return _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(sender != address(0), \"SENDER==0\");\n        require(sender != operator, \"SENDER==OPERATOR\");\n        require(operator != address(0), \"OPERATOR==0\");\n        require(!_superOperators[operator], \"APPR_EXISTING_SUPEROPERATOR\");\n        _operatorsForAll[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /* solhint-disable code-complexity */\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bool authorized\n    ) internal {\n        uint256 numItems = ids.length;\n        uint256 bin;\n        uint256 index;\n        uint256 balFrom;\n        uint256 balTo;\n\n        uint256 lastBin;\n        uint256 numNFTs = 0;\n        for (uint256 i = 0; i < numItems; i++) {\n            if (ids[i] & ERC1155ERC721Helper.IS_NFT > 0) {\n                require(authorized || _erc721operators[ids[i]] == _msgSender(), \"OPERATOR_!AUTH\");\n                if (values[i] > 0) {\n                    require(values[i] == 1, \"NFT!=1\");\n                    require(_ownerOf(ids[i]) == from, \"OWNER!=FROM\");\n                    numNFTs++;\n                    _owners[ids[i]] = uint256(uint160(to));\n                    if (_erc721operators[ids[i]] != address(0)) {\n                        // TODO operatorEnabled flag optimization (like in ERC721BaseToken)\n                        _erc721operators[ids[i]] = address(0);\n                    }\n                    emit Transfer(from, to, ids[i]);\n                }\n            } else {\n                require(authorized, \"OPERATOR_!AUTH\");\n                if (from == to) {\n                    _checkEnoughBalance(from, ids[i], values[i]);\n                } else if (values[i] > 0) {\n                    (bin, index) = ids[i].getTokenBinIndex();\n                    if (lastBin == 0) {\n                        lastBin = bin;\n                        balFrom = ObjectLib32.updateTokenBalance(\n                            _packedTokenBalance[from][bin],\n                            index,\n                            values[i],\n                            ObjectLib32.Operations.SUB\n                        );\n                        balTo = ObjectLib32.updateTokenBalance(\n                            _packedTokenBalance[to][bin],\n                            index,\n                            values[i],\n                            ObjectLib32.Operations.ADD\n                        );\n                    } else {\n                        if (bin != lastBin) {\n                            _packedTokenBalance[from][lastBin] = balFrom;\n                            _packedTokenBalance[to][lastBin] = balTo;\n                            balFrom = _packedTokenBalance[from][bin];\n                            balTo = _packedTokenBalance[to][bin];\n                            lastBin = bin;\n                        }\n\n                        balFrom = balFrom.updateTokenBalance(index, values[i], ObjectLib32.Operations.SUB);\n                        balTo = balTo.updateTokenBalance(index, values[i], ObjectLib32.Operations.ADD);\n                    }\n                }\n            }\n        }\n        if (numNFTs > 0 && from != to) {\n            _numNFTPerAddress[from] -= numNFTs;\n            _numNFTPerAddress[to] += numNFTs;\n        }\n\n        if (bin != 0 && from != to) {\n            _packedTokenBalance[from][bin] = balFrom;\n            _packedTokenBalance[to][bin] = balTo;\n        }\n    }\n\n    /* solhint-enable code-complexity */\n\n    function _checkERC1155AndCallSafeTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data,\n        bool erc721,\n        bool erc721Safe\n    ) internal returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        if (erc721) {\n            if (!_checkIsERC1155Receiver(to)) {\n                if (erc721Safe) {\n                    return _checkERC721AndCallSafeTransfer(operator, from, to, id, data);\n                } else {\n                    return true;\n                }\n            }\n        }\n        return IERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) == ERC1155_RECEIVED;\n    }\n\n    function _checkERC1155AndCallSafeBatchTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes4 retval = IERC1155TokenReceiver(to).onERC1155BatchReceived(operator, from, ids, values, data);\n        return (retval == ERC1155_BATCH_RECEIVED);\n    }\n\n    function _checkERC721AndCallSafeTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal returns (bool) {\n        // following not required as this function is always called as part of ERC1155 checks that include such check already\n        // if (!to.isContract()) {\n        //     return true;\n        // }\n        return (IERC721TokenReceiver(to).onERC721Received(operator, from, id, data) == ERC721_RECEIVED);\n    }\n\n    function _burnERC1155(\n        address operator,\n        address from,\n        uint256 id,\n        uint32 amount\n    ) internal {\n        (uint256 bin, uint256 index) = (id).getTokenBinIndex();\n        _packedTokenBalance[from][bin] = _packedTokenBalance[from][bin].updateTokenBalance(\n            index,\n            amount,\n            ObjectLib32.Operations.SUB\n        );\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnERC721(\n        address operator,\n        address from,\n        uint256 id\n    ) internal {\n        require(from == _ownerOf(id), \"OWNER!=FROM\");\n        _owners[id] = 2**160; // equivalent to zero address when casted but ensure we track minted status\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n        emit TransferSingle(operator, from, address(0), id, 1);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        address sender = _msgSender();\n        if ((id & ERC1155ERC721Helper.IS_NFT) > 0) {\n            require(amount == 1, \"AMOUNT!=1\");\n            _burnERC721(isTrustedForwarder(msg.sender) ? from : sender, from, id);\n        } else {\n            require(amount > 0 && amount <= ERC1155ERC721Helper.MAX_SUPPLY, \"INVALID_AMOUNT\");\n            _burnERC1155(isTrustedForwarder(msg.sender) ? from : sender, from, id, uint32(amount));\n        }\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        address operator = isTrustedForwarder(msg.sender) ? from : _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            if ((ids[i] & ERC1155ERC721Helper.IS_NFT) > 0) {\n                require(amounts[i] == 1, \"amounts[i]!=1\");\n                require(from == _ownerOf(ids[i]), \"OWNER!=FROM\");\n                _owners[ids[i]] = 2**160; // equivalent to zero address when casted but ensure we track minted status\n                _numNFTPerAddress[from]--;\n                emit Transfer(from, address(0), ids[i]);\n            } else {\n                require(amounts[i] > 0 && amounts[i] <= ERC1155ERC721Helper.MAX_SUPPLY, \"INVALID_AMOUNT\");\n                (uint256 bin, uint256 index) = (ids[i]).getTokenBinIndex();\n                _packedTokenBalance[from][bin] = _packedTokenBalance[from][bin].updateTokenBalance(\n                    index,\n                    amounts[i],\n                    ObjectLib32.Operations.SUB\n                );\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _allocateIds(\n        address creator,\n        uint256[] memory supplies,\n        bytes memory rarityPack,\n        uint40 packId,\n        bytes32 hash\n    ) internal returns (uint256[] memory ids, uint16 numNFTs) {\n        require(supplies.length > 0, \"SUPPLIES<=0\");\n        require(supplies.length <= ERC1155ERC721Helper.MAX_PACK_SIZE, \"BATCH_TOO_BIG\");\n        (ids, numNFTs) = _generateTokenIds(creator, supplies, packId);\n\n        require(uint256(_metadataHash[ids[0] & ERC1155ERC721Helper.URI_ID]) == 0, \"ID_TAKEN\");\n        _metadataHash[ids[0] & ERC1155ERC721Helper.URI_ID] = hash;\n        _rarityPacks[ids[0] & ERC1155ERC721Helper.URI_ID] = rarityPack;\n    }\n\n    function _completeMultiMint(\n        address operator,\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory supplies,\n        bytes memory data\n    ) internal {\n        emit TransferBatch(operator, address(0), owner, ids, supplies);\n        require(\n            _checkERC1155AndCallSafeBatchTransfer(operator, address(0), owner, ids, supplies, data),\n            \"TRANSFER_REJECTED\"\n        );\n    }\n\n    function _mintBatches(\n        uint256[] memory supplies,\n        address owner,\n        uint256[] memory ids,\n        uint16 numNFTs\n    ) internal {\n        uint16 offset = 0;\n        while (offset < supplies.length - numNFTs) {\n            _mintBatch(offset, supplies, owner, ids);\n            offset += 8;\n        }\n        // deal with NFT last. they do not care of balance packing\n        if (numNFTs > 0) {\n            _mintNFTs(uint16(supplies.length - numNFTs), numNFTs, owner, ids);\n        }\n    }\n\n    function _mintNFTs(\n        uint16 offset,\n        uint16 numNFTs,\n        address owner,\n        uint256[] memory ids\n    ) internal {\n        for (uint256 i = 0; i < numNFTs; i++) {\n            uint256 id = ids[i + offset];\n            _owners[id] = uint256(uint160(owner));\n            emit Transfer(address(0), owner, id);\n        }\n        _numNFTPerAddress[owner] += numNFTs;\n    }\n\n    function _mintBatch(\n        uint16 offset,\n        uint256[] memory supplies,\n        address owner,\n        uint256[] memory ids\n    ) internal {\n        (uint256 bin, uint256 index) = ids[offset].getTokenBinIndex();\n        for (uint256 i = 0; i < 8 && offset + i < supplies.length; i++) {\n            uint256 j = offset + i;\n            if (supplies[j] > 1) {\n                _packedTokenBalance[owner][bin] = _packedTokenBalance[owner][bin].updateTokenBalance(\n                    index + i,\n                    supplies[j],\n                    ObjectLib32.Operations.ADD\n                );\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// @dev Use only when you mint from L1 to L2\n    function _mintFTFromAnotherLayer(\n        uint256 supply,\n        address owner,\n        uint256 id\n    ) internal {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n\n        _packedTokenBalance[owner][bin] = _packedTokenBalance[owner][bin].updateTokenBalance(\n            index,\n            supply,\n            ObjectLib32.Operations.ADD\n        );\n    }\n\n    function _mintNFTFromAnotherLayer(address owner, uint256 id) internal {\n        _owners[id] = uint256(uint160(owner));\n        _numNFTPerAddress[owner]++;\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal returns (bool metaTx) {\n        require(to != address(0), \"TO==0\");\n        require(from != address(0), \"FROM==0\");\n        address sender = _msgSender();\n        metaTx = isTrustedForwarder(msg.sender);\n        bool authorized = from == sender || isApprovedForAll(from, sender);\n\n        if (id & ERC1155ERC721Helper.IS_NFT > 0) {\n            require(authorized || _erc721operators[id] == sender, \"OPERATOR_!AUTH\");\n            if (value > 0) {\n                require(value == 1, \"NFT!=1\");\n                _numNFTPerAddress[from]--;\n                _numNFTPerAddress[to]++;\n                _owners[id] = uint256(uint160(to));\n                if (_erc721operators[id] != address(0)) {\n                    _erc721operators[id] = address(0);\n                }\n                emit Transfer(from, to, id);\n            }\n        } else {\n            require(authorized, \"OPERATOR_!AUTH\");\n            if (value > 0) {\n                // if different owners it will fails\n                (uint256 bin, uint256 index) = id.getTokenBinIndex();\n                _packedTokenBalance[from][bin] = _packedTokenBalance[from][bin].updateTokenBalance(\n                    index,\n                    value,\n                    ObjectLib32.Operations.SUB\n                );\n                _packedTokenBalance[to][bin] = _packedTokenBalance[to][bin].updateTokenBalance(\n                    index,\n                    value,\n                    ObjectLib32.Operations.ADD\n                );\n            }\n        }\n\n        emit TransferSingle(metaTx ? from : sender, from, to, id, value);\n    }\n\n    function _extractERC721From(\n        address operator,\n        address sender,\n        uint256 id,\n        address to\n    ) internal returns (uint256 newId) {\n        require(to != address(0), \"TO==0\");\n        require(id & ERC1155ERC721Helper.IS_NFT == 0, \"!1155\");\n        uint32 tokenCollectionIndex = _nextCollectionIndex[id];\n        newId = id + ERC1155ERC721Helper.IS_NFT + (tokenCollectionIndex) * 2**ERC1155ERC721Helper.NFT_INDEX_OFFSET;\n        _nextCollectionIndex[id] = tokenCollectionIndex + 1;\n        _burnERC1155(operator, sender, id, 1);\n        _mint(_metadataHash[id & ERC1155ERC721Helper.URI_ID], 1, 0, operator, to, newId, \"\", true);\n        emit Extraction(id, newId);\n    }\n\n    function _mint(\n        bytes32 hash,\n        uint256 supply,\n        uint8 rarity,\n        address operator,\n        address owner,\n        uint256 id,\n        bytes memory data,\n        bool extraction\n    ) internal {\n        uint256 uriId = id & ERC1155ERC721Helper.URI_ID;\n        if (!extraction) {\n            require(uint256(_metadataHash[uriId]) == 0, \"ID_TAKEN\");\n            _metadataHash[uriId] = hash;\n            require(rarity < 4, \"RARITY>=4\");\n            bytes memory pack = new bytes(1);\n            pack[0] = bytes1(rarity * 64);\n            _rarityPacks[uriId] = pack;\n        }\n        if (supply == 1) {\n            // ERC721\n            _numNFTPerAddress[owner]++;\n            _owners[id] = uint256(uint160(owner));\n            emit Transfer(address(0), owner, id);\n        } else {\n            (uint256 bin, uint256 index) = id.getTokenBinIndex();\n            _packedTokenBalance[owner][bin] = _packedTokenBalance[owner][bin].updateTokenBalance(\n                index,\n                supply,\n                ObjectLib32.Operations.REPLACE\n            );\n        }\n\n        emit TransferSingle(operator, address(0), owner, id, supply);\n        require(\n            _checkERC1155AndCallSafeTransfer(operator, address(0), owner, id, supply, data, false, false),\n            \"TRANSFER_REJECTED\"\n        );\n    }\n\n    /// @dev Allows the use of a bitfield to track the initialized status of the version `v` passed in as an arg.\n    /// If the bit at the index corresponding to the given version is already set, revert.\n    /// Otherwise, set the bit and return.\n    /// @param v The version of this contract.\n    function _checkInit(uint256 v) internal {\n        require((_initBits >> v) & uint256(1) != 1, \"ALREADY_INITIALISED\");\n        _initBits = _initBits | (uint256(1) << v);\n    }\n\n    function _checkIsERC1155Receiver(address _contract) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory callData = abi.encodeWithSelector(ERC165ID, ERC1155_IS_RECEIVER);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, callData)\n            let call_size := mload(callData)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    function _checkEnoughBalance(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal view {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        require(_packedTokenBalance[from][bin].getValueInBin(index) >= value, \"BALANCE_TOO_LOW\");\n    }\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(uint160(_owners[id]));\n    }\n\n    function _generateTokenId(\n        address creator,\n        uint256 supply,\n        uint40 packId,\n        uint16 numFTs,\n        uint16 packIndex\n    ) internal view returns (uint256) {\n        require(supply > 0 && supply <= ERC1155ERC721Helper.MAX_SUPPLY, \"SUPPLY_OUT_OF_BOUNDS\");\n        return\n            uint256(uint160(creator)) *\n            ERC1155ERC721Helper.CREATOR_OFFSET_MULTIPLIER + // CREATOR\n            (supply == 1 ? uint256(1) * ERC1155ERC721Helper.IS_NFT_OFFSET_MULTIPLIER : 0) + // minted as NFT(1)|FT(0) // ERC1155ERC721Helper.IS_NFT\n            uint256(_chainIndex) *\n            CHAIN_INDEX_OFFSET_MULTIPLIER + // mainnet = 0, polygon = 1\n            uint256(packId) *\n            ERC1155ERC721Helper.PACK_ID_OFFSET_MULTIPLIER + // packId (unique pack) // ERC1155ERC721Helper.URI_ID\n            numFTs *\n            ERC1155ERC721Helper.PACK_NUM_FT_TYPES_OFFSET_MULTIPLIER + // number of fungible token in the pack // ERC1155ERC721Helper.URI_ID\n            packIndex; // packIndex (position in the pack) // PACK_INDEX\n    }\n\n    function _generateTokenIds(\n        address creator,\n        uint256[] memory supplies,\n        uint40 packId\n    ) internal view returns (uint256[] memory, uint16) {\n        uint16 numTokenTypes = uint16(supplies.length);\n        uint256[] memory ids = new uint256[](numTokenTypes);\n        uint16 numNFTs = 0;\n        for (uint16 i = 0; i < numTokenTypes; i++) {\n            if (numNFTs == 0) {\n                if (supplies[i] == 1) {\n                    numNFTs = uint16(numTokenTypes - i);\n                }\n            } else {\n                require(supplies[i] == 1, \"NFTS_MUST_BE_LAST\");\n            }\n        }\n        uint16 numFTs = numTokenTypes - numNFTs;\n        for (uint16 i = 0; i < numTokenTypes; i++) {\n            ids[i] = _generateTokenId(creator, supplies[i], packId, numFTs, i);\n        }\n        return (ids, numNFTs);\n    }\n}\n"
    },
    "src/solc_0.8/asset/libraries/AssetHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../common/interfaces/IAssetAttributesRegistry.sol\";\n\n// used to reduce PolygonAssetV2 contract code size\nlibrary AssetHelper {\n    struct AssetRegistryData {\n        IAssetAttributesRegistry assetRegistry;\n    }\n\n    function setCatalystDatas(\n        AssetRegistryData storage self,\n        IAssetAttributesRegistry.AssetGemsCatalystData[] memory assetGemsCatalystData\n    ) public {\n        for (uint256 i = 0; i < assetGemsCatalystData.length; i++) {\n            require(assetGemsCatalystData[i].catalystContractId > 0, \"WRONG_catalystContractId\");\n            require(assetGemsCatalystData[i].assetId != 0, \"WRONG_assetId\");\n            self.assetRegistry.setCatalystWhenDepositOnOtherLayer(\n                assetGemsCatalystData[i].assetId,\n                assetGemsCatalystData[i].catalystContractId,\n                assetGemsCatalystData[i].gemContractIds\n            );\n        }\n    }\n\n    function decodeAndSetCatalystDataL1toL2(AssetRegistryData storage self, bytes calldata depositData)\n        public\n        returns (\n            uint256[] memory ids,\n            uint256[] memory amounts,\n            bytes32[] memory hashes\n        )\n    {\n        bytes memory data;\n        IAssetAttributesRegistry.AssetGemsCatalystData[] memory catalystDatas;\n        (ids, amounts, data) = abi.decode(depositData, (uint256[], uint256[], bytes));\n        (hashes, catalystDatas) = abi.decode(data, (bytes32[], IAssetAttributesRegistry.AssetGemsCatalystData[]));\n\n        setCatalystDatas(self, catalystDatas);\n    }\n\n    function decodeAndSetCatalystDataL2toL1(AssetRegistryData storage self, bytes calldata data)\n        public\n        returns (bytes32[] memory hashes)\n    {\n        IAssetAttributesRegistry.AssetGemsCatalystData[] memory catalystDatas;\n\n        (hashes, catalystDatas) = abi.decode(data, (bytes32[], IAssetAttributesRegistry.AssetGemsCatalystData[]));\n\n        setCatalystDatas(self, catalystDatas);\n    }\n\n    function getGemsAndCatalystData(AssetRegistryData storage self, uint256[] calldata assetIds)\n        public\n        view\n        returns (IAssetAttributesRegistry.AssetGemsCatalystData[] memory)\n    {\n        uint256 count = getGemsCatalystDataCount(self, assetIds);\n        uint256 indexInCatalystArray;\n\n        IAssetAttributesRegistry.AssetGemsCatalystData[] memory gemsCatalystDatas =\n            new IAssetAttributesRegistry.AssetGemsCatalystData[](count);\n\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            (bool isDataFound, uint16 catalystId, uint16[] memory gemIds) = self.assetRegistry.getRecord(assetIds[i]);\n            if (isDataFound) {\n                IAssetAttributesRegistry.AssetGemsCatalystData memory data;\n                data.assetId = assetIds[i];\n                data.catalystContractId = catalystId;\n                data.gemContractIds = gemIds;\n                require(indexInCatalystArray < count, \"indexInCatalystArray out of bound\");\n                gemsCatalystDatas[indexInCatalystArray] = data;\n                indexInCatalystArray++;\n            }\n        }\n\n        return gemsCatalystDatas;\n    }\n\n    function getGemsCatalystDataCount(AssetRegistryData storage self, uint256[] calldata assetIds)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 count;\n\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            (bool isDataFound, , ) = self.assetRegistry.getRecord(assetIds[i]);\n            if (isDataFound) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /**\n        @notice Transfers `value` amount of an `id` from  `from` to `to`  (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if balance of holder for token `id` is lower than the `value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param id      ID of the token type\n        @param value   Transfer amount\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `to`\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Transfers `values` amount(s) of `ids` from the `from` address to the `to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if length of `ids` is not the same as length of `values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `ids` is lower than the respective amount(s) in `values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param ids     IDs of each token type (order and length must match _values array)\n        @param values  Transfer amounts per token type (order and length must match _ids array)\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `to`\n    */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Get the balance of an account's tokens.\n        @param owner  The address of the token holder\n        @param id     ID of the token\n        @return        The _owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param owners The addresses of the token holders\n        @param ids    ID of the tokens\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param operator  Address to add to the set of authorized operators\n        @param approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param owner     The owner of the tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC1155TokenReceiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface IERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param operator  The address which initiated the transfer (i.e. msg.sender)\n        @param from      The address which previously owned the token\n        @param id        The ID of the token being transferred\n        @param value     The amount of tokens being transferred\n        @param data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param from      The address which previously owned the token\n        @param ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "src/solc_0.8/common/Libraries/ObjectLib32.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nlibrary ObjectLib32 {\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 internal constant TYPES_BITS_SIZE = 32; // Max size of each object\n    uint256 internal constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /// @dev Return the bin number and index within that bin where ID is\n    /// @param tokenId Object type\n    /// @return bin Bin number.\n    /// @return index ID's index within that bin.\n    function getTokenBinIndex(uint256 tokenId) internal pure returns (uint256 bin, uint256 index) {\n        unchecked {bin = (tokenId * TYPES_BITS_SIZE) / 256;}\n        index = tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in binBalances\n     * @param binBalances Uint256 containing the balances of objects\n     * @param index Index of the object in the provided bin\n     * @param amount Value to update the type balance\n     * @param operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with amount\n     *     Operations.ADD     : ADD amount to type balance\n     *     Operations.SUB     : Substract amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 binBalances,\n        uint256 index,\n        uint256 amount,\n        Operations operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (operation == Operations.ADD) {\n            objectBalance = getValueInBin(binBalances, index);\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance + amount);\n        } else if (operation == Operations.SUB) {\n            objectBalance = getValueInBin(binBalances, index);\n            require(objectBalance >= amount, \"can't substract more than there is\");\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance - amount);\n        } else if (operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(binBalances, index, amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in binValue at position index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index index at which to retrieve value\n     * @return Value at given index in bin\n     */\n    function getValueInBin(uint256 binValue, uint256 index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated binValue after writing amount at index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index Index at which to retrieve value\n     * @param amount Value to store at index in bin\n     * @return Value at given index in bin\n     */\n    function writeValueInBin(\n        uint256 binValue,\n        uint256 index,\n        uint256 amount\n    ) internal pure returns (uint256) {\n        require(amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue & ~(mask << leftShift)) | (amount << leftShift);\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IERC721TokenReceiver.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "src/solc_0.8/asset/libraries/ERC1155ERC721Helper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nlibrary ERC1155ERC721Helper {\n    bytes32 private constant base32Alphabet = 0x6162636465666768696A6B6C6D6E6F707172737475767778797A323334353637;\n\n    uint256 public constant CREATOR_OFFSET_MULTIPLIER = uint256(2)**(256 - 160);\n    uint256 public constant IS_NFT_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 1);\n    uint256 public constant PACK_ID_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 1 - 32 - 40);\n    uint256 public constant PACK_NUM_FT_TYPES_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 1 - 32 - 40 - 12);\n    uint256 public constant NFT_INDEX_OFFSET = 63;\n\n    uint256 public constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    uint256 public constant NOT_IS_NFT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 public constant NFT_INDEX = 0x00000000000000000000000000000000000000007FFFFFFF8000000000000000;\n    uint256 public constant NOT_NFT_INDEX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF800000007FFFFFFFFFFFFFFF;\n    uint256 public constant URI_ID = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000007FFFFFFFFFFFF800;\n    uint256 public constant PACK_ID = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000007FFFFFFFFF800000;\n    uint256 public constant PACK_INDEX = 0x00000000000000000000000000000000000000000000000000000000000007FF;\n    uint256 public constant PACK_NUM_FT_TYPES = 0x00000000000000000000000000000000000000000000000000000000007FF800;\n\n    uint256 public constant MAX_SUPPLY = uint256(2)**32 - 1;\n    uint256 public constant MAX_PACK_SIZE = uint256(2)**11;\n\n    function toFullURI(bytes32 hash, uint256 id) public pure returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://bafybei\", hash2base32(hash), \"/\", uint2str(id & PACK_INDEX), \".json\"));\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function hash2base32(bytes32 hash) public pure returns (string memory _uintAsString) {\n        uint256 _i = uint256(hash);\n        uint256 k = 52;\n        bytes memory bstr = new bytes(k);\n        bstr[--k] = base32Alphabet[uint8((_i % 8) << 2)]; // uint8 s = uint8((256 - skip) % 5);  // (_i % (2**s)) << (5-s)\n        _i /= 8;\n        while (k > 0) {\n            bstr[--k] = base32Alphabet[_i % 32];\n            _i /= 32;\n        }\n        return string(bstr);\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint256 _i) public pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            bstr[--k] = bytes1(uint8(48 + uint8(_i % 10)));\n            _i /= 10;\n        }\n\n        return string(bstr);\n    }\n}\n"
    },
    "src/solc_0.8/Game/GameMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./GameBaseToken.sol\";\nimport \"../common/interfaces/IGameMinter.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"../common/BaseWithStorage/ERC2771Handler.sol\";\n\ncontract GameMinter is ERC2771Handler, IGameMinter {\n    ///////////////////////////////  Data //////////////////////////////\n\n    GameBaseToken internal immutable _gameToken;\n    // @todo confirm actual fees\n    uint256 internal immutable _gameMintingFee;\n    uint256 internal immutable _gameUpdateFee;\n    address internal immutable _feeBeneficiary;\n    IERC20 internal immutable _sand;\n\n    ///////////////////////////////  Functions /////////////////////////\n\n    constructor(\n        GameBaseToken gameTokenContract,\n        address trustedForwarder,\n        uint256 gameMintingFee,\n        uint256 gameUpdateFee,\n        address feeBeneficiary,\n        IERC20 sand\n    ) {\n        _gameToken = gameTokenContract;\n        _gameMintingFee = gameMintingFee;\n        _gameUpdateFee = gameUpdateFee;\n        _feeBeneficiary = feeBeneficiary;\n        _sand = sand;\n        ERC2771Handler.__ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @notice Function to create a new GAME token\n    /// @param to The address who will be assigned ownership of this game.\n    /// @param creation The struct containing ids & ammounts of assets to add to this game,\n    /// along with the uri to set.\n    /// @param editor The address to allow to edit (can also be set later).\n    /// @param subId A random id created on the backend.\n    /// @return gameId The id of the new GAME token (erc721)\n    function createGame(\n        address to,\n        GameBaseToken.GameData calldata creation,\n        address editor,\n        uint64 subId\n    ) external override returns (uint256 gameId) {\n        address msgSender = _msgSender();\n        _chargeSand(msgSender, _gameMintingFee);\n        return _gameToken.createGame(msgSender, to, creation, editor, subId);\n    }\n\n    /// @notice Update an existing GAME token.This actually burns old token\n    /// and mints new token with same basId & incremented version.\n    /// @param gameId The current id of the GAME token.\n    /// @param update The values to use for the update.\n    /// @return newId The new gameId.\n    function updateGame(uint256 gameId, GameBaseToken.GameData memory update)\n        external\n        override\n        returns (uint256 newId)\n    {\n        address gameOwner = _gameToken.ownerOf(gameId);\n        address msgSender = _msgSender();\n        require(msgSender == gameOwner || _gameToken.isGameEditor(gameOwner, msgSender), \"AUTH_ACCESS_DENIED\");\n        _chargeSand(msgSender, _gameUpdateFee);\n        return _gameToken.updateGame(msgSender, gameId, update);\n    }\n\n    /// @dev Charge a fee in Sand if conditions are met.\n    /// @param from The address responsible for paying the fee.\n    /// @param sandFee The fee that applies to the current operation (create || update).\n    function _chargeSand(address from, uint256 sandFee) internal {\n        if (_feeBeneficiary != address(0) && sandFee != 0) {\n            _sand.transferFrom(from, _feeBeneficiary, sandFee);\n        }\n    }\n}\n"
    },
    "src/solc_0.8/Game/GameBaseToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/BaseWithStorage/ImmutableERC721.sol\";\nimport \"../common/BaseWithStorage/WithMinter.sol\";\nimport \"../common/interfaces/IAssetToken.sol\";\nimport \"../common/interfaces/IGameToken.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract GameBaseToken is ImmutableERC721, WithMinter, Initializable, IGameToken {\n    ///////////////////////////////  Data //////////////////////////////\n\n    IAssetToken internal _asset;\n\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n\n    mapping(uint256 => mapping(uint256 => uint256)) private _gameAssets;\n    mapping(uint256 => address) private _creatorship; // creatorship transfer\n\n    mapping(uint256 => bytes32) private _metaData;\n    mapping(address => mapping(address => bool)) private _gameEditors;\n\n    ///////////////////////////////  Events //////////////////////////////\n\n    /// @dev Emits when a game is updated.\n    /// @param oldId The id of the previous erc721 GAME token.\n    /// @param newId The id of the newly minted token.\n    /// @param update The changes made to the Game: new assets, removed assets, uri\n\n    event GameTokenUpdated(uint256 indexed oldId, uint256 indexed newId, IGameToken.GameData update);\n\n    /// @dev Emits when creatorship of a GAME token is transferred.\n    /// @param original The original creator of the GAME token.\n    /// @param from The current 'creator' of the token.\n    /// @param to The new 'creator' of the token.\n    event CreatorshipTransfer(address indexed original, address indexed from, address indexed to);\n\n    /// @dev Emits when an address has its gameEditor status changed.\n    /// @param gameOwner The owner of the GAME token.\n    /// @param gameEditor The address whose editor rights to update.\n    /// @param isEditor WHether the address 'gameEditor' should be an editor.\n    event GameEditorSet(address indexed gameOwner, address gameEditor, bool isEditor);\n\n    function initV1(\n        address trustedForwarder,\n        address admin,\n        IAssetToken asset,\n        uint8 chainIndex\n    ) public initializer() {\n        _admin = admin;\n        _asset = asset;\n        ImmutableERC721.__ImmutableERC721_initialize(chainIndex);\n        ERC2771Handler.__ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    ///////////////////////////////  Modifiers //////////////////////////////\n\n    modifier notToZero(address to) {\n        require(to != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        _;\n    }\n\n    modifier notToThis(address to) {\n        require(to != address(this), \"DESTINATION_GAME_CONTRACT\");\n        _;\n    }\n\n    ///////////////////////////////  Functions //////////////////////////////\n\n    /// @notice Create a new GAME token.\n    /// @param from The address of the one creating the game (may be different from msg.sender if metaTx).\n    /// @param to The address who will be assigned ownership of this game.\n    /// @param creation The struct containing ids & ammounts of assets to add to this game,\n    /// along with the uri to set.\n    /// @param editor The address to allow to edit (can also be set later).\n    /// @param subId A random id created on the backend.\n    /// @return id The id of the new GAME token (erc721).\n    function createGame(\n        address from,\n        address to,\n        GameData calldata creation,\n        address editor,\n        uint64 subId\n    ) external override onlyMinter() notToZero(to) notToThis(to) returns (uint256 id) {\n        (uint256 gameId, uint256 strgId) = _mintGame(from, to, subId, 0, true);\n\n        if (editor != address(0)) {\n            _setGameEditor(to, editor, true);\n        }\n        if (creation.assetIdsToAdd.length != 0) {\n            _addAssets(from, strgId, creation.assetIdsToAdd, creation.assetAmountsToAdd);\n        }\n\n        _metaData[strgId] = creation.uri;\n        emit GameTokenUpdated(0, gameId, creation);\n        return gameId;\n    }\n\n    /// @notice Update an existing GAME token.This actually burns old token\n    /// and mints new token with same basId & incremented version.\n    /// @param from The one updating the GAME token.\n    /// @param gameId The current id of the GAME token.\n    /// @param update The values to use for the update.\n    /// @return The new gameId.\n    function updateGame(\n        address from,\n        uint256 gameId,\n        IGameToken.GameData memory update\n    ) external override onlyMinter() returns (uint256) {\n        uint256 id = _storageId(gameId);\n        _addAssets(from, id, update.assetIdsToAdd, update.assetAmountsToAdd);\n        _removeAssets(id, update.assetIdsToRemove, update.assetAmountsToRemove, _ownerOf(gameId));\n        _metaData[id] = update.uri;\n        uint256 newId = _bumpGameVersion(from, gameId);\n        emit GameTokenUpdated(gameId, newId, update);\n        return newId;\n    }\n\n    /// @notice Allow token owner to set game editors.\n    /// @param gameOwner The address of a GAME token creator.\n    /// @param editor The address of the editor to set.\n    /// @param isEditor Add or remove the ability to edit.\n    function setGameEditor(\n        address gameOwner,\n        address editor,\n        bool isEditor\n    ) external override {\n        require(_msgSender() == gameOwner, \"EDITOR_ACCESS_DENIED\");\n        _setGameEditor(gameOwner, editor, isEditor);\n    }\n\n    /// @notice Transfers creatorship of `original` from `sender` to `to`.\n    /// @param gameId The current id of the GAME token.\n    /// @param sender The address of current registered creator.\n    /// @param to The address to transfer the creatorship to\n    function transferCreatorship(\n        uint256 gameId,\n        address sender,\n        address to\n    ) external override notToZero(to) {\n        require(_ownerOf(gameId) != address(0), \"NONEXISTENT_TOKEN\");\n        uint256 id = _storageId(gameId);\n        address msgSender = _msgSender();\n        require(msgSender == sender || _superOperators[msgSender], \"TRANSFER_ACCESS_DENIED\");\n        require(sender != address(0), \"NOT_FROM_ZEROADDRESS\");\n        address originalCreator = address(uint160(id / CREATOR_OFFSET_MULTIPLIER));\n        address current = creatorOf(gameId);\n        require(current != to, \"CURRENT_=_TO\");\n        require(current == sender, \"CURRENT_!=_SENDER\");\n        _creatorship[id] = to;\n        emit CreatorshipTransfer(originalCreator, current, to);\n    }\n\n    /// @notice Burn a GAME token and recover assets.\n    /// @param from The address of the one destroying the game.\n    /// @param to The address to send all GAME assets to.\n    /// @param gameId The id of the GAME to destroy.\n    /// @param assetIds The assets to recover from the burnt GAME.\n    function burnAndRecover(\n        address from,\n        address to,\n        uint256 gameId,\n        uint256[] calldata assetIds\n    ) external override {\n        _burnGame(from, gameId);\n        _recoverAssets(from, to, gameId, assetIds);\n    }\n\n    /// @notice Burn a GAME token.\n    /// @param gameId The id of the GAME to destroy.\n    function burn(uint256 gameId) external override(ERC721BaseToken, IGameToken) {\n        _burnGame(_msgSender(), gameId);\n    }\n\n    /// @notice Burn a GAME token on behalf of owner.\n    /// @param from The address whose GAME is being burnt.\n    /// @param gameId The id of the GAME to burn.\n    function burnFrom(address from, uint256 gameId) external override(ERC721BaseToken, IGameToken) {\n        require(from != address(0), \"NOT_FROM_ZEROADDRESS\");\n        _burnGame(from, gameId);\n    }\n\n    /// @notice Get the amount of each assetId in a GAME.\n    /// @param gameId The game to query.\n    /// @param assetIds The assets to get balances for.\n    function getAssetBalances(uint256 gameId, uint256[] calldata assetIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 storageId = _storageId(gameId);\n        require(_ownerOf(gameId) != address(0), \"NONEXISTENT_TOKEN\");\n        uint256 length = assetIds.length;\n        uint256[] memory assets;\n        assets = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            assets[i] = _gameAssets[storageId][assetIds[i]];\n        }\n        return assets;\n    }\n\n    /// @notice Get game editor status.\n    /// @param gameOwner The address of the owner of the GAME.\n    /// @param editor The address of the editor to set.\n    /// @return isEditor Editor status of editor for given tokenId.\n    function isGameEditor(address gameOwner, address editor) external view override returns (bool isEditor) {\n        return _gameEditors[gameOwner][editor];\n    }\n\n    /// @notice Called by other contracts to check if this can receive erc1155 batch.\n    /// @param operator The address of the operator in the current tx.\n    /// @return the bytes4 value 0xbc197c81.\n    function onERC1155BatchReceived(\n        address operator,\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        if (operator == address(this)) {\n            return ERC1155_BATCH_RECEIVED;\n        }\n        revert(\"ERC1155_BATCH_REJECTED\");\n    }\n\n    /// @notice Called by other contracts to check if this can receive erc1155 tokens.\n    /// @param operator The address of the operator in the current tx.\n    /// @return the bytes4 value 0xf23a6e61.\n    function onERC1155Received(\n        address operator,\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external view override returns (bytes4) {\n        if (operator == address(this)) {\n            return ERC1155_RECEIVED;\n        }\n        revert(\"ERC1155_REJECTED\");\n    }\n\n    /// @notice Return the name of the token contract.\n    /// @return The name of the token contract.\n    function name() external pure override returns (string memory) {\n        return \"The Sandbox: GAME token\";\n    }\n\n    /// @notice Get the symbol of the token contract.\n    /// @return the symbol of the token contract.\n    function symbol() external pure override returns (string memory) {\n        return \"GAME\";\n    }\n\n    /// @notice Get the creator of the token type `id`.\n    /// @param gameId The id of the token to get the creator of.\n    /// @return the creator of the token type `id`.\n    function creatorOf(uint256 gameId) public view override returns (address) {\n        require(gameId != uint256(0), \"GAME_NEVER_MINTED\");\n        uint256 id = _storageId(gameId);\n        address originalCreator = address(uint160(id / CREATOR_OFFSET_MULTIPLIER));\n        address newCreator = _creatorship[id];\n        if (newCreator != address(0)) {\n            return newCreator;\n        }\n        return originalCreator;\n    }\n\n    /// @notice Return the URI of a specific token.\n    /// @param gameId The id of the token.\n    /// @return uri The URI of the token metadata.\n    function tokenURI(uint256 gameId) public view override returns (string memory uri) {\n        require(_ownerOf(gameId) != address(0), \"BURNED_OR_NEVER_MINTED\");\n        uint256 id = _storageId(gameId);\n        return _toFullURI(_metaData[id]);\n    }\n\n    /// @notice Transfer assets from a burnt GAME.\n    /// @param from Previous owner of the burnt game.\n    /// @param to Address that will receive the assets.\n    /// @param gameId Id of the burnt GAME token.\n    /// @param assetIds The assets to recover from the burnt GAME.\n    function recoverAssets(\n        address from,\n        address to,\n        uint256 gameId,\n        uint256[] memory assetIds\n    ) public override {\n        _recoverAssets(from, to, gameId, assetIds);\n    }\n\n    /// @notice Check if the contract supports an interface.\n    /// 0x01ffc9a7 is ERC-165.\n    /// 0x80ac58cd is ERC-721.\n    /// @param id The id of the interface.\n    /// @return if the interface is supported.\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /// @notice Add assets to an existing GAME.\n    /// @param from The address of the current owner of assets.\n    /// @param strgId The storageId of the GAME to add assets to.\n    /// @param assetIds The id of the asset to add to GAME.\n    /// @param amounts The amount of each asset to add to GAME.\n    function _addAssets(\n        address from,\n        uint256 strgId,\n        uint256[] memory assetIds,\n        uint256[] memory amounts\n    ) internal {\n        if (assetIds.length == 0) {\n            return;\n        }\n        require(assetIds.length == amounts.length, \"INVALID_INPUT_LENGTHS\");\n        uint256 currentValue;\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            currentValue = _gameAssets[strgId][assetIds[i]];\n            require(amounts[i] != 0, \"INVALID_ASSET_ADDITION\");\n            _gameAssets[strgId][assetIds[i]] = currentValue + amounts[i];\n        }\n        if (assetIds.length == 1) {\n            _asset.safeTransferFrom(from, address(this), assetIds[0], amounts[0], \"\");\n        } else {\n            _asset.safeBatchTransferFrom(from, address(this), assetIds, amounts, \"\");\n        }\n    }\n\n    /// @notice Remove assets from a GAME.\n    /// @param id The storageId of the GAME to remove assets from.\n    /// @param assetIds An array of asset Ids to remove.\n    /// @param values An array of the number of each asset id to remove.\n    /// @param to The address to send removed assets to.\n    function _removeAssets(\n        uint256 id,\n        uint256[] memory assetIds,\n        uint256[] memory values,\n        address to\n    ) internal {\n        if (assetIds.length == 0) {\n            return;\n        }\n        require(assetIds.length == values.length && assetIds.length != 0, \"INVALID_INPUT_LENGTHS\");\n        uint256 currentValue;\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            currentValue = _gameAssets[id][assetIds[i]];\n            require(currentValue != 0 && values[i] != 0 && values[i] <= currentValue, \"INVALID_ASSET_REMOVAL\");\n            _gameAssets[id][assetIds[i]] = currentValue - values[i];\n        }\n\n        if (assetIds.length == 1) {\n            _asset.safeTransferFrom(address(this), to, assetIds[0], values[0], \"\");\n        } else {\n            _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n        }\n    }\n\n    /// @dev See burn / burnFrom.\n    function _burnGame(address from, uint256 gameId) internal {\n        uint256 storageId = _storageId(gameId);\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(storageId);\n        address msgSender = _msgSender();\n        require(\n            msgSender == owner ||\n                (operatorEnabled && _operators[storageId] == msgSender) ||\n                _superOperators[msgSender] ||\n                _operatorsForAll[from][msgSender],\n            \"UNAUTHORIZED_BURN\"\n        );\n\n        delete _metaData[storageId];\n        _creatorship[storageId] = address(0);\n        _burn(from, owner, gameId);\n    }\n\n    /// @dev See recoverAssets.\n    function _recoverAssets(\n        address from,\n        address to,\n        uint256 gameId,\n        uint256[] memory assetIds\n    ) internal notToZero(to) notToThis(to) {\n        require(_ownerOf(gameId) == address(0), \"ONLY_FROM_BURNED_TOKEN\");\n        uint256 storageId = _storageId(gameId);\n        require(from == _msgSender(), \"INVALID_RECOVERY\");\n        _check_withdrawal_authorized(from, gameId);\n        require(assetIds.length > 0, \"WITHDRAWAL_COMPLETE\");\n        uint256[] memory values;\n        values = new uint256[](assetIds.length);\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            values[i] = _gameAssets[storageId][assetIds[i]];\n            delete _gameAssets[storageId][assetIds[i]];\n        }\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n\n        GameData memory recovery;\n        recovery.assetIdsToRemove = assetIds;\n        recovery.assetAmountsToRemove = values;\n        emit GameTokenUpdated(gameId, 0, recovery);\n    }\n\n    /// @dev Create a new gameId and associate it with an owner.\n    /// @param from The address of one creating the game.\n    /// @param to The address of the Game owner.\n    /// @param subId The id to use when generating the new GameId.\n    /// @param version The version number part of the gameId.\n    /// @param isCreation Whether this is a brand new GAME (as opposed to an update).\n    /// @return id The newly created gameId.\n    function _mintGame(\n        address from,\n        address to,\n        uint64 subId,\n        uint16 version,\n        bool isCreation\n    ) internal returns (uint256 id, uint256 storageId) {\n        uint16 idVersion;\n        uint256 gameId;\n        uint256 strgId;\n        if (isCreation) {\n            idVersion = 1;\n            gameId = _generateTokenId(from, subId, _chainIndex, idVersion);\n            strgId = _storageId(gameId);\n            require(_owners[strgId] == 0, \"STORAGE_ID_REUSE_FORBIDDEN\");\n        } else {\n            idVersion = version;\n            gameId = _generateTokenId(from, subId, _chainIndex, idVersion);\n            strgId = _storageId(gameId);\n        }\n\n        _owners[strgId] = (uint256(idVersion) << 200) + uint256(uint160(to));\n        _numNFTPerAddress[to]++;\n        emit Transfer(address(0), to, gameId);\n        return (gameId, strgId);\n    }\n\n    /// @dev Allow token owner to set game editors.\n    /// @param gameCreator The address of a GAME creator,\n    /// @param editor The address of the editor to set.\n    /// @param isEditor Add or remove the ability to edit.\n    function _setGameEditor(\n        address gameCreator,\n        address editor,\n        bool isEditor\n    ) internal {\n        emit GameEditorSet(gameCreator, editor, isEditor);\n        _gameEditors[gameCreator][editor] = isEditor;\n    }\n\n    /// @dev Bumps the version number of a game token, buring the previous\n    /// version and minting a new one.\n    /// @param from The address of the GAME token owner.\n    /// @param gameId The Game token to bump the version of.\n    /// @return The new gameId.\n    function _bumpGameVersion(address from, uint256 gameId) internal returns (uint256) {\n        address originalCreator = address(uint160(gameId / CREATOR_OFFSET_MULTIPLIER));\n        uint64 subId = uint64(gameId / SUBID_MULTIPLIER);\n        uint16 version = uint16(gameId);\n        version++;\n        address owner = _ownerOf(gameId);\n        if (from == owner) {\n            // caller is owner or metaTx on owner's behalf\n            _burn(from, owner, gameId);\n        } else if (_gameEditors[owner][from]) {\n            // caller is editor or metaTx on editor's behalf, so we need to pass owner\n            // instead of from or _burn will fail\n            _burn(owner, owner, gameId);\n        }\n        (uint256 newId, ) = _mintGame(originalCreator, owner, subId, version, false);\n        address newOwner = _ownerOf(newId);\n        assert(owner == newOwner);\n        return newId;\n    }\n\n    /// @dev Get the a full URI string for a given hash + gameId.\n    /// @param hash The 32 byte IPFS hash.\n    /// @return The URI string.\n    function _toFullURI(bytes32 hash) internal pure override returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://bafybei\", hash2base32(hash), \"/\", \"game.json\"));\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IGameMinter.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./IGameToken.sol\";\n\ninterface IGameMinter {\n    function createGame(\n        address to,\n        IGameToken.GameData calldata creation,\n        address editor,\n        uint64 subId\n    ) external returns (uint256 gameId);\n\n    function updateGame(uint256 gameId, IGameToken.GameData memory update) external returns (uint256 newId);\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/ImmutableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../BaseWithStorage/ERC721BaseToken.sol\";\n\ncontract ImmutableERC721 is ERC721BaseToken {\n    uint256 internal constant CREATOR_OFFSET_MULTIPLIER = uint256(2)**(256 - 160);\n    uint256 internal constant SUBID_MULTIPLIER = uint256(2)**(256 - 224);\n    uint256 internal constant CHAIN_INDEX_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 64 - 16);\n    uint256 internal constant STORAGE_ID_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\n    uint256 internal constant VERSION_MASK = 0x000000FFFFFFFF00000000000000000000000000000000000000000000000000;\n    uint256 internal constant CHAIN_INDEX_MASK = 0x0000000000000000000000000000000000000000000000000000000000FF0000;\n    bytes32 internal constant base32Alphabet = 0x6162636465666768696A6B6C6D6E6F707172737475767778797A323334353637;\n\n    uint8 internal _chainIndex;\n\n    function __ImmutableERC721_initialize(uint8 index) internal {\n        _chainIndex = index;\n    }\n\n    /// @dev get the layer a token was minted on from its id.\n    /// @param id The id of the token to query.\n    /// @return The index of the original layer of minting.\n    /// 0 = eth mainnet, 1 == Polygon, etc...\n    function getChainIndex(uint256 id) public pure virtual returns (uint256) {\n        return uint256((id & CHAIN_INDEX_MASK) >> 16);\n    }\n\n    /// @dev An implementation which handles versioned tokenIds.\n    /// @param id The tokenId to get the owner of.\n    /// @return The address of the owner.\n    function _ownerOf(uint256 id) internal view virtual override returns (address) {\n        uint256 packedData = _owners[_storageId(id)];\n        uint16 idVersion = uint16(id);\n        uint16 storageVersion = uint16((packedData & VERSION_MASK) >> 200);\n\n        if (((packedData & BURNED_FLAG) == BURNED_FLAG) || idVersion != storageVersion) {\n            return address(0);\n        }\n        return address(uint160(packedData));\n    }\n\n    /// @dev Check if a withdrawal is allowed.\n    /// @param from The address requesting the withdrawal.\n    /// @param gameId The id of the GAME token to withdraw assets from.\n    function _check_withdrawal_authorized(address from, uint256 gameId) internal view virtual {\n        require(from != address(0), \"SENDER_ZERO_ADDRESS\");\n        require(from == _withdrawalOwnerOf(gameId), \"LAST_OWNER_NOT_EQUAL_SENDER\");\n    }\n\n    /// @dev Get the address allowed to withdraw associated tokens from the parent token.\n    /// If too many associated tokens in TOKEN, block.gaslimit won't allow detroy and withdraw in 1 tx.\n    /// An owner may destroy their token, then withdraw associated tokens in a later tx (even\n    /// though ownerOf(id) would be address(0) after burning.)\n    /// @param id The id of the token to query.\n    /// @return the address of the owner before burning.\n    function _withdrawalOwnerOf(uint256 id) internal view virtual returns (address) {\n        uint256 packedData = _owners[_storageId(id)];\n        return address(uint160(packedData));\n    }\n\n    /// @notice Get the storageID (no chainIndex or version data), which is constant for a given token.\n    /// @param tokenId The tokenId for which to find the first token Id.\n    /// @return The storage id for this token.\n    function getStorageId(uint256 tokenId) external pure virtual returns (uint256) {\n        return _storageId(tokenId);\n    }\n\n    /// @dev Get the storageId (full id without the version number) from the full tokenId.\n    /// @param id The full tokenId for the GAME token.\n    /// @return The storageId.\n    function _storageId(uint256 id) internal pure virtual override returns (uint256) {\n        return uint256(id & STORAGE_ID_MASK);\n    }\n\n    /// @dev Get the a full URI string for a given hash + gameId.\n    /// @param hash The 32 byte IPFS hash.\n    /// @return The URI string.\n    function _toFullURI(bytes32 hash) internal pure virtual returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://bafybei\", hash2base32(hash), \"/\", \"token.json\"));\n    }\n\n    /// @dev Create a new tokenId and associate it with an owner.\n    /// This is a packed id, consisting of 4 parts:\n    /// the creator's address, a uint64 subId, a uint18 chainIndex and a uint16 version.\n    /// @param creator The address of the Token creator.\n    /// @param subId The id used to generate the id.\n    /// @param version The publicversion used to generate the id.\n    function _generateTokenId(\n        address creator,\n        uint64 subId,\n        uint8 chainIndex,\n        uint16 version\n    ) internal pure returns (uint256) {\n        return\n            uint256(uint160(creator)) *\n            CREATOR_OFFSET_MULTIPLIER +\n            uint64(subId) *\n            SUBID_MULTIPLIER +\n            chainIndex *\n            CHAIN_INDEX_OFFSET_MULTIPLIER +\n            uint16(version);\n    }\n\n    /// @dev Convert a 32 byte hash to a base 32 string.\n    /// @param hash A 32 byte (IPFS) hash.\n    /// @return _uintAsString The hash as a base 32 string.\n    // solhint-disable-next-line security/no-assign-params\n    function hash2base32(bytes32 hash) internal pure returns (string memory _uintAsString) {\n        uint256 _i = uint256(hash);\n        uint256 k = 52;\n        bytes memory bstr = new bytes(k);\n        bstr[--k] = base32Alphabet[uint8((_i % 8) << 2)]; // uint8 s = uint8((256 - skip) % 5);  // (_i % (2**s)) << (5-s)\n        _i /= 8;\n        while (k > 0) {\n            bstr[--k] = base32Alphabet[_i % 32];\n            _i /= 32;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IAssetToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\ninterface IAssetToken {\n    function mint(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256 supply,\n        uint8 rarity,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256 id);\n\n    function mintMultiple(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256[] calldata supplies,\n        bytes calldata rarityPack,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256[] memory ids);\n\n    // fails on non-NFT or nft who do not have collection (was a mistake)\n    function collectionOf(uint256 id) external view returns (uint256);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    // return true for Non-NFT ERC1155 tokens which exists\n    function isCollection(uint256 id) external view returns (bool);\n\n    function collectionIndexOf(uint256 id) external view returns (uint256);\n\n    function extractERC721From(\n        address sender,\n        uint256 id,\n        address to\n    ) external returns (uint256 newId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    function isSuperOperator(address who) external view returns (bool);\n}\n"
    },
    "src/solc_0.8/common/interfaces/IGameToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\n/// @title Interface for the Game token\n\ninterface IGameToken {\n    struct GameData {\n        uint256[] assetIdsToRemove;\n        uint256[] assetAmountsToRemove;\n        uint256[] assetIdsToAdd;\n        uint256[] assetAmountsToAdd;\n        bytes32 uri; // ipfs hash (without the prefix, assume cidv1 folder)\n    }\n\n    function createGame(\n        address from,\n        address to,\n        GameData calldata creation,\n        address editor,\n        uint64 subId\n    ) external returns (uint256 id);\n\n    function burn(uint256 gameId) external;\n\n    function burnFrom(address from, uint256 gameId) external;\n\n    function recoverAssets(\n        address from,\n        address to,\n        uint256 gameId,\n        uint256[] calldata assetIds\n    ) external;\n\n    function burnAndRecover(\n        address from,\n        address to,\n        uint256 gameId,\n        uint256[] calldata assetIds\n    ) external;\n\n    function updateGame(\n        address from,\n        uint256 gameId,\n        GameData calldata update\n    ) external returns (uint256);\n\n    function getAssetBalances(uint256 gameId, uint256[] calldata assetIds) external view returns (uint256[] calldata);\n\n    function setGameEditor(\n        address gameCreator,\n        address editor,\n        bool isEditor\n    ) external;\n\n    function isGameEditor(address gameOwner, address editor) external view returns (bool isEditor);\n\n    function creatorOf(uint256 id) external view returns (address);\n\n    function transferCreatorship(\n        uint256 gameId,\n        address sender,\n        address to\n    ) external;\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function tokenURI(uint256 gameId) external returns (string memory uri);\n\n    function onERC1155Received(\n        address operator,\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external view returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external view returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/solc_0.8/polygon/child/ChildGameTokenV1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../Game/GameBaseToken.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ncontract ChildGameTokenV1 is GameBaseToken {\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/solc_0.8/claims/signedGiveaway/SignedERC20Giveaway.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {EIP712Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC2771Handler} from \"../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title This contract pays Sand claims when the backend authorize it via message signing.\n/// @dev can be extended to support NFTs, etc.\n/// @dev This contract support meta transactions.\n/// @dev This contract is final, don't inherit form it.\ncontract SignedERC20Giveaway is\n    Initializable,\n    ContextUpgradeable,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    ERC2771Handler,\n    PausableUpgradeable\n{\n    bytes32 public constant SIGNER_ROLE = keccak256(\"SIGNER_ROLE\");\n    bytes32 public constant CLAIM_TYPEHASH =\n        keccak256(\"Claim(address signer,uint256 claimId,address token,address to,uint256 amount)\");\n    string public constant name = \"Sandbox SignedERC20Giveaway\";\n    string public constant version = \"1.0\";\n    mapping(uint256 => bool) public claimed;\n\n    function initialize(address trustedForwarder_, address defaultAdmin_) external initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __EIP712_init_unchained(name, version);\n        __ERC2771Handler_initialize(trustedForwarder_);\n        __Pausable_init_unchained();\n        _setupRole(DEFAULT_ADMIN_ROLE, defaultAdmin_);\n    }\n\n    /// @notice verifies a ERC712 signature for the Mint data type.\n    /// @param v signature part\n    /// @param r signature part\n    /// @param s signature part\n    /// @param signer the address of the signer, must be part of the signer role\n    /// @param claimId unique claim id\n    /// @param token token contract address\n    /// @param to destination user\n    /// @param amount of ERC20 to transfer\n    /// @return true if the signature is valid\n    function verify(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address signer,\n        uint256 claimId,\n        address token,\n        address to,\n        uint256 amount\n    ) external view returns (bool) {\n        return _verify(v, r, s, signer, claimId, token, to, amount);\n    }\n\n    /// @notice verifies a ERC712 signature and mint a new NFT for the buyer.\n    /// @param v signature part\n    /// @param r signature part\n    /// @param s signature part\n    /// @param signer the address of the signer, must be part of the signer role\n    /// @param claimId unique claim id\n    /// @param token token contract address\n    /// @param to destination user\n    /// @param amount of ERC20 to transfer\n    function claim(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address signer,\n        uint256 claimId,\n        address token,\n        address to,\n        uint256 amount\n    ) external whenNotPaused {\n        require(_verify(v, r, s, signer, claimId, token, to, amount), \"Invalid signature\");\n        require(hasRole(SIGNER_ROLE, signer), \"Invalid signer\");\n        require(!claimed[claimId], \"Already claimed\");\n        claimed[claimId] = true;\n        require(IERC20Upgradeable(token).transfer(to, amount), \"Transfer failed\");\n    }\n\n    /// @notice let the admin revoke some claims so they cannot be used\n    /// @param claimIds and array of claim Ids to revoke\n    function revokeClaims(uint256[] calldata claimIds) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"Only admin\");\n        for (uint256 i = 0; i < claimIds.length; i++) {\n            claimed[claimIds[i]] = true;\n        }\n    }\n\n    // @dev Triggers stopped state.\n    // The contract must not be paused.\n    function pause() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"Only admin\");\n        _pause();\n    }\n\n    // @dev Returns to normal state.\n    // The contract must be paused.\n    function unpause() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"Only admin\");\n        _unpause();\n    }\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    function _verify(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address signer,\n        uint256 claimId,\n        address token,\n        address to,\n        uint256 amount\n    ) internal view returns (bool) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(CLAIM_TYPEHASH, signer, claimId, token, to, amount)));\n        address recoveredSigner = ECDSAUpgradeable.recover(digest, v, r, s);\n        return recoveredSigner == signer;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/CollectionCatalystMigrations.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IOldCatalystRegistry.sol\";\nimport \"../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"./interfaces/ICollectionCatalystMigrations.sol\";\nimport \"../common/interfaces/IAssetToken.sol\";\nimport \"../common/BaseWithStorage/WithAdmin.sol\";\n\n/// @notice Contract performing migrations for collections, do not require owner approval\ncontract CollectionCatalystMigrations is WithAdmin, ICollectionCatalystMigrations {\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n\n    IOldCatalystRegistry internal immutable _oldRegistry;\n    IAssetAttributesRegistry internal immutable _registry;\n    IAssetToken internal immutable _asset;\n\n    /// @notice CollectionCatalystMigrations depends on:\n    /// @param asset: Asset Token Contract\n    /// @param registry: New AssetAttributesRegistry\n    /// @param oldRegistry: Old CatalystRegistry\n    /// @param admin: Contract admin\n    constructor(\n        IAssetToken asset,\n        IAssetAttributesRegistry registry,\n        IOldCatalystRegistry oldRegistry,\n        address admin\n    ) {\n        _oldRegistry = oldRegistry;\n        _asset = asset;\n        _registry = registry;\n        _admin = admin;\n    }\n\n    /// @notice Migrate the catalyst for a collection of assets.\n    /// @param assetId The id of the asset for which the catalyst is being migrated.\n    /// @param oldGemIds The gems currently embedded in the catalyst (old gems count starts from 0)\n    /// @param blockNumber The blocknumber to use when setting the catalyst.\n    function migrate(\n        uint256 assetId,\n        uint16[] calldata oldGemIds,\n        uint64 blockNumber\n    ) external override {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _migrate(assetId, oldGemIds, blockNumber);\n    }\n\n    /// @notice Migrate the catalysts for a batch of assets.\n    /// @param migrations The data to use for each migration in the batch.\n    function batchMigrate(Migration[] calldata migrations) external override {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        for (uint256 i = 0; i < migrations.length; i++) {\n            _migrate(migrations[i].assetId, migrations[i].gemIds, migrations[i].blockNumber);\n        }\n    }\n\n    /// @notice Set the registry migration contract\n    /// @param migrationContract The migration contract for AssetAttributesRegistry\n    function setAssetAttributesRegistryMigrationContract(address migrationContract) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _registry.setMigrationContract(migrationContract);\n    }\n\n    /// @dev Perform the migration of the catalyst. See `migrate(...)`\n    function _migrate(\n        uint256 assetId,\n        uint16[] memory oldGemIds,\n        uint64 blockNumber\n    ) internal {\n        (bool oldExists, uint256 oldCatalystId) = _oldRegistry.getCatalyst(assetId);\n        require(oldExists, \"OLD_CATALYST_NOT_EXIST\");\n        (bool exists, , ) = _registry.getRecord(assetId);\n        require(!exists, \"ALREADY_MIGRATED\");\n        oldCatalystId += 1; // old catalyst start from 0 , new one start with common = 1\n        if (assetId & IS_NFT != 0) {\n            // ensure this NFT has no collection: original NFT\n            // If it has, the collection itself need to be migrated\n            try _asset.collectionOf(assetId) returns (uint256 collId) {\n                require(collId == 0, \"NOT_ORIGINAL_NFT\");\n                // solhint-disable-next-line no-empty-blocks\n            } catch {}\n        }\n        // old gems started from 0, new gems starts with power = 1\n        for (uint256 i = 0; i < oldGemIds.length; i++) {\n            oldGemIds[i] += 1;\n        }\n        _registry.setCatalystWithBlockNumber(assetId, uint16(oldCatalystId), oldGemIds, blockNumber);\n    }\n}\n"
    },
    "src/solc_0.8/catalyst/interfaces/IOldCatalystRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ninterface IOldCatalystRegistry {\n    function getCatalyst(uint256 assetId) external view returns (bool exists, uint256 catalystId);\n}\n"
    },
    "src/solc_0.8/catalyst/interfaces/ICollectionCatalystMigrations.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\ninterface ICollectionCatalystMigrations {\n    struct Migration {\n        uint256 assetId;\n        uint16[] gemIds;\n        uint64 blockNumber;\n    }\n\n    function migrate(\n        uint256 assetId,\n        uint16[] calldata gemIds,\n        uint64 blockNumber\n    ) external;\n\n    function batchMigrate(Migration[] calldata migrations) external;\n}\n"
    },
    "src/solc_0.8/asset/AssetUpgrader.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"../common/interfaces/IAssetUpgrader.sol\";\nimport \"../catalyst/GemsCatalystsRegistry.sol\";\nimport \"../common/interfaces/IERC20Extended.sol\";\nimport \"../common/interfaces/IAssetToken.sol\";\n\n/// @notice Allow to upgrade Asset with Catalyst, Gems and Sand, giving the assets attributes through AssetAttributeRegistry\ncontract AssetUpgrader is Ownable, ERC2771Handler, IAssetUpgrader {\n    using SafeMath for uint256;\n\n    address public immutable feeRecipient;\n    uint256 public immutable upgradeFee;\n    uint256 public immutable gemAdditionFee;\n    uint256 private constant GEM_UNIT = 1000000000000000000;\n    uint256 private constant CATALYST_UNIT = 1000000000000000000;\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    address private constant BURN_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n\n    IERC20Extended internal immutable _sand;\n    IAssetAttributesRegistry internal immutable _registry;\n    IAssetToken internal immutable _asset;\n    GemsCatalystsRegistry internal immutable _gemsCatalystsRegistry;\n\n    /// @notice AssetUpgrader depends on\n    /// @param registry: AssetAttributesRegistry for recording catalyst and gems used\n    /// @param sand: ERC20 for fee payment\n    /// @param asset: Asset Token Contract (dual ERC1155/ERC721)\n    /// @param gemsCatalystsRegistry: that track the canonical catalyst and gems and provide batch burning facility\n    /// @param _upgradeFee: the fee in Sand paid for an upgrade (setting or replacing a catalyst)\n    /// @param _gemAdditionFee: the fee in Sand paid for adding gems\n    /// @param _feeRecipient: address receiving the Sand fee\n    /// @param trustedForwarder: address of the trusted forwarder (used for metaTX)\n    constructor(\n        IAssetAttributesRegistry registry,\n        IERC20Extended sand,\n        IAssetToken asset,\n        GemsCatalystsRegistry gemsCatalystsRegistry,\n        uint256 _upgradeFee,\n        uint256 _gemAdditionFee,\n        address _feeRecipient,\n        address trustedForwarder\n    ) {\n        _registry = registry;\n        _sand = sand;\n        _asset = asset;\n        _gemsCatalystsRegistry = gemsCatalystsRegistry;\n        upgradeFee = _upgradeFee;\n        gemAdditionFee = _gemAdditionFee;\n        feeRecipient = _feeRecipient;\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    /// @return tokenId The Id of the extracted token.\n    function extractAndSetCatalyst(\n        address from,\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        address to\n    ) external override returns (uint256 tokenId) {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(_msgSender() == from, \"AUTH_ACCESS_DENIED\");\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _changeCatalyst(from, tokenId, catalystId, gemIds, to);\n    }\n\n    // TODO tests\n    // function extractAndAddGems(\n    //     address from,\n    //     uint256 assetId,\n    //     uint16[] calldata gemIds,\n    //     address to\n    // ) external override returns (uint256 tokenId) {\n    //     require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n    //     require(_msgSender() == from, \"AUTH_ACCESS_DENIED\");\n    //     tokenId = _asset.extractERC721From(from, assetId, from);\n    //     _addGems(from, assetId, gemIds, to);\n    // }\n\n    /// @notice associate a new catalyst to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being updated.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the Asset token.\n    /// @return tokenId The id of the asset.\n    function changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        address to\n    ) external override returns (uint256 tokenId) {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(_msgSender() == from, \"AUTH_ACCESS_DENIED\");\n        _changeCatalyst(from, assetId, catalystId, gemIds, to);\n        return assetId;\n    }\n\n    /// @notice add gems to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset to which the gems will be added to.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function addGems(\n        address from,\n        uint256 assetId,\n        uint16[] calldata gemIds,\n        address to\n    ) external override {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(_msgSender() == from, \"AUTH_ACCESS_DENIED\");\n        _addGems(from, assetId, gemIds, to);\n    }\n\n    /// @dev Collect a fee in SAND tokens\n    /// @param from The address paying the fee.\n    /// @param sandFee The fee amount.\n    function _chargeSand(address from, uint256 sandFee) internal {\n        if (feeRecipient != address(0) && sandFee != 0) {\n            if (feeRecipient == address(BURN_ADDRESS)) {\n                // special address for burn\n                _sand.burnFor(from, sandFee);\n            } else {\n                _sand.transferFrom(from, feeRecipient, sandFee);\n            }\n        }\n    }\n\n    /// @dev Change the catalyst for an asset.\n    /// @param from The current owner of the asset.\n    /// @param assetId The id of the asset to change.\n    /// @param catalystId The id of the new catalyst to set.\n    /// @param gemIds An array of gemIds to embed.\n    /// @param to The address to transfer the asset to after the catalyst is changed.\n    function _changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _burnCatalyst(from, catalystId);\n        _burnGems(from, gemIds);\n        _chargeSand(from, upgradeFee);\n        _registry.setCatalyst(assetId, catalystId, gemIds);\n        _transfer(from, to, assetId);\n    }\n\n    /// @dev Add gems to an existing asset.\n    /// @param from The current owner of the asset.\n    /// @param assetId The asset to add gems to.\n    /// @param gemIds An array of gemIds to add to the asset.\n    /// @param to The address to transfer the asset to after adding gems.\n    function _addGems(\n        address from,\n        uint256 assetId,\n        uint16[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _burnGems(from, gemIds);\n        _chargeSand(from, gemAdditionFee);\n        _registry.addGems(assetId, gemIds);\n        _transfer(from, to, assetId);\n    }\n\n    /// @dev transfer an asset if from != to.\n    /// @param from The address to transfer the asset from.\n    /// @param to The address to transfer the asset to.\n    /// @param assetId The asset to transfer.\n    function _transfer(\n        address from,\n        address to,\n        uint256 assetId\n    ) internal {\n        if (from != to) {\n            _asset.safeTransferFrom(from, to, assetId);\n        } else {\n            require(_asset.balanceOf(from, assetId) > 0, \"NOT_AUTHORIZED_ASSET_OWNER\");\n        }\n    }\n\n    /// @dev Burn gems.\n    /// @param from The owner of the gems.\n    /// @param gemIds The gem types to burn.\n    function _burnGems(address from, uint16[] memory gemIds) internal {\n        _gemsCatalystsRegistry.burnDifferentGems(from, gemIds, GEM_UNIT);\n    }\n\n    /// @dev Burn a catalyst.\n    /// @param from The owner of the catalyst.\n    /// @param catalystId The catalyst type to burn.\n    function _burnCatalyst(address from, uint16 catalystId) internal {\n        _gemsCatalystsRegistry.burnCatalyst(from, catalystId, CATALYST_UNIT);\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IAssetUpgrader.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\ninterface IAssetUpgrader {\n    function extractAndSetCatalyst(\n        address from,\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId);\n\n    function changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId);\n\n    function addGems(\n        address from,\n        uint256 assetId,\n        uint16[] calldata gemIds,\n        address to\n    ) external;\n}\n"
    },
    "src/solc_0.8/test/AssetUpgraderFeeBurner.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../asset/AssetUpgrader.sol\";\n\n/// @notice Allow to upgrade Asset with Catalyst, Gems and Sand, giving the assets attributes through AssetAttributeRegistry\ncontract AssetUpgraderFeeBurner is AssetUpgrader {\n    constructor(\n        IAssetAttributesRegistry registry,\n        IERC20Extended sand,\n        IAssetToken asset,\n        GemsCatalystsRegistry gemsCatalystsRegistry,\n        uint256 _upgradeFee,\n        uint256 _gemAdditionFee,\n        address _feeRecipient,\n        address trustedForwarder\n    )\n        AssetUpgrader(\n            registry,\n            sand,\n            asset,\n            gemsCatalystsRegistry,\n            _upgradeFee,\n            _gemAdditionFee,\n            _feeRecipient,\n            trustedForwarder\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}\n"
    },
    "src/solc_0.8/polygon/root/SandPolygonDepositor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\nimport \"../../common/interfaces/IERC20Extended.sol\";\nimport \"./IRootChainManager.sol\";\n\ncontract SandPolygonDepositor {\n    IERC20Extended internal immutable _sand;\n    address internal immutable _predicate;\n    IRootChainManager internal immutable _rootChainManager;\n\n    constructor(\n        IERC20Extended sand,\n        address predicate,\n        IRootChainManager rootChainManager\n    ) {\n        _sand = sand;\n        _predicate = predicate;\n        _rootChainManager = rootChainManager;\n    }\n\n    function depositToPolygon(address beneficiary, uint256 amount) public {\n        _sand.transferFrom(beneficiary, address(this), amount);\n        _sand.approve(_predicate, amount);\n        _rootChainManager.depositFor(beneficiary, address(_sand), abi.encode(amount));\n    }\n}\n"
    },
    "src/solc_0.8/polygon/root/IRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\ninterface IRootChainManager {\n    event TokenMapped(address indexed rootToken, address indexed childToken, bytes32 indexed tokenType);\n\n    event PredicateRegistered(bytes32 indexed tokenType, address indexed predicateAddress);\n\n    function registerPredicate(bytes32 tokenType, address predicateAddress) external;\n\n    function mapToken(\n        address rootToken,\n        address childToken,\n        bytes32 tokenType\n    ) external;\n\n    function cleanMapToken(address rootToken, address childToken) external;\n\n    function remapToken(\n        address rootToken,\n        address childToken,\n        bytes32 tokenType\n    ) external;\n\n    function depositEtherFor(address user) external payable;\n\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n\n    function exit(bytes calldata inputData) external;\n}\n"
    },
    "src/solc_0.8/permit/Permit.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/interfaces/IERC20Extended.sol\";\nimport \"../common/BaseWithStorage/WithPermit.sol\";\n\n/// @title Permit contract\n/// @notice This contract manages approvals of SAND via signature\ncontract Permit is WithPermit {\n    IERC20Extended internal immutable _sand;\n\n    constructor(IERC20Extended sandContractAddress) {\n        _sand = sandContractAddress;\n    }\n\n    /// @notice Permit the expenditure of SAND by a nominated spender.\n    /// @param owner The owner of the ERC20 tokens.\n    /// @param spender The nominated spender of the ERC20 tokens.\n    /// @param value The value (allowance) of the ERC20 tokens that the nominated.\n    /// spender will be allowed to spend.\n    /// @param deadline The deadline for granting permission to the spender.\n    /// @param v The final 1 byte of signature.\n    /// @param r The first 32 bytes of signature.\n    /// @param s The second 32 bytes of signature.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        checkApproveFor(owner, spender, value, deadline, v, r, s);\n        _sand.approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/solc_0.8/asset/AssetSignedAuctionAuth.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/Libraries/PriceUtil.sol\";\nimport \"../asset/AssetV2.sol\";\nimport \"../common/Base/TheSandbox712.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../common/interfaces/ERC1271.sol\";\nimport \"../common/interfaces/ERC1271Constants.sol\";\nimport \"../common/interfaces/ERC1654.sol\";\nimport \"../common/interfaces/ERC1654Constants.sol\";\n\ncontract AssetSignedAuctionAuth is ERC1654Constants, ERC1271Constants, TheSandbox712, MetaTransactionReceiver {\n    struct ClaimSellerOfferRequest {\n        address buyer;\n        address payable seller;\n        address token;\n        uint256[] purchase;\n        uint256[] auctionData;\n        uint256[] ids;\n        uint256[] amounts;\n        bytes signature;\n    }\n\n    enum SignatureType {DIRECT, EIP1654, EIP1271}\n\n    bytes32 public constant AUCTION_TYPEHASH =\n        keccak256(\n            \"Auction(address from,address token,uint256 offerId,uint256 startingPrice,uint256 endingPrice,uint256 startedAt,uint256 duration,uint256 packs,bytes ids,bytes amounts)\"\n        );\n\n    event OfferClaimed(\n        address indexed seller,\n        address indexed buyer,\n        uint256 indexed offerId,\n        uint256 amount,\n        uint256 pricePaid,\n        uint256 feePaid\n    );\n    event OfferCancelled(address indexed seller, uint256 indexed offerId);\n\n    uint256 public constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    // Stack too deep, grouping parameters\n    // AuctionData:\n    uint256 public constant AuctionData_OfferId = 0;\n    uint256 public constant AuctionData_StartingPrice = 1;\n    uint256 public constant AuctionData_EndingPrice = 2;\n    uint256 public constant AuctionData_StartedAt = 3;\n    uint256 public constant AuctionData_Duration = 4;\n    uint256 public constant AuctionData_Packs = 5;\n\n    mapping(address => mapping(uint256 => uint256)) public claimed;\n\n    AssetV2 public _asset;\n    uint256 public _fee10000th = 0;\n    address payable public _feeCollector;\n\n    event FeeSetup(address feeCollector, uint256 fee10000th);\n\n    constructor(\n        AssetV2 asset,\n        address admin,\n        address initialMetaTx,\n        address payable feeCollector,\n        uint256 fee10000th\n    ) TheSandbox712() {\n        _asset = asset;\n        _feeCollector = feeCollector;\n        _fee10000th = fee10000th;\n        emit FeeSetup(feeCollector, fee10000th);\n        _admin = admin;\n        _setMetaTransactionProcessor(initialMetaTx, true);\n    }\n\n    /// @notice set fee parameters\n    /// @param feeCollector address receiving the fee\n    /// @param fee10000th fee in 10,000th\n    function setFee(address payable feeCollector, uint256 fee10000th) external {\n        require(msg.sender == _admin, \"only admin can change fee\");\n        _feeCollector = feeCollector;\n        _fee10000th = fee10000th;\n        emit FeeSetup(feeCollector, fee10000th);\n    }\n\n    function _verifyParameters(\n        address buyer,\n        address payable seller,\n        address token,\n        uint256 buyAmount,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal view {\n        require(ids.length == amounts.length, \"ids and amounts length not matching\");\n        require(\n            buyer == msg.sender || (token != address(0) && _metaTransactionContracts[msg.sender]),\n            \"not authorized\"\n        );\n        uint256 amountAlreadyClaimed = claimed[seller][auctionData[AuctionData_OfferId]];\n        require(amountAlreadyClaimed != MAX_UINT256, \"Auction cancelled\");\n\n        uint256 total = amountAlreadyClaimed + buyAmount;\n        require(total >= amountAlreadyClaimed, \"overflow\");\n        require(total <= auctionData[AuctionData_Packs], \"Buy amount exceeds sell amount\");\n\n        require(auctionData[AuctionData_StartedAt] <= block.timestamp, \"Auction didn't start yet\");\n        require(\n            auctionData[AuctionData_StartedAt] + auctionData[AuctionData_Duration] > block.timestamp,\n            \"Auction finished\"\n        );\n    }\n\n    /// @notice claim offer using EIP712\n    /// @param input Claim Seller Offer Request\n    function claimSellerOffer(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.DIRECT,\n            true\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    /// @notice claim offer using EIP712 and EIP1271 signature verification scheme\n    /// @param input Claim Seller Offer Request\n    function claimSellerOfferViaEIP1271(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.EIP1271,\n            true\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    /// @notice claim offer using EIP712 and EIP1654 signature verification scheme\n    /// @param input Claim Seller Offer Request\n    function claimSellerOfferViaEIP1654(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.EIP1654,\n            true\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    /// @notice claim offer using Basic Signature\n    /// @param input Claim Seller Offer Request\n    function claimSellerOfferUsingBasicSig(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.DIRECT,\n            false\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    /// @notice claim offer using Basic Signature and EIP1271 signature verification scheme\n    /// @param input Claim Seller Offer Request\n    function claimSellerOfferUsingBasicSigViaEIP1271(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.EIP1271,\n            false\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    /// @notice claim offer using Basic Signature and EIP1654 signature verification scheme\n    /// @param input Claim Seller Offer Request\n    function claimSellerOfferUsingBasicSigViaEIP1654(ClaimSellerOfferRequest memory input) external payable {\n        _verifyParameters(\n            input.buyer,\n            input.seller,\n            input.token,\n            input.purchase[0],\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n        _ensureCorrectSigner(\n            input.seller,\n            input.token,\n            input.auctionData,\n            input.ids,\n            input.amounts,\n            input.signature,\n            SignatureType.EIP1654,\n            false\n        );\n        _executeDeal(\n            input.token,\n            input.purchase,\n            input.buyer,\n            input.seller,\n            input.auctionData,\n            input.ids,\n            input.amounts\n        );\n    }\n\n    function _executeDeal(\n        address token,\n        uint256[] memory purchase,\n        address buyer,\n        address payable seller,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 offer =\n            PriceUtil.calculateCurrentPrice(\n                auctionData[AuctionData_StartingPrice],\n                auctionData[AuctionData_EndingPrice],\n                auctionData[AuctionData_Duration],\n                block.timestamp - auctionData[AuctionData_StartedAt]\n            ) * purchase[0];\n        claimed[seller][auctionData[AuctionData_OfferId]] =\n            claimed[seller][auctionData[AuctionData_OfferId]] +\n            purchase[0];\n\n        uint256 fee = 0;\n        if (_fee10000th > 0) {\n            fee = PriceUtil.calculateFee(offer, _fee10000th);\n        }\n\n        uint256 total = offer + fee;\n        require(total <= purchase[1], \"offer exceeds max amount to spend\");\n\n        if (token != address(0)) {\n            require(IERC20(token).transferFrom(buyer, seller, offer), \"failed to transfer token price\");\n            if (fee > 0) {\n                require(IERC20(token).transferFrom(buyer, _feeCollector, fee), \"failed to collect fee\");\n            }\n        } else {\n            require(msg.value >= total, \"ETH < total\");\n            if (msg.value > total) {\n                payable(msg.sender).transfer(msg.value - total);\n            }\n            seller.transfer(offer);\n            if (fee > 0) {\n                _feeCollector.transfer(fee);\n            }\n        }\n\n        uint256[] memory packAmounts = new uint256[](amounts.length);\n        for (uint256 i = 0; i < packAmounts.length; i++) {\n            packAmounts[i] = amounts[i] * purchase[0];\n        }\n        _asset.safeBatchTransferFrom(seller, buyer, ids, packAmounts, \"\");\n        emit OfferClaimed(seller, buyer, auctionData[AuctionData_OfferId], purchase[0], offer, fee);\n    }\n\n    /// @notice cancel a offer previously signed, new offer need to use a id not used yet\n    /// @param offerId offer to cancel\n    function cancelSellerOffer(uint256 offerId) external {\n        claimed[msg.sender][offerId] = MAX_UINT256;\n        emit OfferCancelled(msg.sender, offerId);\n    }\n\n    function _ensureCorrectSigner(\n        address from,\n        address token,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory signature,\n        SignatureType signatureType,\n        bool eip712\n    ) internal view returns (address) {\n        bytes memory dataToHash;\n        address signer;\n\n        if (eip712) {\n            dataToHash = abi.encodePacked(\n                \"\\x19\\x01\",\n                _DOMAIN_SEPARATOR,\n                _hashAuction(from, token, auctionData, ids, amounts)\n            );\n        } else {\n            dataToHash = _encodeBasicSignatureHash(from, token, auctionData, ids, amounts);\n        }\n\n        if (signatureType == SignatureType.EIP1271) {\n            require(\n                ERC1271(from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\n                \"invalid 1271 signature\"\n            );\n        } else if (signatureType == SignatureType.EIP1654) {\n            require(\n                ERC1654(from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\n                \"invalid 1654 signature\"\n            );\n        } else {\n            signer = SigUtil.recover(keccak256(dataToHash), signature);\n            require(signer == from, \"signer != from\");\n        }\n\n        return signer;\n    }\n\n    function _encodeBasicSignatureHash(\n        address from,\n        address token,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal view returns (bytes memory) {\n        return\n            SigUtil.prefixed(\n                keccak256(\n                    abi.encodePacked(\n                        address(this),\n                        AUCTION_TYPEHASH,\n                        from,\n                        token,\n                        auctionData[AuctionData_OfferId],\n                        auctionData[AuctionData_StartingPrice],\n                        auctionData[AuctionData_EndingPrice],\n                        auctionData[AuctionData_StartedAt],\n                        auctionData[AuctionData_Duration],\n                        auctionData[AuctionData_Packs],\n                        keccak256(abi.encodePacked(ids)),\n                        keccak256(abi.encodePacked(amounts))\n                    )\n                )\n            );\n    }\n\n    function _hashAuction(\n        address from,\n        address token,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    AUCTION_TYPEHASH,\n                    from,\n                    token,\n                    auctionData[AuctionData_OfferId],\n                    auctionData[AuctionData_StartingPrice],\n                    auctionData[AuctionData_EndingPrice],\n                    auctionData[AuctionData_StartedAt],\n                    auctionData[AuctionData_Duration],\n                    auctionData[AuctionData_Packs],\n                    keccak256(abi.encodePacked(ids)),\n                    keccak256(abi.encodePacked(amounts))\n                )\n            );\n    }\n}\n"
    },
    "src/solc_0.8/common/Libraries/SigUtil.sol": {
      "content": "pragma solidity 0.8.2;\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {\n        require(sig.length == 65, \"incorrect signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28, \"version of signature should be 27 or 28\");\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0), \"incorrect address\");\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig) internal pure returns (address) {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n"
    },
    "src/solc_0.8/common/Libraries/PriceUtil.sol": {
      "content": "pragma solidity 0.8.2;\n\nimport \"./SafeMathWithRequire.sol\";\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\n\nlibrary PriceUtil {\n    using SafeMathWithRequire for uint256;\n    using SafeMath for uint256;\n\n    function calculateCurrentPrice(\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 secondsPassed\n    ) internal pure returns (uint256) {\n        if (secondsPassed > duration) {\n            return endingPrice;\n        }\n        if (endingPrice == startingPrice) {\n            return endingPrice;\n        } else if (endingPrice > startingPrice) {\n            return startingPrice.add((endingPrice.sub(startingPrice)).mul(secondsPassed).div(duration));\n        } else {\n            return startingPrice.sub((startingPrice.sub(endingPrice)).mul(secondsPassed).div(duration));\n        }\n    }\n\n    function calculateFee(uint256 price, uint256 fee10000th) internal pure returns (uint256) {\n        // _fee < 10000, so the result will be <= price\n        return (price.mul(fee10000th)) / 10000;\n    }\n}\n"
    },
    "src/solc_0.8/asset/AssetV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"./ERC1155ERC721.sol\";\nimport \"../common/interfaces/IAssetAttributesRegistry.sol\";\nimport \"./libraries/AssetHelper.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ncontract AssetV2 is ERC1155ERC721 {\n    AssetHelper.AssetRegistryData private assetRegistryData;\n\n    /// @notice fulfills the purpose of a constructor in upgradeable contracts\n    function initialize(\n        address trustedForwarder,\n        address admin,\n        address bouncerAdmin,\n        address predicate,\n        uint8 chainIndex,\n        address assetRegistry\n    ) external {\n        initV2(trustedForwarder, admin, bouncerAdmin, predicate, chainIndex);\n        assetRegistryData.assetRegistry = IAssetAttributesRegistry(assetRegistry);\n    }\n\n    /// @notice called by predicate to mint tokens transferred from L2\n    /// @param to address to mint to\n    /// @param ids ids to mint\n    /// @param amounts supply for each token type\n    /// @param data extra data to accompany the minting call\n    function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        require(_msgSender() == _predicate, \"!PREDICATE\");\n        bytes32[] memory hashes = AssetHelper.decodeAndSetCatalystDataL2toL1(assetRegistryData, data);\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 uriId = ids[i] & ERC1155ERC721Helper.URI_ID;\n            _metadataHash[uriId] = hashes[i];\n            _rarityPacks[uriId] = \"0x00\";\n            uint16 numNFTs = 0;\n            if ((ids[i] & ERC1155ERC721Helper.IS_NFT) > 0) {\n                numNFTs = 1;\n            }\n            uint256[] memory singleId = new uint256[](1);\n            singleId[0] = ids[i];\n            uint256[] memory singleAmount = new uint256[](1);\n            singleAmount[0] = amounts[i];\n            _mintBatches(singleAmount, to, singleId, numNFTs);\n        }\n    }\n}\n"
    },
    "src/solc_0.8/common/BaseWithStorage/MetaTransactionReceiver.sol": {
      "content": "pragma solidity 0.8.2;\n\nimport \"./WithAdmin.sol\";\n\ncontract MetaTransactionReceiver is WithAdmin {\n    mapping(address => bool) internal _metaTransactionContracts;\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @notice Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(msg.sender == _admin, \"only admin can setup metaTransactionProcessors\");\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @notice check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns (bool) {\n        return _metaTransactionContracts[who];\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/ERC1271.sol": {
      "content": "pragma solidity 0.8.2;\n\ninterface ERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param data Arbitrary length data signed on the behalf of address(this)\n     * @param signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory data, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/solc_0.8/common/interfaces/ERC1271Constants.sol": {
      "content": "pragma solidity 0.8.2;\n\ncontract ERC1271Constants {\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n"
    },
    "src/solc_0.8/common/interfaces/ERC1654.sol": {
      "content": "pragma solidity 0.8.2;\n\ninterface ERC1654 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param hash 32 bytes hash to be signed\n     * @param signature Signature byte array associated with hash\n     * @return magicValue - 0x1626ba7e if valid else 0x00000000\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/solc_0.8/common/interfaces/ERC1654Constants.sol": {
      "content": "pragma solidity 0.8.2;\n\ncontract ERC1654Constants {\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\n}\n"
    },
    "src/solc_0.8/bundleSandSale/PolygonBundleSandSale.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/interfaces/IERC20.sol\";\nimport \"../common/interfaces/Medianizer.sol\";\nimport \"../common/interfaces/IERC1155TokenReceiver.sol\";\nimport \"../common/BaseWithStorage/WithAdmin.sol\";\nimport \"../asset/ERC1155ERC721.sol\";\n\n/// @title PolygonBundleSandSale contract.\n/// @notice This contract receives bundles of: Assets (ERC1155) + Sand.\n/// @notice Then those bundles are sold to users. Users can pay BaseCoin (Ethers) or Dais for the bundles.\ncontract PolygonBundleSandSale is WithAdmin, IERC1155TokenReceiver {\n    bytes4 public constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 public constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n\n    event BundleSale(\n        uint256 indexed saleId,\n        uint256[] ids,\n        uint256[] amounts,\n        uint256 sandAmount,\n        uint256 priceUSD,\n        uint256 numPacks\n    );\n\n    event BundleSold(\n        uint256 indexed saleId,\n        address indexed buyer,\n        uint256 numPacks,\n        address token,\n        uint256 tokenAmount\n    );\n\n    Medianizer public medianizer;\n    IERC20 public dai;\n    IERC20 public sand;\n    ERC1155ERC721 public asset;\n    address payable public receivingWallet;\n\n    /*\n        This is the main structure representing a pack to be sold.\n        Each pack includes some Assets (NFTs or small collection of fungible tokens) plus Sand\n    */\n    struct Sale {\n        uint256[] ids; // ids of the Assets in each pack\n        uint256[] amounts; // Amount of each Asset  in each pack\n        uint256 sandAmount; // Sands sold with each pack\n        uint256 priceUSD; // Price in USD for each Pack u$s * 1e18 (aka: 1u$s == 1e18 wei)\n        uint256 numPacksLeft; // Number of packs left, used for accounting\n    }\n\n    Sale[] private sales;\n\n    constructor(\n        IERC20 sandTokenContractAddress,\n        ERC1155ERC721 assetTokenContractAddress,\n        Medianizer medianizerContractAddress,\n        IERC20 daiTokenContractAddress,\n        address admin,\n        address payable receivingWallet_\n    ) {\n        require(receivingWallet_ != address(0), \"need a wallet to receive funds\");\n        medianizer = medianizerContractAddress;\n        sand = sandTokenContractAddress;\n        asset = assetTokenContractAddress;\n        dai = daiTokenContractAddress;\n        _admin = admin;\n        receivingWallet = receivingWallet_;\n    }\n\n    /// @notice set the wallet receiving the proceeds\n    /// @param newWallet address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external onlyAdmin {\n        require(newWallet != address(0), \"receiving wallet cannot be zero address\");\n        receivingWallet = newWallet;\n    }\n\n    /**\n     * @notice Buys Sand Bundle with Ether\n     * @param saleId id of the bundle\n     * @param numPacks the amount of packs to buy\n     * @param to The address that will receive the SAND\n     */\n    function buyBundleWithEther(\n        uint256 saleId,\n        uint256 numPacks,\n        address to\n    ) external payable {\n        (uint256 saleIndex, uint256 usdRequired) = _getSaleAmount(saleId, numPacks);\n        uint256 ethRequired = getEtherAmountWithUSD(usdRequired);\n        require(msg.value >= ethRequired, \"not enough ether sent\");\n        uint256 leftOver = msg.value - ethRequired;\n        if (leftOver > 0) {\n            payable(msg.sender).transfer(leftOver);\n            // refund extra\n        }\n        payable(receivingWallet).transfer(ethRequired);\n        _transferPack(saleIndex, numPacks, to);\n\n        emit BundleSold(saleId, msg.sender, numPacks, address(0), ethRequired);\n    }\n\n    /**\n     * @notice Buys Sand Bundle with DAI\n     * @param saleId id of the bundle\n     * @param numPacks the amount of packs to buy\n     * @param to The address that will receive the SAND\n     */\n    function buyBundleWithDai(\n        uint256 saleId,\n        uint256 numPacks,\n        address to\n    ) external {\n        (uint256 saleIndex, uint256 usdRequired) = _getSaleAmount(saleId, numPacks);\n        require(dai.transferFrom(msg.sender, receivingWallet, usdRequired), \"failed to transfer dai\");\n        _transferPack(saleIndex, numPacks, to);\n\n        emit BundleSold(saleId, msg.sender, numPacks, address(dai), usdRequired);\n    }\n\n    /**\n     * @notice get a specific sale information\n     * @param saleId id of the bundle\n     * @return priceUSD price in USD\n     * @return numPacksLeft number of packs left\n     */\n    function getSaleInfo(uint256 saleId) external view returns (uint256 priceUSD, uint256 numPacksLeft) {\n        require(saleId > 0, \"invalid saleId\");\n        uint256 saleIndex = saleId - 1;\n        priceUSD = sales[saleIndex].priceUSD;\n        numPacksLeft = sales[saleIndex].numPacksLeft;\n    }\n\n    /**\n     * @notice Remove a sale returning everything to some address\n     * @param saleId id of the bundle\n     * @param to The address that will receive the SAND\n     */\n    function withdrawSale(uint256 saleId, address to) external onlyAdmin {\n        require(saleId > 0, \"invalid saleId\");\n        uint256 saleIndex = saleId - 1;\n        uint256 numPacksLeft = sales[saleIndex].numPacksLeft;\n        sales[saleIndex].numPacksLeft = 0;\n\n        uint256[] memory ids = sales[saleIndex].ids;\n        uint256[] memory amounts = sales[saleIndex].amounts;\n        uint256 numIds = ids.length;\n        for (uint256 i = 0; i < numIds; i++) {\n            amounts[i] = amounts[i] * numPacksLeft;\n        }\n        require(\n            sand.transferFrom(address(this), to, numPacksLeft * sales[saleIndex].sandAmount),\n            \"transfer fo Sand failed\"\n        );\n        asset.safeBatchTransferFrom(address(this), to, ids, amounts, \"\");\n    }\n\n    /**\n     * @notice IERC1155TokenReceiver callback, creates a new Sale\n     * @notice OBS: in the case of NFTs (one of a kind) value is one so numPacks must be 1 too to be divisible.\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(address(asset) == msg.sender, \"only accept asset as sender\");\n        require(from == operator, \"only self executed transfer allowed\");\n        require(value > 0, \"no Asset transfered\");\n        require(data.length > 0, \"data need to contains the sale data\");\n\n        (uint256 numPacks, uint256 sandAmountPerPack, uint256 priceUSDPerPack) =\n            abi.decode(data, (uint256, uint256, uint256));\n\n        uint256 amount = value / numPacks;\n        require(amount * numPacks == value, \"invalid amounts, not divisible by numPacks\");\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n        uint256[] memory ids = new uint256[](1);\n        ids[0] = id;\n        _setupBundle(from, sandAmountPerPack, numPacks, ids, amounts, priceUSDPerPack);\n        return ERC1155_RECEIVED;\n    }\n\n    /**\n     * @notice IERC1155TokenReceiver callback, creates a new Sale\n     * @notice OBS: in the case of NFTs (one of a kind) value is one so numPacks must be 1 too to be divisible.\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(address(asset) == msg.sender, \"only accept asset as sender\");\n        require(from == operator, \"only self executed transfer allowed\");\n        require(ids.length > 0, \"need to contains Asset\");\n        require(data.length > 0, \"data need to contains the sale data\");\n\n        (uint256 numPacks, uint256 sandAmountPerPack, uint256 priceUSDPerPack) =\n            abi.decode(data, (uint256, uint256, uint256));\n\n        uint256[] memory amounts = new uint256[](ids.length);\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(values[i] > 0, \"asset transfer with zero values\");\n            uint256 amount = values[i] / numPacks;\n            require(amount * numPacks == values[i], \"invalid amounts, not divisible by numPacks\");\n            amounts[i] = amount;\n        }\n\n        _setupBundle(from, sandAmountPerPack, numPacks, ids, amounts, priceUSDPerPack);\n        return ERC1155_BATCH_RECEIVED;\n    }\n\n    /**\n     * @notice Returns the amount of ETH for a specific amount\n     * @notice This rounds down with a precision of 1wei if usdAmount price is expressed in u$s * 10e18\n     * @param usdAmount An amount of USD\n     * @return The amount of ETH\n     */\n    function getEtherAmountWithUSD(uint256 usdAmount) public view returns (uint256) {\n        uint256 ethUsdPair = getEthUsdPair();\n        return (usdAmount * 1 ether) / ethUsdPair;\n    }\n\n    /**\n     * @notice Gets the ETHUSD pair from the Medianizer contract\n     * @return The pair as an uint256\n     */\n    function getEthUsdPair() internal view returns (uint256) {\n        bytes32 pair = medianizer.read();\n        return uint256(pair);\n    }\n\n    function _transferPack(\n        uint256 saleIndex,\n        uint256 numPacks,\n        address to\n    ) internal {\n        uint256 sandAmountPerPack = sales[saleIndex].sandAmount;\n        require(sand.transferFrom(address(this), to, sandAmountPerPack * numPacks), \"Sand Transfer failed\");\n        uint256[] memory ids = sales[saleIndex].ids;\n        uint256[] memory amounts = sales[saleIndex].amounts;\n        uint256 numIds = ids.length;\n        for (uint256 i = 0; i < numIds; i++) {\n            amounts[i] = amounts[i] * numPacks;\n        }\n        asset.safeBatchTransferFrom(address(this), to, ids, amounts, \"\");\n    }\n\n    /**\n     * @notice Create a Sale to be sold.\n     * @param from seller address\n     * @param sandAmountPerPack the sands that will be sell with the Sale\n     * @param numPacks number of packs that this sale contains\n     * @param ids list of ids to create bundle from\n     * @param amounts the corresponding amounts of assets to be bundled for sale\n     * @param priceUSDPerPack price in USD per pack\n     */\n    function _setupBundle(\n        address from,\n        uint256 sandAmountPerPack,\n        uint256 numPacks,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256 priceUSDPerPack\n    ) internal {\n        require(sand.transferFrom(from, address(this), sandAmountPerPack * numPacks), \"failed to transfer Sand\");\n        sales.push(\n            Sale({\n                ids: ids,\n                amounts: amounts,\n                sandAmount: sandAmountPerPack,\n                priceUSD: priceUSDPerPack,\n                numPacksLeft: numPacks\n            })\n        );\n        uint256 saleId = sales.length;\n        emit BundleSale(saleId, ids, amounts, sandAmountPerPack, priceUSDPerPack, numPacks);\n    }\n\n    function _getSaleAmount(uint256 saleId, uint256 numPacks)\n        internal\n        returns (uint256 saleIndex, uint256 usdRequired)\n    {\n        require(saleId > 0, \"PolygonBundleSandSale: invalid saleId\");\n        saleIndex = saleId - 1;\n        uint256 numPacksLeft = sales[saleIndex].numPacksLeft;\n        require(numPacksLeft >= numPacks, \"PolygonBundleSandSale: not enough packs on sale\");\n        sales[saleIndex].numPacksLeft = numPacksLeft - numPacks;\n\n        usdRequired = numPacks * sales[saleIndex].priceUSD;\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/Medianizer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\n/**\n * @title Medianizer contract\n * @dev From MakerDAO (https://etherscan.io/address/0x729D19f657BD0614b4985Cf1D82531c67569197B#code)\n */\ninterface Medianizer {\n    function read() external view returns (bytes32);\n}\n"
    },
    "src/solc_0.8/test/MockSafeMathWithRequire.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\n\n/**\n * @title SafeMathWithRequire\n * @dev Specific Mock to test SafeMathWithRequire\n */\ncontract MockSafeMathWithRequire {\n    function sqrt6(uint256 a) external pure returns (uint256 c) {\n        return SafeMathWithRequire.sqrt6(a);\n    }\n\n    function sqrt3(uint256 a) external pure returns (uint256 c) {\n        return SafeMathWithRequire.sqrt3(a);\n    }\n\n    function cbrt6(uint256 a) external pure returns (uint256 c) {\n        return SafeMathWithRequire.cbrt6(a);\n    }\n\n    function cbrt3(uint256 a) external pure returns (uint256 c) {\n        return SafeMathWithRequire.cbrt3(a);\n    }\n}\n"
    },
    "src/solc_0.8/defi/contributionCalculation/LandOwnerContributionCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport {Ownable} from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport {IERC721} from \"@openzeppelin/contracts-0.8/token/ERC721/IERC721.sol\";\nimport {SafeMathWithRequire} from \"../../common/Libraries/SafeMathWithRequire.sol\";\nimport {IContributionCalculator} from \"../interfaces/IContributionCalculator.sol\";\n\ncontract LandOwnersAloneContributionCalculator is IContributionCalculator, Ownable {\n    using Address for address;\n\n    IERC721 public multiplierNFToken;\n\n    constructor(IERC721 multiplierNFToken_) {\n        multiplierNFToken = multiplierNFToken_;\n    }\n\n    function multiplierOf(address account) external view virtual returns (uint256) {\n        return multiplierNFToken.balanceOf(account);\n    }\n\n    function computeContribution(address account, uint256 amountStaked) external view override returns (uint256) {\n        uint256 numLands = multiplierNFToken.balanceOf(account);\n        if (numLands > 0) {\n            return amountStaked;\n        }\n        return 0;\n    }\n\n    function setNFTMultiplierToken(address newNFTMultiplierToken) external onlyOwner {\n        require(newNFTMultiplierToken.isContract(), \"LandOwnersAloneContributionCalc: Bad NFTMultiplierToken address\");\n        multiplierNFToken = IERC721(newNFTMultiplierToken);\n    }\n}\n"
    },
    "src/solc_0.8/test/ContributionCalculatorMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"../defi/interfaces/IContributionCalculator.sol\";\n\ncontract ContributionCalculatorMock is IContributionCalculator {\n    mapping(address => uint256) public contribution;\n\n    function computeContribution(address account, uint256) external view override returns (uint256) {\n        return contribution[account];\n    }\n\n    function setContribution(address account, uint256 contribution_) external {\n        contribution[account] = contribution_;\n    }\n}\n"
    },
    "src/solc_0.8/defi/contributionCalculation/LandContributionCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport {Ownable} from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport {IERC721} from \"@openzeppelin/contracts-0.8/token/ERC721/IERC721.sol\";\nimport {SafeMathWithRequire} from \"../../common/Libraries/SafeMathWithRequire.sol\";\nimport {IContributionCalculator} from \"../interfaces/IContributionCalculator.sol\";\n\ncontract LandContributionCalculator is IContributionCalculator, Ownable {\n    using Address for address;\n\n    uint256 internal constant DECIMALS_9 = 1000000000;\n    uint256 internal constant MIDPOINT_9 = 500000000;\n    uint256 internal constant NFT_FACTOR_6 = 10000;\n    uint256 internal constant NFT_CONSTANT_3 = 9000;\n    uint256 internal constant ROOT3_FACTOR = 697;\n\n    IERC721 public multiplierNFToken;\n\n    constructor(IERC721 multiplierNFToken_) {\n        multiplierNFToken = multiplierNFToken_;\n    }\n\n    function multiplierOf(address account) external view virtual returns (uint256) {\n        return multiplierNFToken.balanceOf(account);\n    }\n\n    function computeContribution(address account, uint256 amountStaked) external view override returns (uint256) {\n        uint256 numLands = multiplierNFToken.balanceOf(account);\n        return _contribution(amountStaked, numLands);\n    }\n\n    function contribution(uint256 amountStaked, uint256 numLands) external pure returns (uint256) {\n        return _contribution(amountStaked, numLands);\n    }\n\n    function setNFTMultiplierToken(address newNFTMultiplierToken) external onlyOwner {\n        require(newNFTMultiplierToken.isContract(), \"LandContributionCalc: Bad NFTMultiplierToken address\");\n        multiplierNFToken = IERC721(newNFTMultiplierToken);\n    }\n\n    function _contribution(uint256 amountStaked, uint256 numLands) internal pure returns (uint256) {\n        if (numLands == 0) {\n            return amountStaked;\n        }\n        uint256 nftContrib =\n            NFT_FACTOR_6 * (NFT_CONSTANT_3 + SafeMathWithRequire.cbrt3((((numLands - 1) * ROOT3_FACTOR) + 1)));\n        if (nftContrib > MIDPOINT_9) {\n            nftContrib = MIDPOINT_9 + (nftContrib - MIDPOINT_9) / 10;\n        }\n        return amountStaked + ((amountStaked * nftContrib) / DECIMALS_9);\n    }\n}\n"
    },
    "src/solc_0.8/asset/AssetMinter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"../common/interfaces/IAssetMinter.sol\";\nimport \"../catalyst/GemsCatalystsRegistry.sol\";\nimport \"../common/interfaces/IAssetToken.sol\";\n\n/// @notice Allow to mint Asset with Catalyst, Gems and Sand, giving the assets attributes through AssetAttributeRegistry\ncontract AssetMinter is ERC2771Handler, IAssetMinter, Ownable {\n    uint256 private constant NFT_SUPPLY = 1;\n\n    uint32 public numberOfGemsBurnPerAsset = 1;\n    uint32 public numberOfCatalystBurnPerAsset = 1;\n    uint256 public gemsFactor = 1000000000000000000;\n    uint256 public catalystsFactor = 1000000000000000000;\n\n    IAssetAttributesRegistry internal immutable _registry;\n    IAssetToken internal immutable _asset;\n    GemsCatalystsRegistry internal immutable _gemsCatalystsRegistry;\n\n    mapping(uint16 => uint256) public quantitiesByCatalystId;\n    mapping(uint16 => uint256) public quantitiesByAssetTypeId; // quantities for asset that don't use catalyst to burn (art, prop...)\n    mapping(address => bool) public customMinterAllowance;\n\n    /// @notice AssetMinter depends on\n    /// @param registry: AssetAttributesRegistry for recording catalyst and gems used\n    /// @param asset: Asset Token Contract (dual ERC1155/ERC721)\n    /// @param gemsCatalystsRegistry: that track the canonical catalyst and gems and provide batch burning facility\n    /// @param trustedForwarder: address of the trusted forwarder (used for metaTX)\n    constructor(\n        IAssetAttributesRegistry registry,\n        IAssetToken asset,\n        GemsCatalystsRegistry gemsCatalystsRegistry,\n        address admin,\n        address trustedForwarder,\n        uint256[] memory quantitiesByCatalystId_,\n        uint256[] memory quantitiesByAssetTypeId_\n    ) {\n        _registry = registry;\n        _asset = asset;\n        _gemsCatalystsRegistry = gemsCatalystsRegistry;\n        transferOwnership(admin);\n        __ERC2771Handler_initialize(trustedForwarder);\n\n        require(quantitiesByCatalystId_.length > 0, \"AssetMinter: quantitiesByCatalystID length cannot be 0\");\n        require(quantitiesByAssetTypeId_.length > 0, \"AssetMinter: quantitiesByAssetTypeId length cannot be 0\");\n\n        for (uint16 i = 0; i < quantitiesByCatalystId_.length; i++) {\n            quantitiesByCatalystId[i + 1] = quantitiesByCatalystId_[i];\n        }\n\n        for (uint16 i = 0; i < quantitiesByAssetTypeId_.length; i++) {\n            quantitiesByAssetTypeId[i + 1] = quantitiesByAssetTypeId_[i];\n        }\n    }\n\n    function addOrReplaceQuantitiyByCatalystId(uint16 catalystId, uint256 newQuantity) external override onlyOwner {\n        quantitiesByCatalystId[catalystId] = newQuantity;\n    }\n\n    function addOrReplaceAssetTypeQuantity(uint16 index1Based, uint256 newQuantity) external override onlyOwner {\n        quantitiesByAssetTypeId[index1Based] = newQuantity;\n    }\n\n    function setNumberOfGemsBurnPerAsset(uint32 newQuantity) external override onlyOwner {\n        numberOfGemsBurnPerAsset = newQuantity;\n    }\n\n    function setNumberOfCatalystsBurnPerAsset(uint32 newQuantity) external override onlyOwner {\n        numberOfCatalystBurnPerAsset = newQuantity;\n    }\n\n    function setGemsFactor(uint256 newQuantity) external override onlyOwner {\n        gemsFactor = newQuantity;\n    }\n\n    function setCatalystsFactor(uint256 newQuantity) external override onlyOwner {\n        catalystsFactor = newQuantity;\n    }\n\n    function setCustomMintingAllowance(address addressToModify, bool isAddressAllowed) external override onlyOwner {\n        customMinterAllowance[addressToModify] = isAddressAllowed;\n    }\n\n    /// @notice mint \"quantity\" number of Asset token using one catalyst.\n    /// @param mintData (-from address creating the Asset, need to be the tx sender or meta tx signer.\n    ///  -packId unused packId that will let you predict the resulting tokenId.\n    /// - metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// - to destination address receiving the minted tokens.\n    /// - data extra data)\n    /// @param catalystId Id of the Catalyst ERC20 token to burn (1, 2, 3 or 4).\n    /// @param gemIds list of gem ids to burn in the catalyst.\n    /// @param quantity number of token to mint\n    /// @return assetId The new token Id.\n    function mintCustomNumberWithCatalyst(\n        MintData calldata mintData,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        uint256 quantity\n    ) external override returns (uint256 assetId) {\n        require(\n            customMinterAllowance[_msgSender()] == true || _msgSender() == owner(),\n            \"AssetyMinter: custom minting unauthorized\"\n        );\n        assetId = _burnAndMint(\n            mintData.from,\n            mintData.packId,\n            mintData.metadataHash,\n            catalystId,\n            gemIds,\n            quantity,\n            mintData.to,\n            mintData.data\n        );\n    }\n\n    /// @notice mint one Asset token with no catalyst.\n    /// @param mintData : (-from address creating the Asset, need to be the tx sender or meta tx signer.\n    ///  -packId unused packId that will let you predict the resulting tokenId.\n    /// - metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// - to destination address receiving the minted tokens.\n    /// - data extra data)\n    /// @param typeAsset1Based (art, prop...) decide how many asset will be minted (start at 1)\n    /// @return assetId The new token Id.\n    function mintWithoutCatalyst(MintData calldata mintData, uint16 typeAsset1Based)\n        external\n        override\n        returns (uint256 assetId)\n    {\n        uint256 quantity = quantitiesByAssetTypeId[typeAsset1Based];\n\n        _mintRequirements(mintData.from, quantity, mintData.to);\n        assetId = _asset.mint(\n            mintData.from,\n            mintData.packId,\n            mintData.metadataHash,\n            quantity,\n            0,\n            mintData.to,\n            mintData.data\n        );\n    }\n\n    /// @notice mint multiple Asset tokens using one catalyst.\n    /// @param mintData : (-from address creating the Asset, need to be the tx sender or meta tx signer.\n    ///  -packId unused packId that will let you predict the resulting tokenId.\n    /// - metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// - to destination address receiving the minted tokens.\n    /// - data extra data)\n    /// @param catalystId Id of the Catalyst ERC20 token to burn (1, 2, 3 or 4).\n    /// @param gemIds list of gem ids to burn in the catalyst.\n    /// @return assetId The new token Id.\n    function mintWithCatalyst(\n        MintData calldata mintData,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external override returns (uint256 assetId) {\n        uint256 quantity = quantitiesByCatalystId[catalystId];\n\n        assetId = _burnAndMint(\n            mintData.from,\n            mintData.packId,\n            mintData.metadataHash,\n            catalystId,\n            gemIds,\n            quantity,\n            mintData.to,\n            mintData.data\n        );\n    }\n\n    /// @notice mint multiple Asset tokens.\n    /// @param mintData contains (-from address creating the Asset, need to be the tx sender or meta tx signer\n    /// -packId unused packId that will let you predict the resulting tokenId\n    /// -metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata)\n    /// @param assets data (gems and catalyst data)\n    function mintMultipleWithCatalyst(MintData calldata mintData, AssetData[] memory assets)\n        external\n        override\n        returns (uint256[] memory assetIds)\n    {\n        require(assets.length != 0, \"INVALID_0_ASSETS\");\n        require(mintData.to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n\n        require(_msgSender() == mintData.from, \"AUTH_ACCESS_DENIED\");\n\n        uint256[] memory supplies = _handleMultipleAssetRequirements(mintData.from, assets);\n        assetIds = _asset.mintMultiple(\n            mintData.from,\n            mintData.packId,\n            mintData.metadataHash,\n            supplies,\n            \"\",\n            mintData.to,\n            mintData.data\n        );\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            require(assets[i].catalystId != 0, \"AssetMinter: catalystID can't be 0\");\n            _registry.setCatalyst(assetIds[i], assets[i].catalystId, assets[i].gemIds);\n        }\n        return assetIds;\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @dev Handler for dealing with assets when minting multiple at once.\n    /// @param from The original address that signed the transaction.\n    /// @param assets An array of AssetData structs to define how the total gems and catalysts are to be allocated.\n    /// @return supplies An array of the quantities for each asset being minted.\n    function _handleMultipleAssetRequirements(address from, AssetData[] memory assets)\n        internal\n        returns (uint256[] memory supplies)\n    {\n        supplies = new uint256[](assets.length);\n        uint256[] memory catalystsToBurn = new uint256[](_gemsCatalystsRegistry.getNumberOfCatalystContracts());\n        uint256[] memory gemsToBurn = new uint256[](_gemsCatalystsRegistry.getNumberOfGemContracts());\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(\n                assets[i].catalystId > 0 && assets[i].catalystId <= catalystsToBurn.length,\n                \"AssetMinter: catalystID out of bound\"\n            );\n            catalystsToBurn[assets[i].catalystId - 1]++;\n            for (uint256 j = 0; j < assets[i].gemIds.length; j++) {\n                require(\n                    assets[i].gemIds[j] > 0 && assets[i].gemIds[j] <= gemsToBurn.length,\n                    \"AssetMinter: gemId out of bound\"\n                );\n                gemsToBurn[assets[i].gemIds[j] - 1]++;\n            }\n\n            uint16 maxGems = _gemsCatalystsRegistry.getMaxGems(assets[i].catalystId);\n            require(assets[i].gemIds.length <= maxGems, \"AssetMinter: too many gems\");\n            supplies[i] = quantitiesByCatalystId[assets[i].catalystId];\n        }\n        _batchBurnCatalysts(from, catalystsToBurn);\n        _batchBurnGems(from, gemsToBurn);\n    }\n\n    /// @dev Burn a batch of catalysts in one tx.\n    /// @param from The original address that signed the tx.\n    /// @param catalystsQuantities An array of quantities for each type of catalyst to burn.\n    function _batchBurnCatalysts(address from, uint256[] memory catalystsQuantities) internal {\n        uint16[] memory ids = new uint16[](catalystsQuantities.length);\n        for (uint16 i = 0; i < ids.length; i++) {\n            ids[i] = i + 1;\n        }\n        _gemsCatalystsRegistry.batchBurnCatalysts(from, ids, _scaleCatalystQuantities(catalystsQuantities));\n    }\n\n    /// @dev Burn a batch of gems in one tx.\n    /// @param from The original address that signed the tx.\n    /// @param gemsQuantities An array of quantities for each type of gems to burn.\n    function _batchBurnGems(address from, uint256[] memory gemsQuantities) internal {\n        uint16[] memory ids = new uint16[](gemsQuantities.length);\n        for (uint16 i = 0; i < ids.length; i++) {\n            ids[i] = i + 1;\n        }\n        _gemsCatalystsRegistry.batchBurnGems(from, ids, _scaleGemQuantities(gemsQuantities));\n    }\n\n    /// @dev Burn an array of gems.\n    /// @param from The original signer of the tx.\n    /// @param gemIds The array of gems to burn.\n    /// @param numTimes Amount of gems to burn.\n    function _burnGems(\n        address from,\n        uint16[] memory gemIds,\n        uint32 numTimes\n    ) internal {\n        _gemsCatalystsRegistry.burnDifferentGems(from, gemIds, numTimes * gemsFactor);\n    }\n\n    /// @dev Burn a single type of catalyst.\n    /// @param from The original signer of the tx.\n    /// @param catalystId The type of catalyst to burn.\n    /// @param numTimes Amount of catalysts of this type to burn.\n    function _burnCatalyst(\n        address from,\n        uint16 catalystId,\n        uint32 numTimes\n    ) internal {\n        _gemsCatalystsRegistry.burnCatalyst(from, catalystId, numTimes * catalystsFactor);\n    }\n\n    /// @dev Scale up each number in an array of quantities by a factor of gemsUnits.\n    /// @param quantities The array of numbers to scale.\n    /// @return scaledQuantities The scaled-up values.\n    function _scaleGemQuantities(uint256[] memory quantities)\n        internal\n        view\n        returns (uint256[] memory scaledQuantities)\n    {\n        scaledQuantities = new uint256[](quantities.length);\n        for (uint256 i = 0; i < quantities.length; i++) {\n            scaledQuantities[i] = quantities[i] * gemsFactor * numberOfGemsBurnPerAsset;\n        }\n    }\n\n    /// @dev Scale up each number in an array of quantities by a factor of gemsUnits.\n    /// @param quantities The array of numbers to scale.\n    /// @return scaledQuantities The scaled-up values.\n    function _scaleCatalystQuantities(uint256[] memory quantities)\n        internal\n        view\n        returns (uint256[] memory scaledQuantities)\n    {\n        scaledQuantities = new uint256[](quantities.length);\n        for (uint256 i = 0; i < quantities.length; i++) {\n            scaledQuantities[i] = quantities[i] * catalystsFactor * numberOfCatalystBurnPerAsset;\n        }\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    function _mintRequirements(\n        address from,\n        uint256 quantity,\n        address to\n    ) internal view {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(_msgSender() == from, \"AUTH_ACCESS_DENIED\");\n        require(quantity != 0, \"AssetMinter: quantity cannot be 0\");\n    }\n\n    function _burnAndMint(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        uint256 quantity,\n        address to,\n        bytes calldata data\n    ) internal returns (uint256 assetId) {\n        _mintRequirements(from, quantity, to);\n\n        _burnCatalyst(from, catalystId, numberOfCatalystBurnPerAsset);\n        _burnGems(from, gemIds, numberOfGemsBurnPerAsset);\n\n        assetId = _asset.mint(from, packId, metadataHash, quantity, 0, to, data);\n        _registry.setCatalyst(assetId, catalystId, gemIds);\n    }\n}\n"
    },
    "src/solc_0.8/common/interfaces/IAssetMinter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\ninterface IAssetMinter {\n    struct AssetData {\n        uint16[] gemIds;\n        uint16 catalystId;\n    }\n\n    // use only to fix stack too deep\n    struct MintData {\n        address from;\n        address to;\n        uint40 packId;\n        bytes32 metadataHash;\n        bytes data;\n    }\n\n    function mintWithoutCatalyst(MintData calldata mintData, uint16 typeAsset1Based) external returns (uint256 assetId);\n\n    function mintWithCatalyst(\n        MintData calldata mintData,\n        uint16 catalystId,\n        uint16[] calldata gemIds\n    ) external returns (uint256 assetId);\n\n    function mintMultipleWithCatalyst(MintData calldata mintData, AssetData[] memory assets)\n        external\n        returns (uint256[] memory assetIds);\n\n    function mintCustomNumberWithCatalyst(\n        MintData calldata mintData,\n        uint16 catalystId,\n        uint16[] calldata gemIds,\n        uint256 quantity\n    ) external returns (uint256 assetId);\n\n    function addOrReplaceQuantitiyByCatalystId(uint16 catalystId, uint256 newQuantity) external;\n\n    function addOrReplaceAssetTypeQuantity(uint16 index1Based, uint256 newQuantity) external;\n\n    function setNumberOfGemsBurnPerAsset(uint32 newQuantity) external;\n\n    function setNumberOfCatalystsBurnPerAsset(uint32 newQuantity) external;\n\n    function setGemsFactor(uint256 newQuantity) external;\n\n    function setCatalystsFactor(uint256 newQuantity) external;\n\n    function setCustomMintingAllowance(address addressToModify, bool isAddressAllowed) external;\n}\n"
    },
    "src/solc_0.8/catalyst/DefaultAttributes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"../common/interfaces/IAttributes.sol\";\n\ncontract DefaultAttributes is IAttributes {\n    uint256 internal constant MAX_NUM_GEMS = 15;\n    uint256 internal constant MAX_NUM_GEM_TYPES = 256;\n\n    /// @notice Returns the values for each gem included in a given asset.\n    /// @param assetId The asset tokenId.\n    /// @param events An array of GemEvents. Be aware that only gemEvents from the last CatalystApplied event onwards should be used to populate a query. If gemEvents from multiple CatalystApplied events are included the output values will be incorrect.\n    /// @return values An array of values for each gem present in the asset.\n    function getAttributes(uint256 assetId, IAssetAttributesRegistry.GemEvent[] calldata events)\n        external\n        pure\n        override\n        returns (uint32[] memory values)\n    {\n        values = new uint32[](MAX_NUM_GEM_TYPES);\n\n        uint256 numGems;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGems += events[i].gemIds.length;\n        }\n        require(numGems <= MAX_NUM_GEMS, \"TOO_MANY_GEMS\");\n\n        uint32 minValue = (uint32(numGems) - 1) * 5 + 1;\n\n        uint256 numGemsSoFar = 0;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGemsSoFar += events[i].gemIds.length;\n            for (uint256 j = 0; j < events[i].gemIds.length; j++) {\n                uint256 gemId = events[i].gemIds[j];\n                uint256 slotIndex = numGemsSoFar - events[i].gemIds.length + j;\n                if (values[gemId] == 0) {\n                    // first gem : value = roll between ((numGemsSoFar-1)*5+1) and 25\n                    values[gemId] = _computeValue(\n                        assetId,\n                        gemId,\n                        events[i].blockHash,\n                        slotIndex,\n                        (uint32(numGemsSoFar) - 1) * 5 + 1\n                    );\n                    // bump previous values:\n                    if (values[gemId] < minValue) {\n                        values[gemId] = minValue;\n                    }\n                } else {\n                    // further gem, previous roll are overriden with 25 and new roll between 1 and 25\n                    uint32 newRoll = _computeValue(assetId, gemId, events[i].blockHash, slotIndex, 1);\n                    values[gemId] = (((values[gemId] - 1) / 25) + 1) * 25 + newRoll;\n                }\n            }\n        }\n    }\n\n    /// @dev compute a random value between min to 25.\n    /// example: 1-25, 6-25, 11-25, 16-25\n    /// @param assetId The id of the asset.\n    /// @param gemId The id of the gem.\n    /// @param blockHash The blockHash from the gemEvent.\n    /// @param slotIndex Index of the current gem.\n    /// @param min The minumum value this gem can have.\n    /// @return The computed value for the given gem.\n    function _computeValue(\n        uint256 assetId,\n        uint256 gemId,\n        bytes32 blockHash,\n        uint256 slotIndex,\n        uint32 min\n    ) internal pure returns (uint32) {\n        return min + uint16(uint256(keccak256(abi.encodePacked(gemId, assetId, blockHash, slotIndex))) % (26 - min));\n    }\n}\n"
    },
    "src/solc_0.8/test/MockERC667Reciever.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\nimport \"../common/interfaces/IERC677Receiver.sol\";\n\ncontract MockERC677Receiver is IERC677Receiver {\n    event OnTokenTransferEvent(address indexed _sender, uint256 _value, bytes _data);\n\n    /// @dev Emits the OnTokenTransferEvent.\n    /// @param _sender The address of the sender.\n    /// @param _value The value sent with the tx.\n    /// @param _data The data sent with the tx.\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _data\n    ) external override {\n        emit OnTokenTransferEvent(_sender, _value, _data);\n    }\n}\n"
    },
    "src/solc_0.8/faucet/Faucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.8/utils/Strings.sol\";\n\ncontract Faucet is Ownable {\n    IERC20 internal immutable _ierc20;\n    uint256 internal _period;\n    uint256 internal _amountLimit;\n\n    mapping(address => uint256) public _lastTimestamps;\n\n    constructor(\n        IERC20 ierc20,\n        uint256 period,\n        uint256 amountLimit\n    ) {\n        _ierc20 = ierc20;\n        _period = period;\n        _amountLimit = amountLimit;\n    }\n\n    event FaucetPeriod(uint256 period);\n    event FaucetLimit(uint256 amountLimit);\n    event FaucetSent(address _receiver, uint256 _amountSent);\n    event FaucetRetrieved(address receiver, uint256 _amountSent);\n\n    /// @notice set the minimum time delta between 2 calls to send() for an address.\n    /// @param period time delta between 2 calls to send() for an address.\n    function setPeriod(uint256 period) public onlyOwner {\n        _period = period;\n        emit FaucetPeriod(period);\n    }\n\n    /// @notice returns the minimum time delta between 2 calls to Send for an address.\n    function getPeriod() public view returns (uint256) {\n        return _period;\n    }\n\n    /// @notice return the maximum IERC20 token amount for an address.\n    function setLimit(uint256 amountLimit) public onlyOwner {\n        _amountLimit = amountLimit;\n        emit FaucetLimit(amountLimit);\n    }\n\n    /// @notice return the maximum IERC20 token amount for an address.\n    function getLimit() public view returns (uint256) {\n        return _amountLimit;\n    }\n\n    /// @notice return the current IERC20 token balance for the contract.\n    function balance() public view returns (uint256) {\n        return _ierc20.balanceOf(address(this));\n    }\n\n    /// @notice retrieve all IERC20 token from contract to an address.\n    /// @param receiver The address that will receive all IERC20 tokens.\n    function retrieve(address receiver) public onlyOwner {\n        uint256 accountBalance = balance();\n        _ierc20.transferFrom(address(this), receiver, accountBalance);\n\n        emit FaucetRetrieved(receiver, accountBalance);\n    }\n\n    /// @notice send amount of IERC20 to a receiver.\n    /// @param amount The value of the IERC20 token that the receiver will received.\n    function send(uint256 amount) public {\n        require(\n            amount <= _amountLimit,\n            string(abi.encodePacked(\"Demand must not exceed \", Strings.toString(_amountLimit)))\n        );\n\n        uint256 accountBalance = balance();\n\n        require(\n            accountBalance > 0,\n            string(abi.encodePacked(\"Insufficient balance on Faucet account: \", Strings.toString(accountBalance)))\n        );\n        require(\n            _lastTimestamps[msg.sender] + _period < block.timestamp,\n            string(abi.encodePacked(\"After each call you must wait \", Strings.toString(_period), \" seconds.\"))\n        );\n        _lastTimestamps[msg.sender] = block.timestamp;\n\n        if (accountBalance < amount) {\n            amount = accountBalance;\n        }\n        _ierc20.transferFrom(address(this), msg.sender, amount);\n\n        emit FaucetSent(msg.sender, amount);\n    }\n}\n"
    },
    "src/solc_0.8/defi/rewardCalculation/PeriodicRewardCalculator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport {Math} from \"@openzeppelin/contracts-0.8/utils/math/Math.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts-0.8/access/AccessControl.sol\";\nimport {IRewardCalculator} from \"../interfaces/IRewardCalculator.sol\";\n\n/*\n    This contract calculate rewards linearly from the call to notifyRewardAmount until periodFinish\n    if restartRewards is called in the middle with a nonzero contribution rewards are\n    restarted (the main contract distribute the rewards at that point in time before calling)\n    at the end of the period all the accumulated rewards (including those when restartRewards was called) are given.\n*/\ncontract PeriodicRewardCalculator is IRewardCalculator, AccessControl {\n    event RewardAdded(uint256 reward);\n\n    // This role is in charge of configuring reward distribution\n    bytes32 public constant REWARD_DISTRIBUTION = keccak256(\"REWARD_DISTRIBUTION\");\n    // Each time a parameter that affects the reward distribution is changed the rewards are distributed by the reward\n    // pool contract this is the restart time.\n    uint256 public lastUpdateTime;\n    // This is the end of the period in which rewards are distributed\n    uint256 public periodFinish;\n    // Rewards are distributed at a fixed rate => reward = rewardRate * time\n    uint256 public rewardRate;\n    // The duration of the distribution period\n    uint256 public duration;\n    // This variable is only used when a new campaign starts (notifyRewardAmount is called)\n    // We need to save the rewards accumulated between the last call to restartRewards and the call to notifyRewardAmount\n    uint256 public savedRewards;\n    // The address of the reward pool, the only one authorized to restart rewards\n    address public immutable rewardPool;\n\n    constructor(address rewardPool_, uint256 duration_) {\n        rewardPool = rewardPool_;\n        duration = duration_;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function setDuration(uint256 newDuration) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"PeriodicRewardCalculator: not admin\");\n        require(block.timestamp >= periodFinish, \"PeriodicRewardCalculator: campaign already started\");\n\n        duration = newDuration;\n    }\n\n    // At any point in time this function must return the accumulated rewards from last call to restartRewards\n    function getRewards() external view override returns (uint256) {\n        return savedRewards + _getRewards();\n    }\n\n    // The main contract has distributed the rewards until this point, this must start from scratch => getRewards() == 0\n    function restartRewards() external override {\n        require(msg.sender == rewardPool, \"PeriodicRewardCalculator: not reward pool\");\n        // ensure reward past the first stacker do not get lost\n        lastUpdateTime = _lastTimeRewardApplicable();\n        savedRewards = 0;\n    }\n\n    // Useful when switching reward calculators to set an initial reward.\n    function setSavedRewards(uint256 reward) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"PeriodicRewardCalculator: not reward distribution\");\n        savedRewards = reward;\n        lastUpdateTime = block.timestamp;\n    }\n\n    function lastTimeRewardApplicable() external view returns (uint256) {\n        return _lastTimeRewardApplicable();\n    }\n\n    ///@notice to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract\n    // Note that the reward should be divisible by the duration to avoid reward token lost\n    // When calling this function with remaining>0 then reward + leftover must be divisible by duration (which can be problematic)\n    ///@param reward number of token to be distributed over the duration\n    function notifyRewardAmount(uint256 reward) external {\n        require(hasRole(REWARD_DISTRIBUTION, _msgSender()), \"PeriodicRewardCalculator: not reward distribution\");\n        savedRewards = _getRewards();\n        lastUpdateTime = block.timestamp;\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / duration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / duration;\n        }\n        periodFinish = block.timestamp + duration;\n        emit RewardAdded(reward);\n    }\n\n    function _getRewards() internal view returns (uint256) {\n        return (_lastTimeRewardApplicable() - lastUpdateTime) * rewardRate;\n    }\n\n    function _lastTimeRewardApplicable() internal view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n}\n"
    },
    "src/solc_0.8/test/ERC721Mintable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport {ERC721} from \"@openzeppelin/contracts-0.8/token/ERC721/ERC721.sol\";\n\n/// @dev This is NOT a secure ERC721\n/// DO NOT USE in production.\ncontract ERC721Mintable is ERC721 {\n    mapping(address => uint256) public fakeBalance;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n    function mint(address to, uint256 tokenId) external {\n        _mint(to, tokenId);\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (fakeBalance[owner] != 0) {\n            return fakeBalance[owner];\n        }\n        return ERC721.balanceOf(owner);\n    }\n\n    function setFakeBalance(address owner, uint256 balance) external {\n        fakeBalance[owner] = balance;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}