{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/ProxyImplementation.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ProxyImplementation {\n    mapping(string => bool) _initialised;\n\n    modifier phase(string memory phaseName) {\n        if (!_initialised[phaseName]) {\n            _initialised[phaseName] = true;\n            _;\n        }\n    }\n}\n","keccak256":"0x9bfcb76a8aa264d0b33fb8b24c9401198a8e42ec8230ad6cc60ee628e3734fa4"},"contracts_common/src/Interfaces/ERC1271.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1271 {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param data Arbitrary length data signed on the behalf of address(this)\n    * @param signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(bytes memory data, bytes memory signature)\n        public\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0xc96d98567763b067bb0264c9fed2a0df1e638b82e416c86e223e7e1cf2354514"},"contracts_common/src/Interfaces/ERC1271Constants.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1271Constants {\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n","keccak256":"0xe0fa0515924272c2536cc0e09428c456e0303d968cccbcb3395ea5237743c068"},"contracts_common/src/Interfaces/ERC1654.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1654 {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided hash\n    * @param hash 32 bytes hash to be signed\n    * @param signature Signature byte array associated with hash\n    * @return 0x1626ba7e if valid else 0x00000000\n    */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        public\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0xa5a9f130315c41a3578c374651fedc45de45cf66e442442e1c6e3b5fab896db6"},"contracts_common/src/Interfaces/ERC1654Constants.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1654Constants {\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\n}\n","keccak256":"0xc89fe81450f551045b148248ec1bb82156b20918e7dcb88b96e41ddcb62108a5"},"contracts_common/src/Libraries/BytesUtil.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary BytesUtil {\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, a)\n            )\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(\n        bytes memory data,\n        address _address\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n","keccak256":"0xb5c236938e1f71524127371a015836e83103c5ac1b4ed7b7f22892a8c0429e10"},"contracts_common/src/Libraries/SigUtil.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address recovered)\n    {\n        require(sig.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n","keccak256":"0xda7729e5b24c3780242ed1923b2a709ab284c18ee533669d6d0fa394ffb0491b"},"src/Sand/erc20/NativeMetaTransactionProcessor.sol":{"content":"pragma solidity 0.5.9;\n\nimport \"../../../contracts_common/src/Libraries/BytesUtil.sol\";\nimport \"../../../contracts_common/src/Libraries/SigUtil.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC1271.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC1271Constants.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC1654.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC1654Constants.sol\";\nimport \"../../TheSandbox712.sol\";\n\ninterface ExecutionableERC20 {\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 amount) external returns(bool);\n\n    function approveAndExecuteWithSpecificGas(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function approveAndExecuteWithSpecificGasAndChargeForIt(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 gasLimit,\n        uint256 tokenGasPrice,\n        uint256 baseGasCharge,\n        address tokenReceiver,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function transferAndChargeForGas(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 gasLimit,\n        uint256 tokenGasPrice,\n        uint256 baseGasCharge,\n        address tokenReceiver\n    ) external;\n}\n\ncontract NativeMetaTransactionProcessor is ERC1654Constants, ERC1271Constants, TheSandbox712 {\n    enum SignatureType { DIRECT, EIP1654, EIP1271 }\n\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\n        \"ERC20MetaTransaction(address from,address to,uint256 amount,bytes data,uint256 nonce,uint256 minGasPrice,uint256 txGas,uint256 baseGas,uint256 tokenGasPrice,address relayer)\"\n    );\n    mapping(address => uint256) nonces;\n\n    event MetaTx(\n        address indexed from,\n        uint256 indexed nonce,\n        bool success\n    );\n\n    ExecutionableERC20 _tokenContract;\n\n    constructor(ExecutionableERC20 tokenContract) public {\n        _tokenContract = tokenContract;\n        init712();\n    }\n\n    /// @notice gets the current nonce (number of metatx emitted) of `from`.\n    /// @param owner The address to query the nonce of.\n    /// @return the current nonce\n    function meta_nonce(address owner) external view returns (uint256 nonce) {\n        return nonces[owner];\n    }\n\n    /// @notice perform the meta-tx using EIP-712 message.\n    /// @param from address from which the meta-tx originate.\n    /// @param to destination address where the call will be performed.\n    /// @param amount number of tokens to be transfered/allowed as part of the call.\n    /// @param data bytes to send to the destination.\n    /// @param params the meta-tx parameters : nonce, minGasPrice, txGas, baseGas, tokenGasPrice.\n    /// @param relayer the address allowed to perform the meta-tx.\n    /// @param signature the signature that ensure from has allowed the meta-tx to be performed.\n    /// @param tokenReceiver recipient of the gas charge.\n    /// @param signatureType indicate whether it was signed via EOA=0, EIP-1654=1 or EIP-1271=2.\n    /// @return success whether the execution was successful.\n    /// @return returnData data resulting from the execution.\n    function executeERC20MetaTx(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256[5] calldata params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\n        address relayer,\n        bytes calldata signature,\n        address tokenReceiver,\n        SignatureType signatureType\n    ) external returns (bool success, bytes memory returnData) {\n        ensureParametersValidity(from, params, relayer);\n        ensureCorrectSigner(\n            from,\n            to,\n            amount,\n            data,\n            params,\n            relayer,\n            signature,\n            ERC20METATRANSACTION_TYPEHASH,\n            signatureType\n        );\n        return\n            performERC20MetaTx(\n                from,\n                to,\n                amount,\n                data,\n                params,\n                tokenReceiver\n            );\n    }\n\n    /// @notice perform the meta-tx using personal_sign message.\n    /// @param from address from which the meta-tx originate.\n    /// @param to destination address where the call will be performed.\n    /// @param amount number of tokens to be transfered/allowed as part of the call.\n    /// @param data bytes to send to the destination.\n    /// @param params the meta-tx parameters : nonce, minGasPrice, txGas, baseGas, tokenGasPrice.\n    /// @param relayer the address allowed to perform the meta-tx.\n    /// @param signature the signature that ensure from has allowed the meta-tx to be performed.\n    /// @param tokenReceiver recipient of the gas charge.\n    /// @param signatureType indicate whether it was signed via EOA=0, EIP-1654=1 or EIP-1271=2.\n    /// @return success whether the execution was successful.\n    /// @return returnData data resulting from the execution.\n    function executeERC20MetaTxViaBasicSignature(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256[5] calldata params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\n        address relayer,\n        bytes calldata signature,\n        address tokenReceiver,\n        SignatureType signatureType\n    ) external returns (bool, bytes memory) {\n        ensureParametersValidity(from, params, relayer);\n        ensureCorrectSignerViaBasicSignature(\n            from,\n            to,\n            amount,\n            data,\n            params,\n            relayer,\n            signature,\n            ERC20METATRANSACTION_TYPEHASH,\n            signatureType\n        );\n        return\n            performERC20MetaTx(\n                from,\n                to,\n                amount,\n                data,\n                params,\n                tokenReceiver\n            );\n    }\n\n    function ensureParametersValidity(\n        address from,\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\n        address relayer\n    ) internal view {\n        require(\n            relayer == address(0) || relayer == msg.sender,\n            \"wrong relayer\"\n        );\n        require(nonces[from] + 1 == params[0], \"nonce out of order\");\n        require(tx.gasprice >= params[1], \"gasPrice < signer minGasPrice\");\n    }\n\n    function ensureCorrectSigner(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\n        address relayer,\n        bytes memory signature,\n        bytes32 typeHash,\n        SignatureType signatureType\n    ) internal view {\n        bytes memory dataToHash = abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator(),\n            keccak256(\n                abi.encode(\n                    typeHash,\n                    from,\n                    to,\n                    amount,\n                    keccak256(data),\n                    params[0],\n                    params[1],\n                    params[2],\n                    params[3],\n                    params[4],\n                    relayer\n                )\n            )\n        );\n        if (signatureType == SignatureType.EIP1271) {\n            require(\n                ERC1271(from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\n                \"invalid 1271 signature\"\n            );\n        } else if(signatureType == SignatureType.EIP1654){\n            require(\n                ERC1654(from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\n                \"invalid 1654 signature\"\n            );\n        } else {\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\n            require(signer == from, \"signer != from\");\n        }\n    }\n\n    function encodeBasicSignatureData(\n        bytes32 typeHash,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        uint256[5] memory params,\n        address relayer\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    typeHash,\n                    from,\n                    to,\n                    amount,\n                    keccak256(data),\n                    params[0],\n                    params[1],\n                    params[2],\n                    params[3],\n                    params[4],\n                    relayer\n                )\n            );\n    }\n\n    function ensureCorrectSignerViaBasicSignature(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\n        address relayer,\n        bytes memory signature,\n        bytes32 typeHash,\n        SignatureType signatureType\n    ) internal view {\n        bytes memory dataToHash = SigUtil.prefixed(\n            encodeBasicSignatureData(\n                typeHash,\n                from,\n                to,\n                amount,\n                data,\n                params,\n                relayer\n            )\n        );\n        if (signatureType == SignatureType.EIP1271) {\n            require(\n                ERC1271(from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\n                \"invalid 1271 signature\"\n            );\n        } else if (signatureType == SignatureType.EIP1654) {\n            require(\n                ERC1654(from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\n                \"invalid 1654 signature\"\n            );\n        } else {\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\n            require(signer == from, \"signer != from\");\n        }\n    }\n\n    function performERC20MetaTx(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        uint256[5] memory params,\n        address tokenReceiver\n    ) internal returns (bool success, bytes memory returnData) {\n        nonces[from] = params[0];\n\n        if (data.length == 0) {\n            if(params[4] > 0) {\n                _tokenContract.transferAndChargeForGas(\n                    from,\n                    to,\n                    amount,\n                    params[2],\n                    params[4],\n                    params[3],\n                    tokenReceiver\n                );\n            } else {\n                require(_tokenContract.transferFrom(from, to, amount), \"failed transfer\");\n            }\n            success = true;\n        } else {\n            require(\n                BytesUtil.doFirstParamEqualsAddress(data, from),\n                \"first param != from\"\n            );\n            if(params[4] > 0) {\n                (success, returnData) = _tokenContract.approveAndExecuteWithSpecificGasAndChargeForIt(\n                    from,\n                    to,\n                    amount,\n                    params[2],\n                    params[4],\n                    params[3],\n                    tokenReceiver,\n                    data\n                );\n            } else {\n                (success, returnData) = _tokenContract.approveAndExecuteWithSpecificGas(from, to, amount, params[2], data);\n            }\n        }\n\n        emit MetaTx(from, params[0], success);\n    }\n}\n","keccak256":"0x8522a1057a6efcf65284626b20125ce343edb11a7783a8e07fb252bfe9b74f30"},"src/TheSandbox712.sol":{"content":"pragma solidity 0.5.9;\n\nimport {\n    ProxyImplementation\n} from \"../contracts_common/src/BaseWithStorage/ProxyImplementation.sol\";\n\ncontract TheSandbox712 is ProxyImplementation {\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,address verifyingContract)\"\n    );\n    bytes32 DOMAIN_SEPARATOR;\n\n    function init712() public phase(\"712\") {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(\"The Sandbox 3D\"),\n                keccak256(\"1\"),\n                address(this)\n            )\n        );\n    }\n\n    function domainSeparator() internal view returns (bytes32) {\n        return DOMAIN_SEPARATOR;\n    }\n}\n","keccak256":"0x76f0233c0b532620a8d3a129d30b6551869be42514cbe2b03004400ea230de54"}}}