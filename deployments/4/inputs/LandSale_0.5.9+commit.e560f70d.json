{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/Admin.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract Admin {\n\n    address internal _admin;\n\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @notice gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require (msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n\n}\n","keccak256":"0xf3763fa108235379b48cf8fe9a708692fcb077250d9974351fd636ff0baf84bf"},"contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract MetaTransactionReceiver is Admin{\n\n    mapping(address => bool) internal _metaTransactionContracts;\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @notice Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(\n            msg.sender == _admin,\n            \"only admin can setup metaTransactionProcessors\"\n        );\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @notice check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns(bool) {\n        return _metaTransactionContracts[who];\n    }\n}","keccak256":"0xbd938dbadc0ed2142b6dc20b0613dc3236a9a6ec370639476b672c2536e9a186"},"contracts_common/src/BaseWithStorage/SuperOperators.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract SuperOperators is Admin {\n\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add super operators\"\n        );\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n","keccak256":"0x22354cf60ccf77a6de61c13bdaf4e3094d115b960ae563b0527622c846a12abb"},"contracts_common/src/Interfaces/ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20Basic.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\n/* interface */\ncontract ERC20 is ERC20Basic {\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n","keccak256":"0xa8cb63790e43bb77235530d0add180a84e9eb20c95173059e7d783c599c199b0"},"contracts_common/src/Interfaces/ERC20Basic.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC20Basic DRAFT\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\n/* interface */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n","keccak256":"0x7d333b4cd97e3fa0a67f3f20d79e6a46d5c81a8f7d506aa24c624ec6e4e913b9"},"contracts_common/src/Interfaces/ERC721Events.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface ERC721Events {\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n}\n","keccak256":"0xdf0051d52413d5e853a9801d5745337e4040949b31568cc17ca50f8853e10567"},"contracts_common/src/Interfaces/ERC721MandatoryTokenReceiver.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x5e8bf644.\n*/\ninterface ERC721MandatoryTokenReceiver {\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n\n    // needs to implements EIP-165\n    // function supportsInterface(bytes4 interfaceId)\n    //     external\n    //     view\n    //     returns (bool);\n}\n","keccak256":"0xe68dbcb5d43dd61dd8606271fe75e149bb401e9fdfb9e89e2a5b3962638fea91"},"contracts_common/src/Interfaces/ERC721TokenReceiver.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity ^0.5.2;\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n","keccak256":"0x94e7441c07cb2f97b9b5be8ca5a5f76623615963852aa5e20208b8cbcb33c1ce"},"contracts_common/src/Libraries/AddressUtils.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary AddressUtils {\n\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n","keccak256":"0x2ad037f43ea9a899526bd911737727d027ce8a2bc1cf615bdf5a1706d400afd6"},"src/Land.sol":{"content":"/* solhint-disable no-empty-blocks */\n\npragma solidity 0.5.9;\n\nimport \"./Land/erc721/LandBaseToken.sol\";\n\ncontract Land is LandBaseToken {\n    constructor(\n        address metaTransactionContract,\n        address admin\n    ) public LandBaseToken(\n        metaTransactionContract,\n        admin\n    ) {\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() external pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() external pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\n                    \"https://api.sandbox.game/land/\",\n                    uint2str(id),\n                    \"/metadata.json\"\n                )\n            );\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n}\n","keccak256":"0x0b8243167c5fe78ba03c248bc164e895f83f43a40e11f701cf6652004a9a5441"},"src/Land/erc721/ERC721BaseToken.sol":{"content":"/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../../contracts_common/src/Libraries/AddressUtils.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC721Events.sol\";\nimport \"../../../contracts_common/src/BaseWithStorage/SuperOperators.sol\";\nimport \"../../../contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\ncontract ERC721BaseToken is ERC721Events, SuperOperators, MetaTransactionReceiver {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    constructor(\n        address metaTransactionContract,\n        address admin\n    ) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(address owner, address operator, uint256 id) internal {\n        if(operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[owner][msg.sender],\n            \"not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender),\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(\n            ERC165ID,\n            interfaceId\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                10000,\n                _contract,\n                call_ptr,\n                call_size,\n                output,\n                0x20\n            ) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\n                \"ERC721: transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from ||\n            metaTx ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[from][msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, address owner, uint256 id) public {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            (operatorEnabled && _operators[id] == from) ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n}\n","keccak256":"0x4ed2366d9e73a981b8c2148e828080d6905f09ebab8dedcd6b7a5d9641b68ca0"},"src/Land/erc721/LandBaseToken.sol":{"content":"/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"./ERC721BaseToken.sol\";\n\ncontract LandBaseToken is ERC721BaseToken {\n    // Our grid is 408 x 408 lands\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER =          0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 =      0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 =      0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 =      0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 =    0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 =    0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n    event Minter(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add minters\"\n        );\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin\n    ) public ERC721BaseToken(metaTransactionContract, admin) {\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() external returns(uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() external returns(uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function x(uint256 id) external returns(uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id % GRID_SIZE;\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function y(uint256 id) external returns(uint256) {\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return id / GRID_SIZE;\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The x coordinate of the new quad\n     * @param y The y coordinate of the new quad\n     */\n    function mintQuad(address to, uint16 size, uint16 x, uint16 y) external {\n        require(to != address(0), \"to is zero address\");\n        require(\n            isMinter(msg.sender),\n            \"Only a minter can mint\"\n        );\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        uint256 quadId;\n        uint256 id = x + y * GRID_SIZE;\n\n        if (size == 1) {\n            quadId = id;\n        } else if (size == 3) {\n            quadId = LAYER_3x3 + id;\n        } else if (size == 6) {\n            quadId = LAYER_6x6 + id;\n        } else if (size == 12) {\n            quadId = LAYER_12x12 + id;\n        } else if (size == 24) {\n            quadId = LAYER_24x24 + id;\n        } else {\n            require(false, \"Invalid size\");\n        }\n\n        require(_owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE] == 0, \"Already minted as 24x24\");\n\n        uint256 toX = x+size;\n        uint256 toY = y+size;\n        if (size <= 12) {\n            require(\n                _owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE] == 0,\n                \"Already minted as 12x12\"\n            );\n        } else {\n            for (uint16 x12i = x; x12i < toX; x12i += 12) {\n                for (uint16 y12i = y; y12i < toY; y12i += 12) {\n                    uint256 id12x12 = LAYER_12x12 + x12i + y12i * GRID_SIZE;\n                    require(_owners[id12x12] == 0, \"Already minted as 12x12\");\n                }\n            }\n        }\n\n        if (size <= 6) {\n            require(_owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE] == 0, \"Already minted as 6x6\");\n        } else {\n            for (uint16 x6i = x; x6i < toX; x6i += 6) {\n                for (uint16 y6i = y; y6i < toY; y6i += 6) {\n                    uint256 id6x6 = LAYER_6x6 + x6i + y6i * GRID_SIZE;\n                    require(_owners[id6x6] == 0, \"Already minted as 6x6\");\n                }\n            }\n        }\n\n        if (size <= 3) {\n            require(_owners[LAYER_3x3 + (x/3) * 3 + ((y/3) * 3) * GRID_SIZE] == 0, \"Already minted as 3x3\");\n        } else {\n            for (uint16 x3i = x; x3i < toX; x3i += 3) {\n                for (uint16 y3i = y; y3i < toY; y3i += 3) {\n                    uint256 id3x3 = LAYER_3x3 + x3i + y3i * GRID_SIZE;\n                    require(_owners[id3x3] == 0, \"Already minted as 3x3\");\n                }\n            }\n        }\n\n        for (uint16 xi = x; xi < toX; xi++) {\n            for (uint16 yi = y; yi < toY; yi++) {\n                uint256 id1x1 = xi + yi * GRID_SIZE;\n                require(_owners[id1x1] == 0, \"Already minted\");\n                emit Transfer(address(0), to, id1x1);\n            }\n        }\n\n        _owners[quadId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x x top coordinates of the quad\n    /// @param y y top coordinates of the quad\n    /// @param data additional data\n    function transferQuad(address from, address to, uint16 size, uint16 x, uint16 y, bytes calldata data) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size*size);\n            for (uint256 i = 0; i < size*size; i++) {\n                if((i/size) % 2 == 0) { // alow ids to follow a path\n                    ids[i] = (x + (i%size)) + ((y + (i/size)) * GRID_SIZE);\n                } else {\n                    ids[i] = ((x + size) - (1 + i%size)) + ((y + (i/size)) * GRID_SIZE);\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of x top coordinates for each quad\n    /// @param ys list of y top coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint16[] calldata sizes,\n        uint16[] calldata xs,\n        uint16[] calldata ys,\n        bytes calldata data\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !metaTx) {\n            require(\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint16 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint16 size = sizes[j];\n                uint16 x = xs[j];\n                uint16 y = ys[j];\n                for (uint256 i = 0; i < size*size; i++) {\n                    if((i/size) % 2 == 0) { // alow ids to follow a path\n                        ids[counter] = (x + (i%size)) + ((y + (i/size)) * GRID_SIZE);\n                    } else {\n                        ids[counter] = ((x + size) - (1 + i%size)) + ((y + (i/size)) * GRID_SIZE);\n                    }\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    function _transferQuad(address from, address to, uint16 size, uint16 x, uint16 y) internal {\n        if (size == 1) {\n            uint256 id1x1 = x + y * GRID_SIZE;\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(to);\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size*size; i++) {\n            if((i/size) % 2 == 0) { // alow ids to follow a path\n                emit Transfer(from, to, (x + (i%size)) + ((y + (i/size)) * GRID_SIZE));\n            } else {\n                emit Transfer(from, to, ((x + size) - (1 + i%size)) + ((y + (i/size)) * GRID_SIZE));\n            }\n        }\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns(bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require(address(owner) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _regroup(address from, address to, uint16 size, uint16 x, uint16 y) internal {\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        if (size == 3) {\n            _regroup3x3(from, to, x, y, true);\n        } else if (size == 6) {\n            _regroup6x6(from, to, x, y, true);\n        } else if (size == 12) {\n            _regroup12x12(from, to, x, y, true);\n        } else if (size == 24) {\n            _regroup24x24(from, to, x, y, true);\n        } else {\n            require(false, \"Invalid size\");\n        }\n    }\n\n    function _regroup3x3(address from, address to, uint16 x, uint16 y, bool set) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_3x3 + id;\n        bool ownerOfAll = true;\n        for (uint16 xi = x; xi < x+3; xi++) {\n            for (uint16 yi = y; yi < y+3; yi++) {\n                ownerOfAll = _checkAndClear(from, xi + yi * GRID_SIZE) && ownerOfAll;\n            }\n        }\n        if(set) {\n            if(!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(from) ||\n                    _owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE] == uint256(from) ||\n                    _owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE] == uint256(from) ||\n                    _owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE] == uint256(from),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(to);\n            return true;\n        }\n        return ownerOfAll;\n    }\n    function _regroup6x6(address from, address to,  uint16 x, uint16 y, bool set) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_6x6 + id;\n        bool ownerOfAll = true;\n        for (uint16 xi = x; xi < x+6; xi += 3) {\n            for (uint16 yi = y; yi < y+6; yi += 3) {\n                bool ownAllIndividual = _regroup3x3(from, to, xi, yi, false);\n                uint256 id3x3 = LAYER_3x3 + xi + yi * GRID_SIZE;\n                uint256 owner3x3 = _owners[id3x3];\n                if (owner3x3 != 0) {\n                    if(!ownAllIndividual) {\n                        require(owner3x3 == uint256(from), \"not owner of 3x3 quad\");\n                    }\n                    _owners[id3x3] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner3x3 != 0) && ownerOfAll;\n            }\n        }\n        if(set) {\n            if(!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(from) ||\n                    _owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE] == uint256(from) ||\n                    _owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE] == uint256(from),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(to);\n            return true;\n        }\n        return ownerOfAll;\n    }\n    function _regroup12x12(address from, address to,  uint16 x, uint16 y, bool set) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_12x12 + id;\n        bool ownerOfAll = true;\n        for (uint16 xi = x; xi < x+12; xi += 6) {\n            for (uint16 yi = y; yi < y+12; yi += 6) {\n                bool ownAllIndividual = _regroup6x6(from, to, xi, yi, false);\n                uint256 id6x6 = LAYER_6x6 + xi + yi * GRID_SIZE;\n                uint256 owner6x6 = _owners[id6x6];\n                if (owner6x6 != 0) {\n                    if(!ownAllIndividual) {\n                        require(owner6x6 == uint256(from), \"not owner of 6x6 quad\");\n                    }\n                    _owners[id6x6] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner6x6 != 0) && ownerOfAll;\n            }\n        }\n        if(set) {\n            if(!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(from) ||\n                    _owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE] == uint256(from),\n                    \"not owner of all sub quads nor parent quads\"\n                );\n            }\n            _owners[quadId] = uint256(to);\n            return true;\n        }\n        return ownerOfAll;\n    }\n    function _regroup24x24(address from, address to,  uint16 x, uint16 y, bool set) internal returns (bool) {\n        uint256 id = x + y * GRID_SIZE;\n        uint256 quadId = LAYER_24x24 + id;\n        bool ownerOfAll = true;\n        for (uint16 xi = x; xi < x+24; xi += 12) {\n            for (uint16 yi = y; yi < y+24; yi += 12) {\n                bool ownAllIndividual = _regroup12x12(from, to, xi, yi, false);\n                uint256 id12x12 = LAYER_12x12 + xi + yi * GRID_SIZE;\n                uint256 owner12x12 = _owners[id12x12];\n                if (owner12x12 != 0) {\n                    if(!ownAllIndividual) {\n                        require(owner12x12 == uint256(from), \"not owner of 12x12 quad\");\n                    }\n                    _owners[id12x12] = 0;\n                }\n                ownerOfAll = (ownAllIndividual || owner12x12 != 0) && ownerOfAll;\n            }\n        }\n        if(set) {\n            if(!ownerOfAll) {\n                require(\n                    _owners[quadId] == uint256(from),\n                    \"not owner of all sub quads not parent quad\"\n                );\n            }\n            _owners[quadId] = uint256(to);\n            return true;\n        }\n        return ownerOfAll || _owners[quadId] == uint256(from);\n    }\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            return address(owner1x1); // cast to zero\n        } else {\n            address owner3x3 = address(_owners[LAYER_3x3 + (x/3) * 3 + ((y/3) * 3) * GRID_SIZE]);\n            if (owner3x3 != address(0)) {\n                return owner3x3;\n            } else {\n                address owner6x6 = address(_owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE]);\n                if (owner6x6 != address(0)) {\n                    return owner6x6;\n                } else {\n                    address owner12x12 = address(_owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE]);\n                    if (owner12x12 != address(0)) {\n                        return owner12x12;\n                    } else {\n                        return address(_owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            owner = address(owner1x1);\n            operatorEnabled = (owner1x1 / 2**255) == 1;\n        } else {\n            address owner3x3 = address(_owners[LAYER_3x3 + (x/3) * 3 + ((y/3) * 3) * GRID_SIZE]);\n            if (owner3x3 != address(0)) {\n                owner = owner3x3;\n                operatorEnabled = false;\n            } else {\n                address owner6x6 = address(_owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE]);\n                if (owner6x6 != address(0)) {\n                    owner = owner6x6;\n                    operatorEnabled = false;\n                } else {\n                    address owner12x12 = address(_owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE]);\n                    if (owner12x12 != address(0)) {\n                        owner = owner12x12;\n                        operatorEnabled = false;\n                    } else {\n                        owner = address(_owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE]);\n                        operatorEnabled = false;\n                    }\n                }\n            }\n        }\n    }\n\n}\n","keccak256":"0x69565e3c24a5b7e8bc5f65156f88005bd26d4a0f4189a84e67c782f78b83c07e"},"src/LandSale/LandSale.sol":{"content":"pragma solidity 0.5.9;\n\nimport \"../Land.sol\";\nimport \"../../contracts_common/src/Interfaces/ERC20.sol\";\nimport \"../../contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\n/**\n * @title Land Sale contract\n * @notice This contract mananges the sale of our lands\n */\ncontract LandSale is MetaTransactionReceiver {\n\n    uint256 internal constant GRID_SIZE = 408; // 408 is the size of the Land\n\n    Land internal _land;\n    ERC20 internal _erc20;\n    address payable internal _wallet;\n    uint256 internal _expiryTime;\n    bytes32 internal _merkleRoot;\n\n    event LandQuadPurchased(\n        address indexed buyer,\n        address indexed to,\n        uint256 indexed topCornerId,\n        uint16 size,\n        uint256 price\n    );\n\n    constructor(\n        address landAddress,\n        address erc20ContractAddress,\n        address initialMetaTx,\n        address admin,\n        address payable initialWalletAddress,\n        bytes32 merkleRoot,\n        uint256 expiryTime\n    ) public {\n        _land = Land(landAddress);\n        _erc20 = ERC20(erc20ContractAddress);\n        _setMetaTransactionProcessor(initialMetaTx, true);\n        _admin = admin;\n        _wallet = initialWalletAddress;\n        _merkleRoot = merkleRoot;\n        _expiryTime = expiryTime;\n    }\n\n    /// @notice set the wallet receiving the proceeds\n    /// @param newWallet address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external{\n        require(newWallet != address(0), \"receiving wallet cannot be zero address\");\n        require(msg.sender == _admin, \"only admin can change the receiving wallet\");\n        _wallet = newWallet;\n    }\n\n    /**\n     * @notice buy Land using the merkle proof associated with it\n     * @param buyer address that perform the payment\n     * @param to address that will own the purchased Land\n     * @param reserved the reserved address (if any)\n     * @param x x coordinate of the Land\n     * @param y y coordinate of the Land\n     * @param size size of the pack of Land to purchase\n     * @param price amount of Sand to purchase that Land\n     * @param proof merkleProof for that particular Land\n     * @return The address of the operator\n     */\n    function buyLand(\n        address buyer,\n        address to,\n        address reserved,\n        uint16 x,\n        uint16 y,\n        uint16 size,\n        uint256 price,\n        bytes32 salt,\n        bytes32[] calldata proof\n    ) external {\n        /* solhint-disable-next-line not-rely-on-time */\n        require(block.timestamp < _expiryTime, \"sale is over\");\n        require(buyer == msg.sender || _metaTransactionContracts[msg.sender], \"not authorized\");\n        require(reserved == address(0) || reserved == buyer, \"cannot buy reserved Land\");\n        bytes32 leaf = _generateLandHash(x, y, size, price, reserved, salt);\n\n        require(\n            _verify(proof, leaf),\n            \"Invalid land provided\"\n        );\n\n        require(\n            _erc20.transferFrom(\n                buyer,\n                _wallet,\n                price\n            ),\n            \"erc20 transfer failed\"\n        );\n\n        _land.mintQuad(to, size, x, y);\n        emit LandQuadPurchased(buyer, to, x + (y * GRID_SIZE), size, price);\n    }\n\n    /**\n     * @notice Gets the expiry time for the current sale\n     * @return The expiry time, as a unix epoch\n     */\n    function getExpiryTime() external view returns(uint256) {\n        return _expiryTime;\n    }\n\n    /**\n     * @notice Gets the Merkle root associated with the current sale\n     * @return The Merkle root, as a bytes32 hash\n     */\n    function merkleRoot() external view returns(bytes32) {\n        return _merkleRoot;\n    }\n\n    function _generateLandHash(\n        uint16 x,\n        uint16 y,\n        uint16 size,\n        uint256 price,\n        address reserved,\n        bytes32 salt\n    ) internal pure returns (\n        bytes32\n    ) {\n        return keccak256(\n            abi.encodePacked(\n                x,\n                y,\n                size,\n                price,\n                reserved,\n                salt\n            )\n        );\n    }\n\n    function _verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        return computedHash == _merkleRoot;\n    }\n}\n","keccak256":"0x21b7f46fbb065989cd22887f1472eeea5cdfb58e6b6d2892284b331017e44618"}}}