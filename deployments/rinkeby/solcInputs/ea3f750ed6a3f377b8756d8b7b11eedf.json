{
  "language": "Solidity",
  "sources": {
    "src/solc_0.6/Base/TheSandbox712.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ncontract TheSandbox712 {\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\");\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor() public {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH, keccak256(\"The Sandbox\"), keccak256(\"1\"), address(this)));\n    }\n}\n"
    },
    "src/solc_0.6/P2PERC721Sale/P2PERC721Sale.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/BaseWithStorage/Admin.sol\";\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/Libraries/PriceUtil.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../common/Interfaces/ERC721.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/Interfaces/ERC1271.sol\";\nimport \"../common/Interfaces/ERC1271Constants.sol\";\nimport \"../common/Interfaces/ERC1654.sol\";\nimport \"../common/Interfaces/ERC1654Constants.sol\";\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\n\nimport \"../Base/TheSandbox712.sol\";\n\n\ncontract P2PERC721Sale is Admin, ERC1654Constants, ERC1271Constants, TheSandbox712, MetaTransactionReceiver {\n    using SafeMathWithRequire for uint256;\n\n    enum SignatureType {DIRECT, EIP1654, EIP1271}\n\n    mapping(address => mapping(uint256 => uint256)) public claimed;\n\n    uint256 private constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    ERC20 internal _sand;\n    uint256 internal _fee;\n    address internal _feeCollector;\n\n    struct Auction {\n        uint256 id;\n        address tokenAddress; // TODO support bundle : tokenAddress and tokenId should be arrays\n        uint256 tokenId;\n        address seller;\n        uint256 startingPrice; // TODO support any ERC20 or ethereum as payment\n        uint256 endingPrice;\n        uint256 startedAt;\n        uint256 duration;\n    }\n\n    event OfferClaimed(\n        address indexed seller,\n        address indexed buyer,\n        uint256 indexed offerId,\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 pricePaid,\n        uint256 feePaid\n    );\n\n    event OfferCancelled(address indexed seller, uint256 indexed offerId);\n\n    event FeeSetup(address feeCollector, uint256 fee10000th);\n\n    constructor(\n        address sand,\n        address admin,\n        address feeCollector,\n        uint256 fee,\n        address initialMetaTx\n    ) public {\n        _sand = ERC20(sand);\n        _admin = admin;\n\n        _fee = fee;\n        _feeCollector = feeCollector;\n        emit FeeSetup(feeCollector, fee);\n\n        _setMetaTransactionProcessor(initialMetaTx, true);\n    }\n\n    function setFee(address feeCollector, uint256 fee) external {\n        require(msg.sender == _admin, \"Sender not admin\");\n        _feeCollector = feeCollector;\n        _fee = fee;\n        emit FeeSetup(feeCollector, fee);\n    }\n\n    function _verifyParameters(address buyer, Auction memory auction) internal view {\n        require(buyer == msg.sender || _metaTransactionContracts[msg.sender], \"not authorized\"); // if support any ERC20 :(token != address(0) &&\n\n        require(claimed[auction.seller][auction.id] != MAX_UINT256, \"Auction canceled\");\n\n        require(auction.startedAt <= now, \"Auction has not started yet\");\n\n        require(auction.startedAt.add(auction.duration) > now, \"Auction finished\");\n    }\n\n    function claimSellerOffer(\n        address buyer,\n        address to,\n        Auction calldata auction,\n        bytes calldata signature,\n        SignatureType signatureType,\n        bool eip712\n    ) external {\n        _verifyParameters(buyer, auction);\n        _ensureCorrectSigner(auction, signature, signatureType, eip712);\n        _executeDeal(auction, buyer, to);\n    }\n\n    function _executeDeal(\n        Auction memory auction,\n        address buyer,\n        address to\n    ) internal {\n        uint256 offer = PriceUtil.calculateCurrentPrice(\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            now.sub(auction.startedAt)\n        );\n\n        claimed[auction.seller][auction.id] = offer;\n\n        uint256 fee = 0;\n\n        if (_fee > 0) {\n            fee = PriceUtil.calculateFee(offer, _fee);\n        }\n\n        require(_sand.transferFrom(buyer, auction.seller, offer.sub(fee)), \"Funds transfer failed\"); // TODO feeCollector\n\n        ERC721 token = ERC721(auction.tokenAddress);\n\n        token.safeTransferFrom(auction.seller, to, auction.tokenId); // TODO test safeTransferFrom fail\n    }\n\n    function cancelSellerOffer(uint256 id) external {\n        claimed[msg.sender][id] = MAX_UINT256;\n        emit OfferCancelled(msg.sender, id);\n    }\n\n    function _ensureCorrectSigner(\n        Auction memory auction,\n        bytes memory signature,\n        SignatureType signatureType,\n        bool eip712\n    ) internal view returns (address) {\n        bytes memory dataToHash;\n\n        if (eip712) {\n            dataToHash = abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, _hashAuction(auction));\n        } else {\n            dataToHash = _encodeBasicSignatureHash(auction);\n        }\n\n        if (signatureType == SignatureType.EIP1271) {\n            require(\n                ERC1271(auction.seller).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\n                \"Invalid 1271 sig\"\n            );\n        } else if (signatureType == SignatureType.EIP1654) {\n            require(\n                ERC1654(auction.seller).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\n                \"Invalid 1654 sig\"\n            );\n        } else {\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\n            require(signer == auction.seller, \"Invalid sig\");\n        }\n    }\n\n    function _encodeBasicSignatureHash(Auction memory auction) internal view returns (bytes memory) {\n        return\n            SigUtil.prefixed(\n                keccak256(\n                    abi.encodePacked(\n                        address(this),\n                        auction.id,\n                        auction.tokenAddress,\n                        auction.tokenId,\n                        auction.seller,\n                        auction.startingPrice,\n                        auction.endingPrice,\n                        auction.startedAt,\n                        auction.duration\n                    )\n                )\n            );\n    }\n\n    function _hashAuction(Auction memory auction) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    auction.id,\n                    auction.tokenAddress,\n                    auction.tokenId,\n                    auction.seller,\n                    auction.startingPrice,\n                    auction.endingPrice,\n                    auction.startedAt,\n                    auction.duration\n                )\n            );\n    }\n}\n"
    },
    "src/solc_0.6/common/BaseWithStorage/Admin.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ncontract Admin {\n    address internal _admin;\n\n    /// @dev emitted when the contract administrator is changed.\n    /// @param oldAdmin address of the previous administrator.\n    /// @param newAdmin address of the new administrator.\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @dev gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/SigUtil.sol": {
      "content": "pragma solidity 0.6.5;\n\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {\n        require(sig.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig) internal pure returns (address) {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/PriceUtil.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary PriceUtil {\n    using SafeMathWithRequire for uint256;\n\n    function calculateCurrentPrice(\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 secondsPassed\n    ) internal pure returns (uint256) {\n        if (secondsPassed > duration) {\n            return endingPrice;\n        }\n        if (endingPrice == startingPrice) {\n            return endingPrice;\n        } else if (endingPrice > startingPrice) {\n            return startingPrice.add((endingPrice.sub(startingPrice)).mul(secondsPassed).div(duration));\n        } else {\n            return startingPrice.sub((startingPrice.sub(endingPrice)).mul(secondsPassed).div(duration));\n        }\n    }\n\n    function calculateFee(uint256 price, uint256 fee10000th) internal pure returns (uint256) {\n        // _fee < 10000, so the result will be <= price\n        return (price.mul(fee10000th)) / 10000;\n    }\n}\n"
    },
    "src/solc_0.6/common/BaseWithStorage/MetaTransactionReceiver.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./Admin.sol\";\n\n\ncontract MetaTransactionReceiver is Admin {\n    mapping(address => bool) internal _metaTransactionContracts;\n\n    /// @dev emiited when a meta transaction processor is enabled/disabled\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(msg.sender == _admin, \"only admin can setup metaTransactionProcessors\");\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @dev check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns (bool) {\n        return _metaTransactionContracts[who];\n    }\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC721.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./ERC165.sol\";\nimport \"./ERC721Events.sol\";\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\n\ninterface ERC721 is ERC165, ERC721Events {\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    //   function exists(uint256 tokenId) external view returns (bool exists);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC20.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\ninterface ERC20 {\n    /// @notice emitted when tokens are transfered from one address to another.\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\n    /// @param value amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice emitted when owner grant transfer rights to another address\n    /// @param owner address allowing its token to be transferred.\n    /// @param spender address allowed to spend on behalf of `owner`\n    /// @param value amount of tokens allowed.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice return the current total amount of tokens owned by all holders.\n    /// @return supply total number of tokens held.\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @notice return the number of tokens held by a particular address.\n    /// @param who address being queried.\n    /// @return balance number of token held by that address.\n    function balanceOf(address who) external view returns (uint256 balance);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    /// @notice approve an address to spend on your behalf.\n    /// @param spender address entitled to transfer on your behalf.\n    /// @param value amount allowed to be transfered.\n    /// @param success whether the approval succeeded.\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /// @notice return the current allowance for a particular owner/spender pair.\n    /// @param owner address allowing spender.\n    /// @param spender address allowed to spend.\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) external view returns (uint256 amount);\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC1271.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ninterface ERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param data Arbitrary length data signed on the behalf of address(this)\n     * @param signature Signature byte array associated with _data\n     * @return magicValue\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes calldata data, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC1271Constants.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ncontract ERC1271Constants {\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC1654.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ninterface ERC1654 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param hash 32 bytes hash to be signed\n     * @param signature Signature byte array associated with hash\n     * @return magicValue 0x1626ba7e if valid else 0x00000000\n     */\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC1654Constants.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ncontract ERC1654Constants {\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\n}\n"
    },
    "src/solc_0.6/common/Libraries/SafeMathWithRequire.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMathWithRequire {\n    using SafeMathWithRequire for uint256;\n\n    uint256 constant DECIMALS_18 = 1000000000000000000;\n    uint256 constant DECIMALS_12 = 1000000000000;\n    uint256 constant DECIMALS_9 = 1000000000;\n    uint256 constant DECIMALS_6 = 1000000;\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"divbyzero\");\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"undeflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"overflow\");\n        return c;\n    }\n\n    function sqrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_12);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function sqrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_6);\n        uint256 tmp = a.add(1) / 2;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n\n    function cbrt6(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_18);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n\n    function cbrt3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_9);\n        uint256 tmp = a.add(2) / 3;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpSquare = tmp**2;\n            require(tmpSquare > tmp, \"overflow\");\n            tmp = ((a / tmpSquare) + (tmp * 2)) / 3;\n        }\n        return c;\n    }\n\n    // TODO test\n    function rt6_3(uint256 a) internal pure returns (uint256 c) {\n        a = a.mul(DECIMALS_18);\n        uint256 tmp = a.add(5) / 6;\n        c = a;\n        // tmp cannot be zero unless a = 0 which skip the loop\n        while (tmp < c) {\n            c = tmp;\n            uint256 tmpFive = tmp**5;\n            require(tmpFive > tmp, \"overflow\");\n            tmp = ((a / tmpFive) + (tmp * 5)) / 6;\n        }\n    }\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC165.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title ERC165\n * @dev https://eips.ethereum.org/EIPS/eip-165\n */\ninterface ERC165 {\n    /**\n     * @notice Query if a contract implements interface `interfaceId`\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC721Events.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface ERC721Events {\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n}\n"
    },
    "src/solc_0.6/test/MockERC20.sol": {
      "content": "pragma solidity 0.6.5;\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/Ownable.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\n\n\ncontract ERC20Impl is ERC20 {\n    using SafeMathWithRequire for uint256;\n\n    mapping(address => uint256) public _balances;\n\n    mapping(address => mapping(address => uint256)) public _allowances;\n\n    uint256 public _totalSupply;\n\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\n\ncontract MintableToken is ERC20Impl, Ownable {\n    function mint(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    constructor() public Ownable(msg.sender) {}\n}\n\n\ncontract MockERC20 is MintableToken {\n    string public constant name = \"Mock Token\";\n    string public constant symbol = \"MCK\";\n    uint8 public constant decimals = 18;\n}\n"
    },
    "src/solc_0.6/common/BaseWithStorage/Ownable.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address payable public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor(address payable _owner) public {\n        owner = _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    // /**\n    // * @dev Allows the current owner to relinquish control of the contract.\n    // * @notice Renouncing to ownership will leave the contract without an owner.\n    // * It will not be possible to call the functions with the `onlyOwner`\n    // * modifier anymore.\n    // */\n    // function renounceOwnership() public onlyOwner {\n    //     emit OwnershipRenounced(owner);\n    //     owner = address(0);\n    // }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address payable _newOwner) internal {\n        require(_newOwner != address(0));\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"
    },
    "src/solc_0.6/StarterPack/StarterPackV1.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../common/Interfaces/Medianizer.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\nimport \"../Catalyst/ERC20GroupCatalyst.sol\";\nimport \"../Catalyst/ERC20GroupGem.sol\";\nimport \"./PurchaseValidator.sol\";\n\n\n/// @title StarterPack contract that supports SAND, DAI and ETH as payment\n/// @notice This contract manages the purchase and distribution of StarterPacks (bundles of Catalysts and Gems)\ncontract StarterPackV1 is Admin, MetaTransactionReceiver, PurchaseValidator {\n    using SafeMathWithRequire for uint256;\n    uint256 internal constant DAI_PRICE = 44000000000000000;\n    uint256 private constant DECIMAL_PLACES = 1 ether;\n\n    ERC20 internal immutable _sand;\n    Medianizer private immutable _medianizer;\n    ERC20 private immutable _dai;\n    ERC20Group internal immutable _erc20GroupCatalyst;\n    ERC20Group internal immutable _erc20GroupGem;\n\n    bool _sandEnabled;\n    bool _etherEnabled;\n    bool _daiEnabled;\n\n    uint256[] private _starterPackPrices;\n    uint256[] private _previousStarterPackPrices;\n    uint256 private _gemPrice;\n    uint256 private _previousGemPrice;\n\n    // The timestamp of the last pricechange\n    uint256 private _priceChangeTimestamp;\n\n    address payable internal _wallet;\n\n    // The delay between calling setPrices() and when the new prices come into effect.\n    // Minimizes the effect of price changes on pending TXs\n    uint256 private constant PRICE_CHANGE_DELAY = 1 hours;\n\n    event Purchase(address indexed buyer, Message message, uint256 price, address token, uint256 amountPaid);\n\n    event SetPrices(uint256[] prices, uint256 gemPrice);\n\n    struct Message {\n        uint256[] catalystIds;\n        uint256[] catalystQuantities;\n        uint256[] gemIds;\n        uint256[] gemQuantities;\n        uint256 nonce;\n    }\n\n    // ////////////////////////// Functions ////////////////////////\n\n    /// @notice Set the wallet receiving the proceeds\n    /// @param newWallet Address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"WALLET_ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }\n\n    /// @notice Enable / disable DAI payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setDAIEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _daiEnabled = enabled;\n    }\n\n    /// @notice Return whether DAI payments are enabled\n    /// @return Whether DAI payments are enabled\n    function isDAIEnabled() external view returns (bool) {\n        return _daiEnabled;\n    }\n\n    /// @notice Enable / disable ETH payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setETHEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _etherEnabled = enabled;\n    }\n\n    /// @notice Return whether ETH payments are enabled\n    /// @return Whether ETH payments are enabled\n    function isETHEnabled() external view returns (bool) {\n        return _etherEnabled;\n    }\n\n    /// @dev Enable / disable the specific SAND payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setSANDEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _sandEnabled = enabled;\n    }\n\n    /// @notice Return whether SAND payments are enabled\n    /// @return Whether SAND payments are enabled\n    function isSANDEnabled() external view returns (bool) {\n        return _sandEnabled;\n    }\n\n    /// @notice Purchase StarterPacks with SAND\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n\n    function purchaseWithSand(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_sandEnabled, \"SAND_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_sand), amountInSand);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_sand), amountInSand);\n    }\n\n    /// @notice Purchase StarterPacks with Ether\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n    function purchaseWithETH(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external payable {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_etherEnabled, \"ETHER_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 ETHRequired = getEtherAmountWithSAND(amountInSand);\n        require(msg.value >= ETHRequired, \"NOT_ENOUGH_ETHER_SENT\");\n\n        _wallet.transfer(ETHRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(0), ETHRequired);\n\n        if (msg.value - ETHRequired > 0) {\n            // refund extra\n            (bool success, ) = msg.sender.call{value: msg.value - ETHRequired}(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    /// @notice Purchase StarterPacks with DAI\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n    function purchaseWithDAI(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_daiEnabled, \"DAI_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 DAIRequired = amountInSand.mul(DAI_PRICE).div(DECIMAL_PLACES);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_dai), DAIRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_dai), DAIRequired);\n    }\n\n    /// @notice Enables admin to withdraw all remaining tokens\n    /// @param to The destination address for the purchased Catalysts and Gems\n    /// @param catalystIds The IDs of the catalysts to be transferred\n    /// @param gemIds The IDs of the gems to be transferred\n    function withdrawAll(\n        address to,\n        uint256[] calldata catalystIds,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n\n        address[] memory catalystAddresses = new address[](catalystIds.length);\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            catalystAddresses[i] = address(this);\n        }\n        address[] memory gemAddresses = new address[](gemIds.length);\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            gemAddresses[i] = address(this);\n        }\n        uint256[] memory unsoldCatalystQuantities = _erc20GroupCatalyst.balanceOfBatch(catalystAddresses, catalystIds);\n        uint256[] memory unsoldGemQuantities = _erc20GroupGem.balanceOfBatch(gemAddresses, gemIds);\n\n        _erc20GroupCatalyst.batchTransferFrom(address(this), to, catalystIds, unsoldCatalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), to, gemIds, unsoldGemQuantities);\n    }\n\n    /// @notice Enables admin to change the prices of the StarterPack bundles\n    /// @param prices Array of new prices that will take effect after a delay period\n    /// @param gemPrice New price for gems that will take effect after a delay period\n\n    function setPrices(uint256[] calldata prices, uint256 gemPrice) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _previousStarterPackPrices = _starterPackPrices;\n        _starterPackPrices = prices;\n        _previousGemPrice = _gemPrice;\n        _gemPrice = gemPrice;\n        _priceChangeTimestamp = now;\n        emit SetPrices(prices, gemPrice);\n    }\n\n    /// @notice Get current StarterPack prices\n    /// @return pricesBeforeSwitch Array of prices before price change\n    /// @return pricesAfterSwitch Array of prices after price change\n    /// @return gemPriceBeforeSwitch Gem price before price change\n    /// @return gemPriceAfterSwitch Gem price after price change\n    /// @return switchTime The time the latest price change will take effect, being the time of the price change plus the price change delay\n\n    function getPrices()\n        external\n        view\n        returns (\n            uint256[] memory pricesBeforeSwitch,\n            uint256[] memory pricesAfterSwitch,\n            uint256 gemPriceBeforeSwitch,\n            uint256 gemPriceAfterSwitch,\n            uint256 switchTime\n        )\n    {\n        switchTime = 0;\n        if (_priceChangeTimestamp != 0) {\n            switchTime = _priceChangeTimestamp + PRICE_CHANGE_DELAY;\n        }\n        return (_previousStarterPackPrices, _starterPackPrices, _previousGemPrice, _gemPrice, switchTime);\n    }\n\n    /// @notice Returns the amount of ETH for a specific amount of SAND\n    /// @param sandAmount An amount of SAND\n    /// @return The amount of ETH\n    function getEtherAmountWithSAND(uint256 sandAmount) public view returns (uint256) {\n        uint256 ethUsdPair = _getEthUsdPair();\n        return sandAmount.mul(DAI_PRICE).div(ethUsdPair);\n    }\n\n    // ////////////////////////// Internal ////////////////////////\n\n    /// @dev Gets the ETHUSD pair from the Medianizer contract\n    /// @return The pair as an uint256\n    function _getEthUsdPair() internal view returns (uint256) {\n        bytes32 pair = _medianizer.read();\n        return uint256(pair);\n    }\n\n    /// @dev Function to calculate the total price in SAND of the StarterPacks to be purchased\n    /// @dev The price of each StarterPack relates to the catalystId\n    /// @param catalystIds Array of catalystIds to be purchase\n    /// @param catalystQuantities Array of quantities of those catalystIds to be purchased\n    /// @return Total price in SAND\n    function _calculateTotalPriceInSand(\n        uint256[] memory catalystIds,\n        uint256[] memory catalystQuantities,\n        uint256[] memory gemQuantities\n    ) internal returns (uint256) {\n        require(catalystIds.length == catalystQuantities.length, \"INVALID_INPUT\");\n        (uint256[] memory prices, uint256 gemPrice) = _priceSelector();\n        uint256 totalPrice;\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            uint256 id = catalystIds[i];\n            uint256 quantity = catalystQuantities[i];\n            totalPrice = totalPrice.add(prices[id].mul(quantity));\n        }\n        for (uint256 i = 0; i < gemQuantities.length; i++) {\n            uint256 quantity = gemQuantities[i];\n            totalPrice = totalPrice.add(gemPrice.mul(quantity));\n        }\n        return totalPrice;\n    }\n\n    /// @dev Function to determine whether to use old or new prices\n    /// @return Array of prices\n\n    function _priceSelector() internal returns (uint256[] memory, uint256) {\n        uint256[] memory prices;\n        uint256 gemPrice;\n        // No price change:\n        if (_priceChangeTimestamp == 0) {\n            prices = _starterPackPrices;\n            gemPrice = _gemPrice;\n        } else {\n            // Price change delay has expired.\n            if (now > _priceChangeTimestamp + PRICE_CHANGE_DELAY) {\n                _priceChangeTimestamp = 0;\n                prices = _starterPackPrices;\n                gemPrice = _gemPrice;\n            } else {\n                // Price change has occured:\n                prices = _previousStarterPackPrices;\n                gemPrice = _previousGemPrice;\n            }\n        }\n        return (prices, gemPrice);\n    }\n\n    /// @dev Function to handle purchase with SAND or DAI\n    function _handlePurchaseWithERC20(\n        address buyer,\n        address payable paymentRecipient,\n        address tokenAddress,\n        uint256 amount\n    ) internal {\n        ERC20 token = ERC20(tokenAddress);\n        uint256 amountForDestination = amount;\n        require(token.transferFrom(buyer, paymentRecipient, amountForDestination), \"PAYMENT_TRANSFER_FAILED\");\n    }\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n\n    constructor(\n        address starterPackAdmin,\n        address sandContractAddress,\n        address initialMetaTx,\n        address payable initialWalletAddress,\n        address medianizerContractAddress,\n        address daiTokenContractAddress,\n        address erc20GroupCatalystAddress,\n        address erc20GroupGemAddress,\n        address initialSigningWallet,\n        uint256[] memory initialStarterPackPrices,\n        uint256 initialGemPrice\n    ) public PurchaseValidator(initialSigningWallet) {\n        _setMetaTransactionProcessor(initialMetaTx, true);\n        _wallet = initialWalletAddress;\n        _admin = starterPackAdmin;\n        _sand = ERC20(sandContractAddress);\n        _medianizer = Medianizer(medianizerContractAddress);\n        _dai = ERC20(daiTokenContractAddress);\n        _erc20GroupCatalyst = ERC20Group(erc20GroupCatalystAddress);\n        _erc20GroupGem = ERC20Group(erc20GroupGemAddress);\n        _starterPackPrices = initialStarterPackPrices;\n        _previousStarterPackPrices = initialStarterPackPrices;\n        _gemPrice = initialGemPrice;\n        _previousGemPrice = initialGemPrice;\n        _sandEnabled = true; // Sand is enabled by default\n        _etherEnabled = true; // Ether is enabled by default\n    }\n}\n"
    },
    "src/solc_0.6/common/Interfaces/Medianizer.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title Medianizer contract\n * @dev From MakerDAO (https://etherscan.io/address/0x729D19f657BD0614b4985Cf1D82531c67569197B#code)\n */\ninterface Medianizer {\n    function read() external view returns (bytes32);\n}\n"
    },
    "src/solc_0.6/Catalyst/ERC20GroupCatalyst.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseWithStorage/ERC20Group.sol\";\nimport \"./CatalystDataBase.sol\";\nimport \"../BaseWithStorage/ERC20SubToken.sol\";\nimport \"./CatalystValue.sol\";\n\n\ncontract ERC20GroupCatalyst is CatalystDataBase, ERC20Group {\n    /// @dev add Catalyst, if one of the catalyst to be added in the batch need to have a value override, all catalyst added in that batch need to have override\n    /// if this is not desired, they can be added in a separated batch\n    /// if no override are needed, the valueOverrides can be left emopty\n    function addCatalysts(\n        ERC20SubToken[] memory catalysts,\n        MintData[] memory mintData,\n        CatalystValue[] memory valueOverrides\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(catalysts.length == mintData.length, \"INVALID_INCONSISTENT_LENGTH\");\n        for (uint256 i = 0; i < mintData.length; i++) {\n            uint256 id = _addSubToken(catalysts[i]);\n            _setMintData(id, mintData[i]);\n            if (valueOverrides.length > i) {\n                _setValueOverride(id, valueOverrides[i]);\n            }\n        }\n    }\n\n    function addCatalyst(\n        ERC20SubToken catalyst,\n        MintData memory mintData,\n        CatalystValue valueOverride\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        uint256 id = _addSubToken(catalyst);\n        _setMintData(id, mintData);\n        _setValueOverride(id, valueOverride);\n    }\n\n    function setConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) external {\n        // CatalystMinter hardcode the value for efficiency purpose, so a change here would require a new deployment of CatalystMinter\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) public ERC20Group(metaTransactionContract, admin, initialMinter) {}\n}\n"
    },
    "src/solc_0.6/Catalyst/ERC20GroupGem.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseWithStorage/ERC20Group.sol\";\n\n\ncontract ERC20GroupGem is ERC20Group {\n    function addGems(ERC20SubToken[] calldata catalysts) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        for (uint256 i = 0; i < catalysts.length; i++) {\n            _addSubToken(catalysts[i]);\n        }\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) public ERC20Group(metaTransactionContract, admin, initialMinter) {}\n}\n"
    },
    "src/solc_0.6/StarterPack/PurchaseValidator.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\n\n\ncontract PurchaseValidator is Admin {\n    address private _signingWallet;\n\n    // A parallel-queue mapping to nonces.\n    mapping(address => mapping(uint128 => uint128)) public queuedNonces;\n\n    /// @notice Function to get the nonce for a given address and queue ID\n    /// @param _buyer The address of the starterPack purchaser\n    /// @param _queueId The ID of the nonce queue for the given address.\n    /// The default is queueID=0, and the max is queueID=2**128-1\n    /// @return uint128 representing the requestied nonce\n    function getNonceByBuyer(address _buyer, uint128 _queueId) external view returns (uint128) {\n        return queuedNonces[_buyer][_queueId];\n    }\n\n    /// @notice Check if a purchase message is valid\n    /// @param buyer The address paying for the purchase & receiving tokens\n    /// @param catalystIds The catalyst IDs to be purchased\n    /// @param catalystQuantities The quantities of the catalysts to be purchased\n    /// @param gemIds The gem IDs to be purchased\n    /// @param gemQuantities The quantities of the gems to be purchased\n    /// @param nonce The current nonce for the user. This is represented as a\n    /// uint256 value, but is actually 2 packed uint128's (queueId + nonce)\n    /// @param signature A signed message specifying tx details\n    /// @return True if the purchase is valid\n    function isPurchaseValid(\n        address buyer,\n        uint256[] memory catalystIds,\n        uint256[] memory catalystQuantities,\n        uint256[] memory gemIds,\n        uint256[] memory gemQuantities,\n        uint256 nonce,\n        bytes memory signature\n    ) public returns (bool) {\n        require(_checkAndUpdateNonce(buyer, nonce), \"INVALID_NONCE\");\n        bytes32 hashedData = keccak256(abi.encodePacked(catalystIds, catalystQuantities, gemIds, gemQuantities, buyer, nonce));\n\n        address signer = SigUtil.recover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashedData)), signature);\n        return signer == _signingWallet;\n    }\n\n    /// @notice Get the wallet authorized for signing purchase-messages.\n    /// @return the address of the signing wallet\n    function getSigningWallet() external view returns (address) {\n        return _signingWallet;\n    }\n\n    /// @notice Update the signing wallet address\n    /// @param newSigningWallet The new address of the signing wallet\n    function updateSigningWallet(address newSigningWallet) external {\n        require(_admin == msg.sender, \"SENDER_NOT_ADMIN\");\n        _signingWallet = newSigningWallet;\n    }\n\n    /// @dev Function for validating the nonce for a user.\n    /// @param _buyer The address for which we want to check the nonce\n    /// @param _packedValue The queueId + nonce, packed together.\n    /// EG: for queueId=42 nonce=7, pass: \"0x0000000000000000000000000000002A00000000000000000000000000000007\"\n    function _checkAndUpdateNonce(address _buyer, uint256 _packedValue) private returns (bool) {\n        uint128 queueId = uint128(_packedValue / 2**128);\n        uint128 nonce = uint128(_packedValue % 2**128);\n        uint128 currentNonce = queuedNonces[_buyer][queueId];\n        if (nonce == currentNonce) {\n            queuedNonces[_buyer][queueId] = currentNonce + 1;\n            return true;\n        }\n        return false;\n    }\n\n    constructor(address initialSigningWallet) public {\n        _signingWallet = initialSigningWallet;\n    }\n}\n"
    },
    "src/solc_0.6/BaseWithStorage/ERC20Group.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20SubToken.sol\";\nimport \"../common/Libraries/SafeMath.sol\";\nimport \"../common/Libraries/AddressUtils.sol\";\nimport \"../common/Libraries/ObjectLib32.sol\";\nimport \"../common/Libraries/BytesUtil.sol\";\n\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\ncontract ERC20Group is SuperOperators, MetaTransactionReceiver {\n    uint256 internal constant MAX_UINT256 = ~uint256(0);\n\n    /// @notice emitted when a new Token is added to the group.\n    /// @param subToken the token added, its id will be its index in the array.\n    event SubToken(ERC20SubToken subToken);\n\n    /// @notice emitted when `owner` is allowing or disallowing `operator` to transfer tokens on its behalf.\n    /// @param owner the address approving.\n    /// @param operator the address being granted (or revoked) permission to transfer.\n    /// @param approved whether the operator is granted transfer right or not.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Minter(address minter, bool enabled);\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setMinter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @dev mint more tokens of a specific subToken .\n    /// @param to address receiving the tokens.\n    /// @param id subToken id (also the index at which it was added).\n    /// @param amount of token minted.\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        toPack[bin] = toPack[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _packedSupplies[bin] = _packedSupplies[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _erc20s[id].emitTransferEvent(address(0), to, amount);\n    }\n\n    /// @dev mint more tokens of a several subToken .\n    /// @param to address receiving the tokens.\n    /// @param ids subToken ids (also the index at which it was added).\n    /// @param amounts for each token minted.\n    function batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        require(ids.length == amounts.length, \"INVALID_INCONSISTENT_LENGTH\");\n        _batchMint(to, ids, amounts);\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 bal = 0;\n        uint256 supply = 0;\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    bal = toPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        toPack[lastBin] = bal;\n                        bal = toPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n                    bal = bal.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                }\n                _erc20s[ids[i]].emitTransferEvent(address(0), to, amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            toPack[lastBin] = bal;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    /// @notice return the current total supply of a specific subToken.\n    /// @param id subToken id.\n    /// @return supply current total number of tokens.\n    function supplyOf(uint256 id) external view returns (uint256 supply) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedSupplies[bin].getValueInBin(index);\n    }\n\n    /// @notice return the balance of a particular owner for a particular subToken.\n    /// @param owner whose balance it is of.\n    /// @param id subToken id.\n    /// @return balance of the owner\n    function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }\n\n    /// @notice return the balances of a list of owners / subTokens.\n    /// @param owners list of addresses to which we want to know the balance.\n    /// @param ids list of subTokens's addresses.\n    /// @return balances list of balances for each request.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\n        require(owners.length == ids.length, \"INVALID_INCONSISTENT_LENGTH\");\n        balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n    }\n\n    /// @notice transfer a number of subToken from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param id subToken id.\n    /// @param value amount of tokens to transfer.\n    function singleTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        ERC20SubToken erc20 = _erc20s[id];\n        require(\n            from == msg.sender ||\n                msg.sender == address(erc20) ||\n                _metaTransactionContracts[msg.sender] ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        fromPack[bin] = fromPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.SUB);\n        toPack[bin] = toPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.ADD);\n        erc20.emitTransferEvent(from, to, value);\n    }\n\n    /// @notice transfer a number of different subTokens from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param ids list of subToken ids to transfer.\n    /// @param values list of amount for eacg subTokens to transfer.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external {\n        require(ids.length == values.length, \"INVALID_INCONSISTENT_LENGTH\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _batchTransferFrom(from, to, ids, values);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 balFrom;\n        uint256 balTo;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (values[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = ObjectLib32.updateTokenBalance(fromPack[bin], index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = ObjectLib32.updateTokenBalance(toPack[bin], index, values[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        toPack[lastBin] = balTo;\n                        balFrom = fromPack[bin];\n                        balTo = toPack[bin];\n                        lastBin = bin;\n                    }\n                    balFrom = balFrom.updateTokenBalance(index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = balTo.updateTokenBalance(index, values[i], ObjectLib32.Operations.ADD);\n                }\n                ERC20SubToken erc20 = _erc20s[ids[i]];\n                erc20.emitTransferEvent(from, to, values[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            toPack[lastBin] = balTo;\n        }\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.\n    /// @param sender address granting/revoking the approval.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"NOT_AUTHORIZED\");\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on your behalf.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.\n    /// @param owner address who would have granted the rights.\n    /// @param operator address being given the ability to transfer.\n    /// @return isOperator whether the operator has approval rigths or not.\n    function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function isAuthorizedToTransfer(address owner, address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender] || _operatorsForAll[owner][sender];\n    }\n\n    function isAuthorizedToApprove(address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender];\n    }\n\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(from != address(0), \"INVALID_FROM_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _batchBurnFrom(from, ids, amounts);\n    }\n\n    /// @notice burn token for a specific owner and subToken.\n    /// @param from fron which address the token are burned from.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _burn(from, id, value);\n    }\n\n    /// @notice burn token for a specific subToken.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }\n\n    // ///////////////// INTERNAL //////////////////////////\n\n    function _batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 balFrom = 0;\n        uint256 supply = 0;\n        uint256 lastBin = MAX_UINT256;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = fromPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        balFrom = fromPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n\n                    balFrom = balFrom.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                }\n                _erc20s[ids[i]].emitTransferEvent(from, address(0), amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal {\n        ERC20SubToken erc20 = _erc20s[id];\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        fromPack[bin] = ObjectLib32.updateTokenBalance(fromPack[bin], index, value, ObjectLib32.Operations.SUB);\n        _packedSupplies[bin] = ObjectLib32.updateTokenBalance(_packedSupplies[bin], index, value, ObjectLib32.Operations.SUB);\n        erc20.emitTransferEvent(from, address(0), value);\n    }\n\n    function _addSubToken(ERC20SubToken subToken) internal returns (uint256 id) {\n        id = _erc20s.length;\n        require(subToken.groupAddress() == address(this), \"INVALID_GROUP\");\n        require(subToken.groupTokenId() == id, \"INVALID_ID\");\n        _erc20s.push(subToken);\n        emit SubToken(subToken);\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_SUPER_OPERATOR\");\n        _operatorsForAll[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function _setMinter(address minter, bool enabled) internal {\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    // ///////////////// UTILITIES /////////////////////////\n    using AddressUtils for address;\n    using ObjectLib32 for ObjectLib32.Operations;\n    using ObjectLib32 for uint256;\n    using SafeMath for uint256;\n\n    // ////////////////// DATA ///////////////////////////////\n    mapping(uint256 => uint256) internal _packedSupplies;\n    mapping(address => mapping(uint256 => uint256)) internal _packedTokenBalance;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    ERC20SubToken[] internal _erc20s;\n    mapping(address => bool) internal _minters;\n\n    // ////////////// CONSTRUCTOR ////////////////////////////\n\n    struct SubTokenData {\n        string name;\n        string symbol;\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _setMinter(initialMinter, true);\n    }\n}\n"
    },
    "src/solc_0.6/Catalyst/CatalystDataBase.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./CatalystValue.sol\";\n\n\ncontract CatalystDataBase is CatalystValue {\n    event CatalystConfiguration(uint256 indexed id, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, uint256 sandUpdateFee);\n\n    function _setMintData(uint256 id, MintData memory data) internal {\n        _data[id] = data;\n        _emitConfiguration(id, data.minQuantity, data.maxQuantity, data.sandMintingFee, data.sandUpdateFee);\n    }\n\n    function _setValueOverride(uint256 id, CatalystValue valueOverride) internal {\n        _valueOverrides[id] = valueOverride;\n    }\n\n    function _setConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) internal {\n        _data[id].minQuantity = minQuantity;\n        _data[id].maxQuantity = maxQuantity;\n        _data[id].sandMintingFee = uint88(sandMintingFee);\n        _data[id].sandUpdateFee = uint88(sandUpdateFee);\n        _emitConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    function _emitConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) internal {\n        emit CatalystConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    ///@dev compute a random value between min to 25.\n    //. example: 1-25, 6-25, 11-25, 16-25\n    function _computeValue(\n        uint256 seed,\n        uint256 gemId,\n        bytes32 blockHash,\n        uint256 slotIndex,\n        uint32 min\n    ) internal pure returns (uint32) {\n        return min + uint16(uint256(keccak256(abi.encodePacked(gemId, seed, blockHash, slotIndex))) % (26 - min));\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        CatalystValue valueOverride = _valueOverrides[catalystId];\n        if (address(valueOverride) != address(0)) {\n            return valueOverride.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n        }\n        values = new uint32[](totalNumberOfGemTypes);\n\n        uint32 numGems;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGems += uint32(events[i].gemIds.length);\n        }\n        require(numGems <= MAX_UINT32, \"TOO_MANY_GEMS\");\n        uint32 minValue = (numGems - 1) * 5 + 1;\n\n        uint256 numGemsSoFar = 0;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGemsSoFar += events[i].gemIds.length;\n            for (uint256 j = 0; j < events[i].gemIds.length; j++) {\n                uint256 gemId = events[i].gemIds[j];\n                uint256 slotIndex = numGemsSoFar - events[i].gemIds.length + j;\n                if (values[gemId] == 0) {\n                    // first gem : value = roll between ((numGemsSoFar-1)*5+1) and 25\n                    values[gemId] = _computeValue(seed, gemId, events[i].blockHash, slotIndex, (uint32(numGemsSoFar) - 1) * 5 + 1);\n                    // bump previous values:\n                    if (values[gemId] < minValue) {\n                        values[gemId] = minValue;\n                    }\n                } else {\n                    // further gem, previous roll are overriden with 25 and new roll between 1 and 25\n                    uint32 newRoll = _computeValue(seed, gemId, events[i].blockHash, slotIndex, 1);\n                    values[gemId] = (((values[gemId] - 1) / 25) + 1) * 25 + newRoll;\n                }\n            }\n        }\n    }\n\n    function getMintData(uint256 catalystId)\n        external\n        view\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        )\n    {\n        maxGems = _data[catalystId].maxGems;\n        minQuantity = _data[catalystId].minQuantity;\n        maxQuantity = _data[catalystId].maxQuantity;\n        sandMintingFee = _data[catalystId].sandMintingFee;\n        sandUpdateFee = _data[catalystId].sandUpdateFee;\n    }\n\n    struct MintData {\n        uint88 sandMintingFee;\n        uint88 sandUpdateFee;\n        uint16 minQuantity;\n        uint16 maxQuantity;\n        uint16 maxGems;\n    }\n\n    uint32 internal constant MAX_UINT32 = 2**32 - 1;\n\n    mapping(uint256 => MintData) internal _data;\n    mapping(uint256 => CatalystValue) internal _valueOverrides;\n}\n"
    },
    "src/solc_0.6/BaseWithStorage/ERC20SubToken.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\nimport \"./ERC20Group.sol\";\n\n\ncontract ERC20SubToken {\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice A descriptive name for the tokens\n    /// @return name of the tokens\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// @notice An abbreviated name for the tokens\n    /// @return symbol of the tokens\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice the tokenId in ERC20Group\n    /// @return the tokenId in ERC20Group\n    function groupTokenId() external view returns (uint256) {\n        return _index;\n    }\n\n    /// @notice the ERC20Group address\n    /// @return the address of the group\n    function groupAddress() external view returns (address) {\n        return address(_group);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _group.supplyOf(_index);\n    }\n\n    function balanceOf(address who) external view returns (uint256) {\n        return _group.balanceOf(who, _index);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(0);\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success) {\n        if (msg.sender != from && !_group.isAuthorizedToTransfer(from, msg.sender)) {\n            uint256 allowance = _mAllowed[from][msg.sender];\n            if (allowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _mAllowed[from][msg.sender] = allowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool success) {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveFor(\n        address from,\n        address spender,\n        uint256 amount\n    ) external returns (bool success) {\n        require(msg.sender == from || _group.isAuthorizedToApprove(msg.sender), \"NOT_AUTHORIZED\");\n        _approveFor(from, spender, amount);\n        return true;\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == address(_group), \"NOT_AUTHORIZED_GROUP_ONLY\");\n        emit Transfer(from, to, amount);\n    }\n\n    // /////////////////// INTERNAL ////////////////////////\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0) && spender != address(0), \"INVALID_FROM_OR_SPENDER\");\n        _mAllowed[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\n        return _mAllowed[owner][spender];\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        _group.singleTransferFrom(from, to, _index, amount);\n    }\n\n    // ///////////////////// UTILITIES ///////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////// CONSTRUCTOR /////////////////////\n    constructor(\n        ERC20Group group,\n        uint256 index,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        _group = group;\n        _index = index;\n        _name = tokenName;\n        _symbol = tokenSymbol;\n    }\n\n    // ////////////////////// DATA ///////////////////////////\n    ERC20Group internal immutable _group;\n    uint256 internal immutable _index;\n    mapping(address => mapping(address => uint256)) internal _mAllowed;\n    string internal _name;\n    string internal _symbol;\n}\n"
    },
    "src/solc_0.6/Catalyst/CatalystValue.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface CatalystValue {\n    struct GemEvent {\n        uint256[] gemIds;\n        bytes32 blockHash;\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external view returns (uint32[] memory values);\n}\n"
    },
    "src/solc_0.6/common/Libraries/SafeMath.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/AddressUtils.sol": {
      "content": "pragma solidity 0.6.5;\n\n\nlibrary AddressUtils {\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/ObjectLib32.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary ObjectLib32 {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 32; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n     * @dev Return the bin number and index within that bin where ID is\n     * @param tokenId Object type\n     * @return bin Bin number\n     * @return index ID's index within that bin\n     */\n    function getTokenBinIndex(uint256 tokenId) internal pure returns (uint256 bin, uint256 index) {\n        bin = (tokenId * TYPES_BITS_SIZE) / 256;\n        index = tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in binBalances\n     * @param binBalances Uint256 containing the balances of objects\n     * @param index Index of the object in the provided bin\n     * @param amount Value to update the type balance\n     * @param operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with amount\n     *     Operations.ADD     : ADD amount to type balance\n     *     Operations.SUB     : Substract amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 binBalances,\n        uint256 index,\n        uint256 amount,\n        Operations operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (operation == Operations.ADD) {\n            objectBalance = getValueInBin(binBalances, index);\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.add(amount));\n        } else if (operation == Operations.SUB) {\n            objectBalance = getValueInBin(binBalances, index);\n            require(objectBalance >= amount, \"can't substract more than there is\");\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.sub(amount));\n        } else if (operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(binBalances, index, amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in binValue at position index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index index at which to retrieve value\n     * @return Value at given index in bin\n     */\n    function getValueInBin(uint256 binValue, uint256 index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated binValue after writing amount at index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index Index at which to retrieve value\n     * @param amount Value to store at index in bin\n     * @return Value at given index in bin\n     */\n    function writeValueInBin(\n        uint256 binValue,\n        uint256 index,\n        uint256 amount\n    ) internal pure returns (uint256) {\n        require(amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue & ~(mask << leftShift)) | (amount << leftShift);\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/BytesUtil.sol": {
      "content": "pragma solidity 0.6.5;\n\n\nlibrary BytesUtil {\n    function memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(\n        bytes memory data,\n        uint256 i,\n        uint256 value\n    ) internal pure returns (bool) {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(bytes memory data, address _address) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n"
    },
    "src/solc_0.6/common/BaseWithStorage/SuperOperators.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./Admin.sol\";\n\n\ncontract SuperOperators is Admin {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n"
    },
    "src/solc_0.6/ReferralValidator/ReferralValidator.sol": {
      "content": "/* solhint-disable not-rely-on-time, func-order */\npragma solidity 0.6.5;\n\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\n\n\n/// @dev This contract verifies if a referral is valid\ncontract ReferralValidator is Admin {\n    address private _signingWallet;\n    uint256 private _maxCommissionRate;\n\n    mapping(address => uint256) private _previousSigningWallets;\n    uint256 private _previousSigningDelay = 60 * 60 * 24 * 10;\n\n    event ReferralUsed(\n        address indexed referrer,\n        address indexed referee,\n        address indexed token,\n        uint256 amount,\n        uint256 commission,\n        uint256 commissionRate\n    );\n\n    constructor(address initialSigningWallet, uint256 initialMaxCommissionRate) public {\n        _signingWallet = initialSigningWallet;\n        _maxCommissionRate = initialMaxCommissionRate;\n    }\n\n    /**\n     * @dev Update the signing wallet\n     * @param newSigningWallet The new address of the signing wallet\n     */\n    function updateSigningWallet(address newSigningWallet) external {\n        require(_admin == msg.sender, \"Sender not admin\");\n        _previousSigningWallets[_signingWallet] = now + _previousSigningDelay;\n        _signingWallet = newSigningWallet;\n    }\n\n    /**\n     * @dev signing wallet authorized for referral\n     * @return the address of the signing wallet\n     */\n    function getSigningWallet() external view returns (address) {\n        return _signingWallet;\n    }\n\n    /**\n     * @notice the max commision rate\n     * @return the maximum commision rate that a referral can give\n     */\n    function getMaxCommisionRate() external view returns (uint256) {\n        return _maxCommissionRate;\n    }\n\n    /**\n     * @dev Update the maximum commission rate\n     * @param newMaxCommissionRate The new maximum commission rate\n     */\n    function updateMaxCommissionRate(uint256 newMaxCommissionRate) external {\n        require(_admin == msg.sender, \"Sender not admin\");\n        _maxCommissionRate = newMaxCommissionRate;\n    }\n\n    function handleReferralWithETH(\n        uint256 amount,\n        bytes memory referral,\n        address payable destination\n    ) internal {\n        uint256 amountForDestination = amount;\n\n        if (referral.length > 0) {\n            (bytes memory signature, address referrer, address referee, uint256 expiryTime, uint256 commissionRate) = decodeReferral(referral);\n\n            uint256 commission = 0;\n\n            if (isReferralValid(signature, referrer, referee, expiryTime, commissionRate)) {\n                commission = SafeMathWithRequire.div(SafeMathWithRequire.mul(amount, commissionRate), 10000);\n\n                emit ReferralUsed(referrer, referee, address(0), amount, commission, commissionRate);\n                amountForDestination = SafeMathWithRequire.sub(amountForDestination, commission);\n            }\n\n            if (commission > 0) {\n                payable(referrer).transfer(commission);\n            }\n        }\n\n        destination.transfer(amountForDestination);\n    }\n\n    function handleReferralWithERC20(\n        address buyer,\n        uint256 amount,\n        bytes memory referral,\n        address payable destination,\n        address tokenAddress\n    ) internal {\n        ERC20 token = ERC20(tokenAddress);\n        uint256 amountForDestination = amount;\n\n        if (referral.length > 0) {\n            (bytes memory signature, address referrer, address referee, uint256 expiryTime, uint256 commissionRate) = decodeReferral(referral);\n\n            uint256 commission = 0;\n\n            if (isReferralValid(signature, referrer, referee, expiryTime, commissionRate)) {\n                commission = SafeMathWithRequire.div(SafeMathWithRequire.mul(amount, commissionRate), 10000);\n\n                emit ReferralUsed(referrer, referee, tokenAddress, amount, commission, commissionRate);\n                amountForDestination = SafeMathWithRequire.sub(amountForDestination, commission);\n            }\n\n            if (commission > 0) {\n                require(token.transferFrom(buyer, referrer, commission), \"commision transfer failed\");\n            }\n        }\n\n        require(token.transferFrom(buyer, destination, amountForDestination), \"payment transfer failed\");\n    }\n\n    /**\n     * @notice Check if a referral is valid\n     * @param signature The signature to check (signed referral)\n     * @param referrer The address of the referrer\n     * @param referee The address of the referee\n     * @param expiryTime The expiry time of the referral\n     * @param commissionRate The commissionRate of the referral\n     * @return True if the referral is valid\n     */\n    function isReferralValid(\n        bytes memory signature,\n        address referrer,\n        address referee,\n        uint256 expiryTime,\n        uint256 commissionRate\n    ) public view returns (bool) {\n        if (commissionRate > _maxCommissionRate || referrer == referee || now > expiryTime) {\n            return false;\n        }\n\n        bytes32 hashedData = keccak256(abi.encodePacked(referrer, referee, expiryTime, commissionRate));\n\n        address signer = SigUtil.recover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashedData)), signature);\n\n        if (_previousSigningWallets[signer] >= now) {\n            return true;\n        }\n\n        return _signingWallet == signer;\n    }\n\n    function decodeReferral(bytes memory referral)\n        public\n        pure\n        returns (\n            bytes memory,\n            address,\n            address,\n            uint256,\n            uint256\n        )\n    {\n        (bytes memory signature, address referrer, address referee, uint256 expiryTime, uint256 commissionRate) = abi.decode(\n            referral,\n            (bytes, address, address, uint256, uint256)\n        );\n\n        return (signature, referrer, referee, expiryTime, commissionRate);\n    }\n}\n"
    },
    "src/solc_0.6/EstateSale/EstateSaleWithFee.sol": {
      "content": "/* solhint-disable not-rely-on-time, func-order */\npragma solidity 0.6.5;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"./LandToken.sol\";\nimport \"../common/Interfaces/ERC1155.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../ReferralValidator/ReferralValidator.sol\";\n\n\n/// @title Estate Sale contract with referral\n/// @notice This contract manages the sale of our lands as Estates\ncontract EstateSaleWithFee is MetaTransactionReceiver, ReferralValidator {\n    using SafeMathWithRequire for uint256;\n\n    event LandQuadPurchased(\n        address indexed buyer,\n        address indexed to,\n        uint256 indexed topCornerId,\n        uint256 size,\n        uint256 price,\n        address token,\n        uint256 amountPaid\n    );\n\n    /// @notice set the wallet receiving the proceeds\n    /// @param newWallet address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }\n\n    function rebalanceSand(uint256 newMultiplier) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _multiplier = newMultiplier;\n    }\n\n    function getSandMultiplier() external view returns (uint256) {\n        return _multiplier;\n    }\n\n    /// @notice buy Land with SAND using the merkle proof associated with it\n    /// @param buyer address that perform the payment\n    /// @param to address that will own the purchased Land\n    /// @param reserved the reserved address (if any)\n    /// @param x x coordinate of the Land\n    /// @param y y coordinate of the Land\n    /// @param size size of the pack of Land to purchase\n    /// @param priceInSand price in SAND to purchase that Land\n    /// @param proof merkleProof for that particular Land\n    function buyLandWithSand(\n        address buyer,\n        address to,\n        address reserved,\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 priceInSand,\n        uint256 adjustedPriceInSand,\n        bytes32 salt,\n        uint256[] calldata assetIds,\n        bytes32[] calldata proof,\n        bytes calldata referral\n    ) external {\n        _checkPrices(priceInSand, adjustedPriceInSand);\n        _checkValidity(buyer, reserved, x, y, size, priceInSand, salt, assetIds, proof);\n        _handleFeeAndReferral(buyer, adjustedPriceInSand, referral);\n        _mint(buyer, to, x, y, size, adjustedPriceInSand, address(_sand), adjustedPriceInSand);\n        _sendAssets(to, assetIds);\n    }\n\n    /// @notice Gets the expiry time for the current sale\n    /// @return The expiry time, as a unix epoch\n    function getExpiryTime() external view returns (uint256) {\n        return _expiryTime;\n    }\n\n    /// @notice Gets the Merkle root associated with the current sale\n    /// @return The Merkle root, as a bytes32 hash\n    function getMerkleRoot() external view returns (bytes32) {\n        return _merkleRoot;\n    }\n\n    /// @notice enable Admin to withdraw remaining assets from EstateSaleWithFee contract\n    /// @param to intended recipient of the asset tokens\n    /// @param assetIds the assetIds to be transferred\n    /// @param values the quantities of the assetIds to be transferred\n    function withdrawAssets(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata values\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        // require(block.timestamp > _expiryTime, \"SALE_NOT_OVER\"); // removed to recover in case of misconfigured sales\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xbc197c81;\n    }\n\n    function _sendAssets(address to, uint256[] memory assetIds) internal {\n        uint256[] memory values = new uint256[](assetIds.length);\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            values[i] = 1;\n        }\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n    }\n\n    function _checkPrices(uint256 priceInSand, uint256 adjustedPriceInSand) internal view {\n        require(adjustedPriceInSand == priceInSand.mul(_multiplier).div(MULTIPLIER_DECIMALS), \"INVALID_PRICE\");\n    }\n\n    function _checkValidity(\n        address buyer,\n        address reserved,\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 price,\n        bytes32 salt,\n        uint256[] memory assetIds,\n        bytes32[] memory proof\n    ) internal view {\n        /* solium-disable-next-line security/no-block-members */\n        require(block.timestamp < _expiryTime, \"SALE_IS_OVER\");\n        require(buyer == msg.sender || _metaTransactionContracts[msg.sender], \"NOT_AUTHORIZED\");\n        require(reserved == address(0) || reserved == buyer, \"RESERVED_LAND\");\n        bytes32 leaf = _generateLandHash(x, y, size, price, reserved, salt, assetIds);\n\n        require(_verify(proof, leaf), \"INVALID_LAND\");\n    }\n\n    function _mint(\n        address buyer,\n        address to,\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 price,\n        address token,\n        uint256 tokenAmount\n    ) internal {\n        if (size == 1 || _estate == address(0)) {\n            _land.mintQuad(to, size, x, y, \"\");\n        } else {\n            _land.mintQuad(_estate, size, x, y, abi.encode(to));\n        }\n        emit LandQuadPurchased(buyer, to, x + (y * GRID_SIZE), size, price, token, tokenAmount);\n    }\n\n    function _generateLandHash(\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 price,\n        address reserved,\n        bytes32 salt,\n        uint256[] memory assetIds\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(x, y, size, price, reserved, salt, assetIds));\n    }\n\n    function _verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        return computedHash == _merkleRoot;\n    }\n\n    function _handleFeeAndReferral(\n        address buyer,\n        uint256 priceInSand,\n        bytes memory referral\n    ) internal {\n        // send 5% fee to a specially configured instance of FeeDistributor.sol\n        uint256 remainingAmountInSand = _handleSandFee(buyer, priceInSand);\n\n        // calculate referral based on 95% of original priceInSand\n        handleReferralWithERC20(buyer, remainingAmountInSand, referral, _wallet, address(_sand));\n    }\n\n    function _handleSandFee(address buyer, uint256 priceInSand) internal returns (uint256) {\n        uint256 feeAmountInSand = priceInSand.mul(FEE).div(100);\n        require(_sand.transferFrom(buyer, address(_feeDistributor), feeAmountInSand), \"FEE_TRANSFER_FAILED\");\n        return priceInSand.sub(feeAmountInSand);\n    }\n\n    uint256 internal constant GRID_SIZE = 408; // 408 is the size of the Land\n\n    ERC1155 internal immutable _asset;\n    LandToken internal immutable _land;\n    ERC20 internal immutable _sand;\n    address internal immutable _estate;\n    address internal immutable _feeDistributor;\n\n    address payable internal _wallet;\n    uint256 internal immutable _expiryTime;\n    bytes32 internal immutable _merkleRoot;\n\n    uint256 private constant FEE = 5; // percentage of land sale price to be diverted to a specially configured instance of FeeDistributor, shown as an integer\n\n    uint256 private _multiplier = 1000; // multiplier used for rebalancing SAND values, 3 decimal places\n    uint256 private constant MULTIPLIER_DECIMALS = 1000;\n\n    constructor(\n        address landAddress,\n        address sandContractAddress,\n        address initialMetaTx,\n        address admin,\n        address payable initialWalletAddress,\n        bytes32 merkleRoot,\n        uint256 expiryTime,\n        address initialSigningWallet,\n        uint256 initialMaxCommissionRate,\n        address estate,\n        address asset,\n        address feeDistributor\n    ) public ReferralValidator(initialSigningWallet, initialMaxCommissionRate) {\n        _land = LandToken(landAddress);\n        _sand = ERC20(sandContractAddress);\n        _setMetaTransactionProcessor(initialMetaTx, true);\n        _wallet = initialWalletAddress;\n        _merkleRoot = merkleRoot;\n        _expiryTime = expiryTime;\n        _admin = admin;\n        _estate = estate;\n        _asset = ERC1155(asset);\n        _feeDistributor = feeDistributor;\n    }\n}\n"
    },
    "src/solc_0.6/EstateSale/LandToken.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ninterface LandToken {\n    function mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC1155.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface ERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /**\n        @notice Transfers `value` amount of an `id` from  `from` to `to`  (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if balance of holder for token `id` is lower than the `value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param id      ID of the token type\n        @param value   Transfer amount\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `to`\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Transfers `values` amount(s) of `ids` from the `from` address to the `to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if length of `ids` is not the same as length of `values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `ids` is lower than the respective amount(s) in `values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param ids     IDs of each token type (order and length must match _values array)\n        @param values  Transfer amounts per token type (order and length must match _ids array)\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `to`\n    */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Get the balance of an account's tokens.\n        @param owner  The address of the token holder\n        @param id     ID of the token\n        @return        The _owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param owners The addresses of the token holders\n        @param ids    ID of the tokens\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param operator  Address to add to the set of authorized operators\n        @param approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param owner     The owner of the tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/solc_0.6/test/MockLand.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"../common/Libraries/AddressUtils.sol\";\nimport \"../common/Interfaces/ERC721.sol\";\nimport \"../common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\ncontract MockERC721 is ERC721, SuperOperators, MetaTransactionReceiver {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping(address => uint256) public _numNFTPerAddress;\n    mapping(uint256 => uint256) public _owners;\n    mapping(address => mapping(address => bool)) public _operatorsForAll;\n    mapping(uint256 => address) public _operators;\n\n    constructor(address metaTransactionContract, address admin) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    function balanceOf(address owner) public override view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    function ownerOf(uint256 id) public override view returns (address owner) {\n        // TODO: does not return owner\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(\n        address owner,\n        address operator,\n        uint256 id\n    ) internal {\n        if (operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    function approve(address operator, uint256 id) public override {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == msg.sender || _superOperators[msg.sender] || _operatorsForAll[owner][msg.sender], \"not authorized to approve\");\n        _approveFor(owner, operator, id);\n    }\n\n    function getApproved(uint256 id) public override view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || (operatorEnabled && _operators[id] == msg.sender),\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(ERC165ID, interfaceId);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"), \"erc721 transfer rejected by to\");\n        }\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data), \"ERC721: transfer rejected by to\");\n        }\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data\n    ) public {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from || metaTx || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\n            require(_checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data\n    ) public {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    function supportsInterface(bytes4 id) public override view returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public {\n        require(sender != address(0), \"Invalid sender address\");\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"not authorized to approve for all\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"super operator can't have their approvalForAll changed\");\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public override view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) public {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    function burn(uint256 id) public {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    function burnFrom(address from, uint256 id) public {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n                _metaTransactionContracts[msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        require(to != address(0), \"to is zero address\");\n        require(_owners[tokenId] == 0, \"Already minted\");\n        emit Transfer(address(0), to, tokenId);\n        _owners[tokenId] = uint256(to);\n        _numNFTPerAddress[to] += 1;\n    }\n}\n\n\ncontract MockLand is MockERC721 {\n    constructor(address metaTransactionContract, address admin) public MockERC721(metaTransactionContract, admin) {}\n\n    function name() external pure returns (string memory) {\n        return \"Mock LANDs\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"MOCKLAND\";\n    }\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC721TokenReceiver.sol": {
      "content": "/* This Source Code Form is subject to the terms of the Mozilla external\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.6.5;\n\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC721MandatoryTokenReceiver.sol": {
      "content": "pragma solidity 0.6.5;\n\n\n/// @dev Note: The ERC-165 identifier for this interface is 0x5e8bf644.\ninterface ERC721MandatoryTokenReceiver {\n    function onERC721BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x4b808c46\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4); // needs to return 0x150b7a02\n\n    // needs to implements EIP-165\n    // function supportsInterface(bytes4 interfaceId)\n    //     external\n    //     view\n    //     returns (bool);\n}\n"
    },
    "src/solc_0.6/BaseWithStorage/ERC721BaseToken.sol": {
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.6.5;\n\nimport \"../common/Libraries/AddressUtils.sol\";\nimport \"../common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../common/Interfaces/ERC721Events.sol\";\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\n\ncontract ERC721BaseToken is ERC721Events, SuperOperators, MetaTransactionReceiver {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping(address => uint256) internal _numNFTPerAddress;\n    mapping(uint256 => uint256) internal _owners;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    mapping(uint256 => address) internal _operators;\n\n    constructor(address metaTransactionContract, address admin) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n    function _ownerOf(uint256 id) internal virtual view returns (address) {\n        uint256 data = _owners[id];\n        if ((data & (2**160)) == 2**160) {\n            return address(0);\n        }\n        return address(data);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        if ((data & (2**160)) == 2**160) {\n            owner = address(0);\n        } else {\n            owner = address(data);\n        }\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return owner The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(\n        address owner,\n        address operator,\n        uint256 id\n    ) internal {\n        if (operator == address(0)) {\n            _owners[id] = _owners[id] & (2**255 - 1); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = _owners[id] | (2**255);\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == msg.sender || _superOperators[msg.sender] || _operatorsForAll[owner][msg.sender], \"not authorized to approve\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || (operatorEnabled && _operators[id] == msg.sender),\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(ERC165ID, interfaceId);\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"), \"erc721 transfer rejected by to\");\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data), \"ERC721: transfer rejected by to\");\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n     */\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data,\n        bool safe\n    ) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from || metaTx || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\n            require(_checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public virtual pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"not authorized to approve for all\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"super operator can't have their approvalForAll changed\");\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return isOperator The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) internal {\n        require(from == owner, \"not owner\");\n        _owners[id] = (_owners[id] & (2**255 - 1)) | (2**160); // record as non owner but keep track of last owner\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external virtual {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external virtual {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n                _metaTransactionContracts[msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory _data\n    ) internal returns (bool) {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n}\n"
    },
    "src/solc_0.6/LiquidityMining/LandWeightedSANDRewardPool.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"@openzeppelin/contracts-0.6/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"./IRewardDistributionRecipient.sol\";\nimport \"../common/Interfaces/ERC721.sol\";\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMathWithRequire for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n\n    IERC20 internal immutable _stakeToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    constructor(IERC20 stakeToken) public {\n        _stakeToken = stakeToken;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\n///@notice Reward Pool based on unipool contract : https://github.com/Synthetixio/Unipool/blob/master/contracts/Unipool.sol\n//with the addition of NFT multiplier reward\ncontract LandWeightedSANDRewardPool is LPTokenWrapper, IRewardDistributionRecipient {\n    using SafeMathWithRequire for uint256;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    uint256 public immutable duration;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 internal constant DECIMALS_9 = 1000000000;\n    uint256 internal constant MIDPOINT_9 = 500000000;\n    uint256 internal constant NFT_FACTOR_6 = 10000;\n    uint256 internal constant NFT_CONSTANT_3 = 9000;\n    uint256 internal constant ROOT3_FACTOR = 697;\n\n    IERC20 internal immutable _rewardToken;\n    ERC721 internal immutable _multiplierNFToken;\n\n    uint256 internal _totalContributions;\n    mapping(address => uint256) internal _contributions;\n\n    constructor(\n        IERC20 stakeToken,\n        IERC20 rewardToken,\n        ERC721 multiplierNFToken,\n        uint256 rewardDuration\n    ) public LPTokenWrapper(stakeToken) {\n        _rewardToken = rewardToken;\n        _multiplierNFToken = multiplierNFToken;\n        duration = rewardDuration;\n    }\n\n    function totalContributions() public view returns (uint256) {\n        return _totalContributions;\n    }\n\n    function contributionOf(address account) public view returns (uint256) {\n        return _contributions[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n\n        if (block.timestamp >= periodFinish || _totalContributions != 0) {\n            // ensure reward past the first staker do not get lost\n            lastUpdateTime = lastTimeRewardApplicable();\n        }\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalContributions() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e24).div(totalContributions())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            contributionOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e24).add(\n                rewards[account]\n            );\n    }\n\n    function computeContribution(uint256 amountStaked, uint256 numLands) public pure returns (uint256) {\n        if (numLands == 0) {\n            return amountStaked;\n        }\n        uint256 nftContrib = NFT_FACTOR_6.mul(NFT_CONSTANT_3.add(numLands.sub(1).mul(ROOT3_FACTOR).add(1).cbrt3()));\n        if (nftContrib > MIDPOINT_9) {\n            nftContrib = MIDPOINT_9.add(nftContrib.sub(MIDPOINT_9).div(10));\n        }\n        return amountStaked.add(amountStaked.mul(nftContrib).div(DECIMALS_9));\n    }\n\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        uint256 contribution = computeContribution(amount, _multiplierNFToken.balanceOf(msg.sender));\n        _totalContributions = _totalContributions.add(contribution);\n        _contributions[msg.sender] = _contributions[msg.sender].add(contribution);\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        uint256 balance = balanceOf(msg.sender);\n        uint256 ratio = amount.mul(DECIMALS_18).div(balance);\n        uint256 currentContribution = contributionOf(msg.sender);\n        uint256 contributionReduction = currentContribution.mul(ratio).div(DECIMALS_18);\n        _contributions[msg.sender] = currentContribution.sub(contributionReduction);\n        _totalContributions = _totalContributions.sub(contributionReduction);\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            _rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    ///@notice to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract\n    // Note that the reward should be divisible by the duration to avoid reward token lost\n    ///@param reward number of token to be distributed over the duration\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/solc_0.6/LiquidityMining/IRewardDistributionRecipient.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    address public rewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(_msgSender() == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution) external onlyOwner {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-0.6/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-0.6/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/solc_0.6/test/LandWeightedSANDRewardPoolNFTTest.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"../LiquidityMining/LandWeightedSANDRewardPool.sol\";\n\n\ncontract LandWeightedSANDRewardPoolNFTTest is LandWeightedSANDRewardPool {\n    constructor(\n        address stakeTokenContract,\n        address rewardTokenContract,\n        address nftContract,\n        uint256 rewardDuration\n    ) public LandWeightedSANDRewardPool(IERC20(stakeTokenContract), IERC20(rewardTokenContract), ERC721(nftContract), rewardDuration) {}\n}\n"
    },
    "src/solc_0.6/LiquidityMining/Rinkeby/RinkebySANDRewardPool.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"@openzeppelin/contracts-0.6/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"../IRewardDistributionRecipient.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public _uniTest; // deploy a Rinkeby Uniswap SAND-ETH pair\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _uniTest.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _uniTest.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract RinkebySANDRewardPool is LPTokenWrapper, IRewardDistributionRecipient {\n    constructor(address uniTest) public {\n        _uniTest = IERC20(uniTest); // constructor for Rinkeby UniswapPair address\n    }\n\n    IERC20 public sand = IERC20(0xCc933a862fc15379E441F2A16Cb943D385a4695f); // Reward token: Rinkeby SAND\n    uint256 public constant DURATION = 30 days; // Reward period\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "src/solc_0.6/LiquidityMining/Mainnet/SANDRewardPool.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"@openzeppelin/contracts-0.6/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"../IRewardDistributionRecipient.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public uni = IERC20(0x3dd49f67E9d5Bc4C5E6634b3F70BfD9dc1b6BD74); // lpToken contract address, currently set to the SAND-ETH pool contract address\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        uni.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        uni.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract SANDRewardPool is LPTokenWrapper, IRewardDistributionRecipient {\n    IERC20 public sand = IERC20(0x3845badAde8e6dFF049820680d1F14bD3903a5d0); // Reward token: SAND\n    uint256 public constant DURATION = 30 days; // Reward period\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "src/solc_0.6/LiquidityMining/Goerli/GoerliSANDRewardPool.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"@openzeppelin/contracts-0.6/math/Math.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"../IRewardDistributionRecipient.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public _uniTest; // deploy a Goerli Uniswap SAND-ETH pair\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _uniTest.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _uniTest.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract GoerliSANDRewardPool is LPTokenWrapper, IRewardDistributionRecipient {\n    constructor(address uniTest) public {\n        _uniTest = IERC20(uniTest); // constructor for Goerli UniswapPair address\n    }\n\n    IERC20 public sand = IERC20(0x200814fe1B8F947084D810C099176685496e5d14); // Reward token: Goerli SAND\n    uint256 public constant DURATION = 1 hours; // Reward period\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "src/solc_0.6/FeeDistributor/FeeTimeVault.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\nimport \"./FeeDistributor.sol\";\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/Ownable.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/// @title Fee Time Vault\n/// @notice Holds tokens collected from fees in a locked state for a certain period of time\ncontract FeeTimeVault is Ownable {\n    using SafeERC20 for IERC20;\n    mapping(uint256 => uint256) public accumulatedAmountPerDay;\n    FeeDistributor public feeDistributor;\n\n    /// @notice Updates the total amount of fees collected alongside with the due date\n    function sync() external returns (uint256) {\n        uint256 timestamp = now;\n        uint256 day = ((timestamp - _startTime) / 1 days);\n        uint256 amount = feeDistributor.withdraw(_sandToken, address(this));\n        accumulatedAmountPerDay[day] = accumulatedAmountPerDay[_lastDaySaved].add(amount);\n        _lastDaySaved = day;\n        return amount;\n    }\n\n    /// @notice Enables fee holder to withdraw its share after lock period expired\n    /// @param beneficiary the address that will receive fees\n    function withdraw(address payable beneficiary) external onlyOwner returns (uint256) {\n        uint256 day = ((now - _startTime) / 1 days);\n        uint256 lockPeriod = _lockPeriod;\n        uint256 amount = lockPeriod > day ? 0 : accumulatedAmountPerDay[day - lockPeriod];\n        if (amount != 0) {\n            uint256 withdrawnAmount = _withdrawnAmount;\n            amount = amount.sub(withdrawnAmount);\n            _withdrawnAmount = withdrawnAmount.add(amount);\n            _sandToken.safeTransfer(beneficiary, amount);\n        }\n        return amount;\n    }\n\n    /// @notice Enables fee holder to withdraw token fees with no time-lock for tokens other than SAND\n    /// @param token the token that fees are collected in\n    /// @param beneficiary the address that will receive fees\n    function withdrawNoTimeLock(IERC20 token, address payable beneficiary) external onlyOwner returns (uint256) {\n        require(token != _sandToken, \"SAND_TOKEN_WITHDRWAL_NOT_ALLOWED\");\n        uint256 amount = feeDistributor.withdraw(token, beneficiary);\n        return amount;\n    }\n\n    function setFeeDistributor(FeeDistributor _feeDistributor) external onlyOwner {\n        require(address(feeDistributor) == address(0), \"FEE_DISTRIBUTOR_ALREADY_SET\");\n        require(address(_feeDistributor) != address(0), \"FEE_DISTRIBUTOR_ZERO_ADDRESS\");\n        feeDistributor = _feeDistributor;\n    }\n\n    receive() external payable {}\n\n    // /////////////////// UTILITIES /////////////////////\n    using SafeMathWithRequire for uint256;\n    // //////////////////////// DATA /////////////////////\n\n    uint256 private _lockPeriod;\n    IERC20 private _sandToken;\n    uint256 private _lastDaySaved;\n    uint256 private _withdrawnAmount;\n    uint256 private _startTime;\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n    /// @param lockPeriod lockPeriod measured in days, e.g. lockPeriod = 10 => 10 days\n    /// @param token sand token contract address\n    /// @param owner the account that can make a withdrawal\n    constructor(\n        uint256 lockPeriod,\n        IERC20 token,\n        address payable owner\n    ) public Ownable(owner) {\n        _lockPeriod = lockPeriod;\n        _sandToken = token;\n        _startTime = now;\n    }\n}\n"
    },
    "src/solc_0.6/FeeDistributor/FeeDistributor.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/// @title Fee distributor\n/// @notice Distributes all fees collected from platform activities to stakeholders\ncontract FeeDistributor {\n    using SafeERC20 for IERC20;\n    event Deposit(address token, address from, uint256 amount);\n    event Withdrawal(IERC20 token, address to, uint256 amount);\n    mapping(address => uint256) public recipientsShares;\n\n    /// @notice Enables fee holder to withdraw its share\n    /// @notice Zero address reserved for ether withdrawal\n    /// @param token the token that fee should be distributed in\n    /// @param beneficiary the address that will receive fees\n    /// @return amount had withdrawn\n    function withdraw(IERC20 token, address payable beneficiary) external returns (uint256 amount) {\n        if (address(token) == address(0)) {\n            amount = _etherWithdrawal(beneficiary);\n        } else {\n            amount = _tokenWithdrawal(token, beneficiary);\n        }\n        if (amount != 0) {\n            emit Withdrawal(token, msg.sender, amount);\n        }\n    }\n\n    receive() external payable {\n        emit Deposit(address(0), msg.sender, msg.value);\n    }\n\n    // //////////////////// INTERNALS ////////////////////\n    function _etherWithdrawal(address payable beneficiary) private returns (uint256) {\n        uint256 amount = _calculateWithdrawalAmount(address(this).balance, address(0));\n        if (amount > 0) {\n            beneficiary.transfer(amount);\n        }\n        return amount;\n    }\n\n    function _tokenWithdrawal(IERC20 token, address payable beneficiary) private returns (uint256) {\n        uint256 amount = _calculateWithdrawalAmount(token.balanceOf(address(this)), address(token));\n        if (amount > 0) {\n            token.safeTransfer(beneficiary, amount);\n        }\n        return amount;\n    }\n\n    function _calculateWithdrawalAmount(uint256 currentBalance, address token) private returns (uint256) {\n        uint256 totalReceived = _tokensState[token].totalReceived;\n        uint256 lastBalance = _tokensState[token].lastBalance;\n        uint256 amountAlreadyGiven = _tokensState[token].amountAlreadyGiven[msg.sender];\n        uint256 _currentBalance = currentBalance;\n        totalReceived = totalReceived.add(_currentBalance.sub(lastBalance));\n        _tokensState[token].totalReceived = totalReceived;\n        uint256 amountDue = ((totalReceived.mul(recipientsShares[msg.sender])).div(10**DECIMALS)).sub(\n            amountAlreadyGiven\n        );\n        if (amountDue == 0) {\n            return amountDue;\n        }\n        amountAlreadyGiven = amountAlreadyGiven.add(amountDue);\n        _tokensState[token].amountAlreadyGiven[msg.sender] = amountAlreadyGiven;\n        _tokensState[token].lastBalance = _currentBalance.sub(amountDue);\n        return amountDue;\n    }\n\n    // /////////////////// UTILITIES /////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////////// DATA /////////////////////\n    struct TokenState {\n        uint256 totalReceived;\n        mapping(address => uint256) amountAlreadyGiven;\n        uint256 lastBalance;\n    }\n    mapping(address => TokenState) private _tokensState;\n    uint256 private constant DECIMALS = 4;\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n    /// @notice Assign each recipient with its corresponding share.\n    /// @notice Percentages are 4 decimal points, e.g. 1 % = 100\n    /// @param recipients fee recipients\n    /// @param shares the corresponding share (from total fees held by the contract) for a recipient\n    constructor(address payable[] memory recipients, uint256[] memory shares) public {\n        require(recipients.length == shares.length, \"ARRAYS_LENGTHS_SHOULD_BE_EQUAL\");\n        uint256 totalPercentage = 0;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipientsShares[recipients[i]] == 0, \"NO_DUPLICATE_ADDRESSES\");\n            uint256 share = shares[i];\n            recipientsShares[recipients[i]] = share;\n            totalPercentage = totalPercentage.add(share);\n        }\n        require(totalPercentage == 10**DECIMALS, \"PERCENTAGES_ARRAY_SHOULD_SUM_TO_100%\");\n    }\n}\n"
    },
    "src/solc_0.6/CatalystMinter.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./Interfaces/AssetToken.sol\";\nimport \"./common/Interfaces/ERC20.sol\";\nimport \"./Interfaces/ERC20Extended.sol\";\nimport \"./common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"./common/Libraries/SafeMathWithRequire.sol\";\nimport \"./Catalyst/GemToken.sol\";\nimport \"./Catalyst/CatalystToken.sol\";\nimport \"./CatalystRegistry.sol\";\nimport \"./BaseWithStorage/ERC20Group.sol\";\n\n\n/// @notice Gateway to mint Asset with Catalyst, Gems and Sand\ncontract CatalystMinter is MetaTransactionReceiver {\n    /// @dev emitted when fee collector (that receive the sand fee) get changed\n    /// @param newCollector address of the new collector, address(0) means the fee will be burned\n    event FeeCollector(address newCollector);\n\n    function setFeeCollector(address newCollector) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setFeeCollector(newCollector);\n    }\n\n    event GemAdditionFee(uint256 newFee);\n\n    function setGemAdditionFee(uint256 newFee) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setGemAdditionFee(newFee);\n    }\n\n    /// @notice mint one Asset token.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param catalystId address of the Catalyst ERC20 token to burn.\n    /// @param gemIds list of gem ids to burn in the catalyst.\n    /// @param quantity asset supply to mint\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    function mint(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        uint256 quantity,\n        address to,\n        bytes calldata data\n    ) external returns (uint256) {\n        _checkAuthorization(from, to);\n        _burnCatalyst(from, catalystId);\n        uint16 maxGems = _checkQuantityAndBurnSandAndGems(from, catalystId, gemIds, quantity);\n        uint256 id = _asset.mint(from, packId, metadataHash, quantity, 0, to, data);\n        _catalystRegistry.setCatalyst(id, catalystId, maxGems, gemIds);\n        return id;\n    }\n\n    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function extractAndChangeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _changeCatalyst(from, tokenId, catalystId, gemIds, to);\n    }\n\n    /// @notice associate a new catalyst to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being updated.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the Asset token.\n    function changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        _changeCatalyst(from, assetId, catalystId, gemIds, to);\n        return assetId;\n    }\n\n    /// @notice add gems to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function extractAndAddGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _addGems(from, tokenId, gemIds, to);\n    }\n\n    /// @notice add gems to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset to which the gems will be added to.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    function addGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external {\n        _checkAuthorization(from, to);\n        _addGems(from, assetId, gemIds, to);\n    }\n\n    struct AssetData {\n        uint256[] gemIds;\n        uint256 quantity;\n        uint256 catalystId;\n    }\n\n    /// @notice mint multiple Asset tokens.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param gemsQuantities quantities of gems to be used for each id in order\n    /// @param catalystsQuantities quantities of catalyst to be used for each id in order\n    /// @param assets contains the data to associate catalyst and gems to the assets.\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    function mintMultiple(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets,\n        address to,\n        bytes memory data\n    ) public returns (uint256[] memory ids) {\n        require(assets.length != 0, \"INVALID_0_ASSETS\");\n        _checkAuthorization(from, to);\n        return _mintMultiple(from, packId, metadataHash, gemsQuantities, catalystsQuantities, assets, to, data);\n    }\n\n    // //////////////////// INTERNALS ////////////////////\n\n    function _checkQuantityAndBurnSandAndGems(\n        address from,\n        uint256 catalystId,\n        uint256[] memory gemIds,\n        uint256 quantity\n    ) internal returns (uint16) {\n        (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(catalystId);\n        require(minQuantity <= quantity && quantity <= maxQuantity, \"INVALID_QUANTITY\");\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        _burnSingleGems(from, gemIds);\n        _chargeSand(from, quantity.mul(sandMintingFee));\n        return maxGems;\n    }\n\n    function _mintMultiple(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets,\n        address to,\n        bytes memory data\n    ) internal returns (uint256[] memory) {\n        (uint256 totalSandFee, uint256[] memory supplies, uint16[] memory maxGemsList) = _handleMultipleCatalysts(\n            from,\n            gemsQuantities,\n            catalystsQuantities,\n            assets\n        );\n\n        _chargeSand(from, totalSandFee);\n\n        return _mintAssets(from, packId, metadataHash, assets, supplies, maxGemsList, to, data);\n    }\n\n    function _chargeSand(address from, uint256 sandFee) internal {\n        address feeCollector = _feeCollector;\n        if (feeCollector != address(0) && sandFee != 0) {\n            if (feeCollector == address(BURN_ADDRESS)) {\n                // special address for burn\n                _sand.burnFor(from, sandFee);\n            } else {\n                _sand.transferFrom(from, _feeCollector, sandFee);\n            }\n        }\n    }\n\n    function _extractMintData(uint256 data)\n        internal\n        pure\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        )\n    {\n        maxGems = uint16(data >> 240);\n        minQuantity = uint16((data >> 224) % 2**16);\n        maxQuantity = uint16((data >> 208) % 2**16);\n        sandMintingFee = uint256((data >> 120) % 2**88);\n        sandUpdateFee = uint256(data % 2**88);\n    }\n\n    function _getMintData(uint256 catalystId)\n        internal\n        view\n        returns (\n            uint16,\n            uint16,\n            uint16,\n            uint256,\n            uint256\n        )\n    {\n        if (catalystId == 0) {\n            return _extractMintData(_common_mint_data);\n        } else if (catalystId == 1) {\n            return _extractMintData(_rare_mint_data);\n        } else if (catalystId == 2) {\n            return _extractMintData(_epic_mint_data);\n        } else if (catalystId == 3) {\n            return _extractMintData(_legendary_mint_data);\n        }\n        return _catalysts.getMintData(catalystId);\n    }\n\n    function _handleMultipleCatalysts(\n        address from,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets\n    )\n        internal\n        returns (\n            uint256 totalSandFee,\n            uint256[] memory supplies,\n            uint16[] memory maxGemsList\n        )\n    {\n        _burnCatalysts(from, catalystsQuantities);\n        _burnGems(from, gemsQuantities);\n\n        supplies = new uint256[](assets.length);\n        maxGemsList = new uint16[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(catalystsQuantities[assets[i].catalystId] != 0, \"INVALID_CATALYST_NOT_ENOUGH\");\n            catalystsQuantities[assets[i].catalystId]--;\n            gemsQuantities = _checkGemsQuantities(gemsQuantities, assets[i].gemIds);\n            (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(assets[i].catalystId);\n            require(minQuantity <= assets[i].quantity && assets[i].quantity <= maxQuantity, \"INVALID_QUANTITY\");\n            require(assets[i].gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n            maxGemsList[i] = maxGems;\n            supplies[i] = assets[i].quantity;\n            totalSandFee = totalSandFee.add(sandMintingFee.mul(assets[i].quantity));\n        }\n    }\n\n    function _checkGemsQuantities(uint256[] memory gemsQuantities, uint256[] memory gemIds) internal pure returns (uint256[] memory) {\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            require(gemsQuantities[gemIds[i]] != 0, \"INVALID_GEMS_NOT_ENOUGH\");\n            gemsQuantities[gemIds[i]]--;\n        }\n        return gemsQuantities;\n    }\n\n    function _burnCatalysts(address from, uint256[] memory catalystsQuantities) internal {\n        uint256[] memory ids = new uint256[](catalystsQuantities.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            ids[i] = i;\n        }\n        _catalysts.batchBurnFrom(from, ids, catalystsQuantities);\n    }\n\n    function _burnGems(address from, uint256[] memory gemsQuantities) internal {\n        uint256[] memory ids = new uint256[](gemsQuantities.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            ids[i] = i;\n        }\n        _gems.batchBurnFrom(from, ids, gemsQuantities);\n    }\n\n    function _mintAssets(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        AssetData[] memory assets,\n        uint256[] memory supplies,\n        uint16[] memory maxGemsList,\n        address to,\n        bytes memory data\n    ) internal returns (uint256[] memory tokenIds) {\n        tokenIds = _asset.mintMultiple(from, packId, metadataHash, supplies, \"\", to, data);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _catalystRegistry.setCatalyst(tokenIds[i], assets[i].catalystId, maxGemsList[i], assets[i].gemIds);\n        }\n    }\n\n    function _changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _burnCatalyst(from, catalystId);\n        (uint16 maxGems, , , , uint256 sandUpdateFee) = _getMintData(catalystId);\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        _burnGems(from, gemIds);\n        _chargeSand(from, sandUpdateFee);\n\n        _catalystRegistry.setCatalyst(assetId, catalystId, maxGems, gemIds);\n\n        _transfer(from, to, assetId);\n    }\n\n    function _addGems(\n        address from,\n        uint256 assetId,\n        uint256[] memory gemIds,\n        address to\n    ) internal {\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\n        _catalystRegistry.addGems(assetId, gemIds);\n        _chargeSand(from, gemIds.length.mul(_gemAdditionFee));\n        _transfer(from, to, assetId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 assetId\n    ) internal {\n        if (from != to) {\n            _asset.safeTransferFrom(from, to, assetId);\n        }\n    }\n\n    function _checkAuthorization(address from, address to) internal view {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(from == msg.sender || _metaTransactionContracts[msg.sender], \"NOT_SENDER\");\n    }\n\n    function _burnSingleGems(address from, uint256[] memory gemIds) internal {\n        uint256[] memory amounts = new uint256[](gemIds.length);\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            amounts[i] = 1;\n        }\n        _gems.batchBurnFrom(from, gemIds, amounts);\n    }\n\n    function _burnCatalyst(address from, uint256 catalystId) internal {\n        _catalysts.burnFrom(from, catalystId, 1);\n    }\n\n    function _setFeeCollector(address newCollector) internal {\n        _feeCollector = newCollector;\n        emit FeeCollector(newCollector);\n    }\n\n    function _setGemAdditionFee(uint256 newFee) internal {\n        _gemAdditionFee = newFee;\n        emit GemAdditionFee(newFee);\n    }\n\n    // /////////////////// UTILITIES /////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////////// DATA /////////////////////\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    address private constant BURN_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n\n    ERC20Extended internal immutable _sand;\n    AssetToken internal immutable _asset;\n    GemToken internal immutable _gems;\n    CatalystToken internal immutable _catalysts;\n    CatalystRegistry internal immutable _catalystRegistry;\n    address internal _feeCollector;\n\n    uint256 internal immutable _common_mint_data;\n    uint256 internal immutable _rare_mint_data;\n    uint256 internal immutable _epic_mint_data;\n    uint256 internal immutable _legendary_mint_data;\n\n    uint256 internal _gemAdditionFee;\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n    constructor(\n        CatalystRegistry catalystRegistry,\n        ERC20Extended sand,\n        AssetToken asset,\n        GemToken gems,\n        address metaTx,\n        address admin,\n        address feeCollector,\n        uint256 gemAdditionFee,\n        CatalystToken catalysts,\n        uint256[4] memory bakedInMintdata\n    ) public {\n        _catalystRegistry = catalystRegistry;\n        _sand = sand;\n        _asset = asset;\n        _gems = gems;\n        _catalysts = catalysts;\n        _admin = admin;\n        _setGemAdditionFee(gemAdditionFee);\n        _setFeeCollector(feeCollector);\n        _setMetaTransactionProcessor(metaTx, true);\n        _common_mint_data = bakedInMintdata[0];\n        _rare_mint_data = bakedInMintdata[1];\n        _epic_mint_data = bakedInMintdata[2];\n        _legendary_mint_data = bakedInMintdata[3];\n    }\n}\n"
    },
    "src/solc_0.6/Interfaces/AssetToken.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ninterface AssetToken {\n    function mint(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256 supply,\n        uint8 rarity,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256 id);\n\n    function mintMultiple(\n        address creator,\n        uint40 packId,\n        bytes32 hash,\n        uint256[] calldata supplies,\n        bytes calldata rarityPack,\n        address owner,\n        bytes calldata data\n    ) external returns (uint256[] memory ids);\n\n    // fails on non-NFT or nft who do not have collection (was a mistake)\n    function collectionOf(uint256 id) external view returns (uint256);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    // return true for Non-NFT ERC1155 tokens which exists\n    function isCollection(uint256 id) external view returns (bool);\n\n    function collectionIndexOf(uint256 id) external view returns (uint256);\n\n    function extractERC721From(\n        address sender,\n        uint256 id,\n        address to\n    ) external returns (uint256 newId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/solc_0.6/Interfaces/ERC20Extended.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"../common/Interfaces/ERC20.sol\";\n\n\ninterface ERC20Extended is ERC20 {\n    function burnFor(address from, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool success);\n}\n"
    },
    "src/solc_0.6/Catalyst/GemToken.sol": {
      "content": "pragma solidity 0.6.5;\n\n\ninterface GemToken {\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external;\n}\n"
    },
    "src/solc_0.6/Catalyst/CatalystToken.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface CatalystToken {\n    function getMintData(uint256 catalystId)\n        external\n        view\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        );\n\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external;\n\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/solc_0.6/CatalystRegistry.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./Interfaces/AssetToken.sol\";\nimport \"./common/BaseWithStorage/Admin.sol\";\nimport \"./Catalyst/CatalystValue.sol\";\n\n\ncontract CatalystRegistry is Admin, CatalystValue {\n    event Minter(address indexed newMinter);\n    event CatalystApplied(uint256 indexed assetId, uint256 indexed catalystId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\n    event GemsAdded(uint256 indexed assetId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\n\n    function getCatalyst(uint256 assetId) external view returns (bool exists, uint256 catalystId) {\n        CatalystStored memory catalyst = _catalysts[assetId];\n        if (catalyst.set != 0) {\n            return (true, catalyst.catalystId);\n        }\n        if (assetId & IS_NFT != 0) {\n            catalyst = _catalysts[_getCollectionId(assetId)];\n            return (catalyst.set != 0, catalyst.catalystId);\n        }\n        return (false, 0);\n    }\n\n    function setCatalyst(\n        uint256 assetId,\n        uint256 catalystId,\n        uint256 maxGems,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        uint256 emptySockets = maxGems - gemIds.length;\n        _catalysts[assetId] = CatalystStored(uint64(emptySockets), uint64(catalystId), 1);\n        uint64 blockNumber = _getBlockNumber();\n        emit CatalystApplied(assetId, catalystId, assetId, gemIds, blockNumber);\n    }\n\n    function addGems(uint256 assetId, uint256[] calldata gemIds) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\");\n        require(gemIds.length != 0, \"INVALID_GEMS_0\");\n        (uint256 emptySockets, uint256 seed) = _getSocketData(assetId);\n        require(emptySockets >= gemIds.length, \"INVALID_GEMS_TOO_MANY\");\n        emptySockets -= gemIds.length;\n        _catalysts[assetId].emptySockets = uint64(emptySockets);\n        uint64 blockNumber = _getBlockNumber();\n        emit GemsAdded(assetId, seed, gemIds, blockNumber);\n    }\n\n    /// @dev Set the Minter that will be the only address able to create Estate\n    /// @param minter address of the minter\n    function setMinter(address minter) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(minter != _minter, \"INVALID_MINTER_SAME_ALREADY_SET\");\n        _minter = minter;\n        emit Minter(minter);\n    }\n\n    /// @dev return the current minter\n    function getMinter() external view returns (address) {\n        return _minter;\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        return _catalystValue.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n    }\n\n    // ///////// INTERNAL ////////////\n\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\n    uint256 private constant NOT_IS_NFT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 private constant NOT_NFT_INDEX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF800000007FFFFFFFFFFFFFFF;\n\n    function _getSocketData(uint256 assetId) internal view returns (uint256 emptySockets, uint256 seed) {\n        seed = assetId;\n        CatalystStored memory catalyst = _catalysts[assetId];\n        if (catalyst.set != 0) {\n            // the gems are added to an asset who already get a specific catalyst.\n            // the seed is its id\n            return (catalyst.emptySockets, seed);\n        }\n        // else the asset is only adding gems while keeping the same seed (that of the original assetId)\n        seed = _getCollectionId(assetId);\n        catalyst = _catalysts[seed];\n        return (catalyst.emptySockets, seed);\n    }\n\n    function _getBlockNumber() internal view returns (uint64 blockNumber) {\n        blockNumber = uint64(block.number + 1);\n    }\n\n    function _getCollectionId(uint256 assetId) internal pure returns (uint256) {\n        return assetId & NOT_NFT_INDEX & NOT_IS_NFT; // compute the same as Asset to get collectionId\n    }\n\n    // CONSTRUCTOR ////\n    constructor(CatalystValue catalystValue, address admin) public {\n        _admin = admin;\n        _catalystValue = catalystValue;\n    }\n\n    /// DATA ////////\n\n    struct CatalystStored {\n        uint64 emptySockets;\n        uint64 catalystId;\n        uint64 set;\n    }\n    address internal _minter;\n    CatalystValue internal immutable _catalystValue;\n    mapping(uint256 => CatalystStored) internal _catalysts;\n}\n"
    },
    "src/solc_0.6/test/MockSandPredicate.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.6.5;\nimport \"../Interfaces/ERC20Extended.sol\";\n\ncontract MockSandPredicate {\n    event LockedERC20(\n        address indexed depositor,\n        address indexed depositReceiver,\n        address indexed rootToken,\n        uint256 amount\n    );\n\n    function lockTokens(\n        address depositor,\n        address depositReceiver,\n        address rootToken,\n        bytes calldata depositData\n    ) external {\n        uint256 amount = abi.decode(depositData, (uint256));\n        emit LockedERC20(depositor, depositReceiver, rootToken, amount);\n        ERC20Extended(rootToken).transferFrom(depositor, address(this), amount);\n    }\n}\n"
    },
    "src/solc_0.6/test/MockRootChainManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity 0.6.5;\nimport \"./MockSandPredicate.sol\";\n\ncontract MockRootChainManager {\n    address internal immutable _predicateAddress;\n\n    constructor(address predicateAddress) public {\n        _predicateAddress = predicateAddress;\n    }\n\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external {\n        MockSandPredicate(_predicateAddress).lockTokens(msg.sender, user, rootToken, depositData);\n    }\n}\n"
    },
    "src/solc_0.6/EstateSale/EstateSaleWithAuth.sol": {
      "content": "/* solhint-disable not-rely-on-time, func-order */\npragma solidity 0.6.5;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"./LandToken.sol\";\nimport \"../common/Interfaces/ERC1155.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../ReferralValidator/ReferralValidator.sol\";\nimport \"./AuthValidator.sol\";\n\n/// @title Estate Sale contract with referral\n/// @notice This contract manages the sale of our lands as Estates\ncontract EstateSaleWithAuth is MetaTransactionReceiver, ReferralValidator {\n    using SafeMathWithRequire for uint256;\n\n    event LandQuadPurchased(\n        address indexed buyer,\n        address indexed to,\n        uint256 indexed topCornerId,\n        uint256 size,\n        uint256 price,\n        address token,\n        uint256 amountPaid\n    );\n\n    /// @notice set the wallet receiving the proceeds\n    /// @param newWallet address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }\n\n    /// @notice buy Land with SAND using the merkle proof associated with it\n    /// @param buyer address that perform the payment\n    /// @param to address that will own the purchased Land\n    /// @param reserved the reserved address (if any)\n    /// @param info [X_INDEX=0] x coordinate of the Land [Y_INDEX=1] y coordinate of the Land [SIZE_INDEX=2] size of the pack of Land to purchase [PRICE_INDEX=3] price in SAND to purchase that Land\n    /// @param proof merkleProof for that particular Land\n    function buyLandWithSand(\n        address buyer,\n        address to,\n        address reserved,\n        uint256[] calldata info,\n        bytes32 salt,\n        uint256[] calldata assetIds,\n        bytes32[] calldata proof,\n        bytes calldata referral,\n        bytes calldata signature\n    ) external {\n        _checkAddressesAndExpiryTime(buyer, reserved);\n        _checkAuthAndProofValidity(to, reserved, info, salt, assetIds, proof, signature);\n        _handleFeeAndReferral(buyer, info[PRICE_INDEX], referral);\n        _mint(buyer, to, info);\n        _sendAssets(to, assetIds);\n    }\n\n    /// @notice Gets the expiry time for the current sale\n    /// @return The expiry time, as a unix epoch\n    function getExpiryTime() external view returns (uint256) {\n        return _expiryTime;\n    }\n\n    /// @notice Gets the Merkle root associated with the current sale\n    /// @return The Merkle root, as a bytes32 hash\n    function getMerkleRoot() external view returns (bytes32) {\n        return _merkleRoot;\n    }\n\n    /// @notice enable Admin to withdraw remaining assets from EstateSaleWithFee contract\n    /// @param to intended recipient of the asset tokens\n    /// @param assetIds the assetIds to be transferred\n    /// @param values the quantities of the assetIds to be transferred\n    function withdrawAssets(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata values\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        // require(block.timestamp > _expiryTime, \"SALE_NOT_OVER\"); // removed to recover in case of misconfigured sales\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n    }\n\n    function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xbc197c81;\n    }\n\n    function _sendAssets(address to, uint256[] memory assetIds) internal {\n        uint256[] memory values = new uint256[](assetIds.length);\n        for (uint256 i = 0; i < assetIds.length; i++) {\n            values[i] = 1;\n        }\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n    }\n\n    // NOTE: _checkAddressesAndExpiryTime & _checkAuthAndProofValidity were split due to a stack too deep issue\n    function _checkAddressesAndExpiryTime(address buyer, address reserved) internal view {\n        /* solium-disable-next-line security/no-block-members */\n        require(block.timestamp < _expiryTime, \"SALE_IS_OVER\");\n        require(buyer == msg.sender || _metaTransactionContracts[msg.sender], \"NOT_AUTHORIZED\");\n        require(reserved == address(0) || reserved == buyer, \"RESERVED_LAND\");\n    }\n\n    // NOTE: _checkAddressesAndExpiryTime & _checkAuthAndProofValidity were split due to a stack too deep issue\n    function _checkAuthAndProofValidity(\n        address to,\n        address reserved,\n        uint256[] memory info,\n        bytes32 salt,\n        uint256[] memory assetIds,\n        bytes32[] memory proof,\n        bytes memory signature\n    ) internal view {\n        bytes32 hashedData = keccak256(\n            abi.encodePacked(\n                to,\n                reserved,\n                info[X_INDEX],\n                info[Y_INDEX],\n                info[SIZE_INDEX],\n                info[PRICE_INDEX],\n                salt,\n                assetIds,\n                proof\n            )\n        );\n        require(_authValidator.isAuthValid(signature, hashedData), \"INVALID_AUTH\");\n\n        bytes32 leaf = _generateLandHash(\n            info[X_INDEX],\n            info[Y_INDEX],\n            info[SIZE_INDEX],\n            info[PRICE_INDEX],\n            reserved,\n            salt,\n            assetIds\n        );\n        require(_verify(proof, leaf), \"INVALID_LAND\");\n    }\n\n    function _mint(\n        address buyer,\n        address to,\n        uint256[] memory info\n    ) internal {\n        if (info[SIZE_INDEX] == 1 || _estate == address(0)) {\n            _land.mintQuad(to, info[SIZE_INDEX], info[X_INDEX], info[Y_INDEX], \"\");\n        } else {\n            _land.mintQuad(_estate, info[SIZE_INDEX], info[X_INDEX], info[Y_INDEX], abi.encode(to));\n        }\n        emit LandQuadPurchased(\n            buyer,\n            to,\n            info[X_INDEX] + (info[Y_INDEX] * GRID_SIZE),\n            info[SIZE_INDEX],\n            info[PRICE_INDEX],\n            address(_sand),\n            info[PRICE_INDEX]\n        );\n    }\n\n    function _generateLandHash(\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 price,\n        address reserved,\n        bytes32 salt,\n        uint256[] memory assetIds\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(x, y, size, price, reserved, salt, assetIds));\n    }\n\n    function _verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        return computedHash == _merkleRoot;\n    }\n\n    function _handleFeeAndReferral(\n        address buyer,\n        uint256 priceInSand,\n        bytes memory referral\n    ) internal {\n        // send 5% fee to a specially configured instance of FeeDistributor.sol\n        uint256 remainingAmountInSand = _handleSandFee(buyer, priceInSand);\n\n        // calculate referral based on 95% of original priceInSand\n        handleReferralWithERC20(buyer, remainingAmountInSand, referral, _wallet, address(_sand));\n    }\n\n    function _handleSandFee(address buyer, uint256 priceInSand) internal returns (uint256) {\n        uint256 feeAmountInSand = priceInSand.mul(FEE).div(100);\n        require(_sand.transferFrom(buyer, address(_feeDistributor), feeAmountInSand), \"FEE_TRANSFER_FAILED\");\n        return priceInSand.sub(feeAmountInSand);\n    }\n\n    uint256 internal constant GRID_SIZE = 408; // 408 is the size of the Land\n\n    ERC1155 internal immutable _asset;\n    LandToken internal immutable _land;\n    ERC20 internal immutable _sand;\n    address internal immutable _estate;\n    address internal immutable _feeDistributor;\n\n    address payable internal _wallet;\n    AuthValidator internal _authValidator;\n    uint256 internal immutable _expiryTime;\n    bytes32 internal immutable _merkleRoot;\n\n    uint256 private constant FEE = 5; // percentage of land sale price to be diverted to a specially configured instance of FeeDistributor, shown as an integer\n    // buyLandWithSand info indexes\n    uint256 private constant X_INDEX = 0;\n    uint256 private constant Y_INDEX = 1;\n    uint256 private constant SIZE_INDEX = 2;\n    uint256 private constant PRICE_INDEX = 3;\n\n    constructor(\n        address landAddress,\n        address sandContractAddress,\n        address initialMetaTx,\n        address admin,\n        address payable initialWalletAddress,\n        bytes32 merkleRoot,\n        uint256 expiryTime,\n        address initialSigningWallet,\n        uint256 initialMaxCommissionRate,\n        address estate,\n        address asset,\n        address feeDistributor,\n        address authValidator\n    ) public ReferralValidator(initialSigningWallet, initialMaxCommissionRate) {\n        _land = LandToken(landAddress);\n        _sand = ERC20(sandContractAddress);\n        _setMetaTransactionProcessor(initialMetaTx, true);\n        _wallet = initialWalletAddress;\n        _merkleRoot = merkleRoot;\n        _expiryTime = expiryTime;\n        _admin = admin;\n        _estate = estate;\n        _asset = ERC1155(asset);\n        _feeDistributor = feeDistributor;\n        _authValidator = AuthValidator(authValidator);\n    }\n}\n"
    },
    "src/solc_0.6/EstateSale/AuthValidator.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.5; // TODO: update once upgrade is complete\n\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\n\ncontract AuthValidator is Admin {\n    address public _signingAuthWallet;\n\n    event SigningWallet(address indexed signingWallet);\n\n    constructor(address adminWallet, address initialSigningWallet) public {\n        _admin = adminWallet;\n        _updateSigningAuthWallet(initialSigningWallet);\n    }\n\n    function updateSigningAuthWallet(address newSigningWallet) external onlyAdmin {\n        _updateSigningAuthWallet(newSigningWallet);\n    }\n\n    function _updateSigningAuthWallet(address newSigningWallet) internal {\n        require(newSigningWallet != address(0), \"INVALID_SIGNING_WALLET\");\n        _signingAuthWallet = newSigningWallet;\n        emit SigningWallet(newSigningWallet);\n    }\n\n    function isAuthValid(bytes memory signature, bytes32 hashedData) public view returns (bool) {\n        address signer = SigUtil.recover(keccak256(SigUtil.prefixed(hashedData)), signature);\n        return signer == _signingAuthWallet;\n    }\n}\n"
    },
    "src/solc_0.6/common/Interfaces/ERC20WithMetadata.sol": {
      "content": "/* This Source Code Form is subject to the terms of the Mozilla external\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.6.5;\n\nimport \"./ERC20.sol\";\n\n\ninterface ERC20WithMetadata is ERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/solc_0.6/common/Libraries/ObjectLib64.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary ObjectLib64 {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 64; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n     * @dev Return the bin number and index within that bin where ID is\n     * @param _tokenId Object type\n     * @return bin Bin number\n     * @return index ID's index within that bin\n     */\n    function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\n        bin = (_tokenId * TYPES_BITS_SIZE) / 256;\n        index = _tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in _binBalances\n     * @param _binBalances Uint256 containing the balances of objects\n     * @param _index Index of the object in the provided bin\n     * @param _amount Value to update the type balance\n     * @param _operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with _amount\n     *     Operations.ADD     : ADD _amount to type balance\n     *     Operations.SUB     : Substract _amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 _binBalances,\n        uint256 _index,\n        uint256 _amount,\n        Operations _operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (_operation == Operations.ADD) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\n        } else if (_operation == Operations.SUB) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\n        } else if (_operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in _binValue at position _index\n     * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param _index index at which to retrieve value\n     * @return Value at given _index in _bin\n     */\n    function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated _binValue after writing _amount at _index\n     * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param _index Index at which to retrieve value\n     * @param _amount Value to store at _index in _bin\n     * @return Value at given _index in _bin\n     */\n    function writeValueInBin(\n        uint256 _binValue,\n        uint256 _index,\n        uint256 _amount\n    ) internal pure returns (uint256) {\n        require(_amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue & ~(mask << leftShift)) | (_amount << leftShift);\n    }\n}\n"
    },
    "src/solc_0.6/common/Libraries/ObjectLib.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary ObjectLib {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 16; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n     * @dev Return the bin number and index within that bin where ID is\n     * @param _tokenId Object type\n     * @return bin Bin number\n     * @return index ID's index within that bin\n     */\n    function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\n        bin = (_tokenId * TYPES_BITS_SIZE) / 256;\n        index = _tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in _binBalances\n     * @param _binBalances Uint256 containing the balances of objects\n     * @param _index Index of the object in the provided bin\n     * @param _amount Value to update the type balance\n     * @param _operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with _amount\n     *     Operations.ADD     : ADD _amount to type balance\n     *     Operations.SUB     : Substract _amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 _binBalances,\n        uint256 _index,\n        uint256 _amount,\n        Operations _operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (_operation == Operations.ADD) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\n        } else if (_operation == Operations.SUB) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\n        } else if (_operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in _binValue at position _index\n     * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param _index index at which to retrieve value\n     * @return Value at given _index in _bin\n     */\n    function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated _binValue after writing _amount at _index\n     * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param _index Index at which to retrieve value\n     * @param _amount Value to store at _index in _bin\n     * @return Value at given _index in _bin\n     */\n    function writeValueInBin(\n        uint256 _binValue,\n        uint256 _index,\n        uint256 _amount\n    ) internal pure returns (uint256) {\n        require(_amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue & ~(mask << leftShift)) | (_amount << leftShift);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}