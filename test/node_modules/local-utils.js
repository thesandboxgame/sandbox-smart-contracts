const {assert} = require("local-chai");
const {BigNumber} = require("@ethersproject/bignumber");
const {ethers} = require("@nomiclabs/buidler");
async function expectRevert(promise, expectedMessage) {
  if (typeof promise === 'undefined') {
    promise = expectedMessage;
    expectedMessage = null;
  }
  let receipt;
  try {
    receipt = await promise;
    if (receipt.wait) { // if tx.wait
      receipt = await receipt.wait();
    }
  } catch (error) {
    const isExpectedMessagePresent = !expectedMessage || error.message.search(expectedMessage) >= 0;
    if (!isExpectedMessagePresent) {
      throw new Error(`Revert message : "${expectedMessage}" not present, instead got : "${error.message}"`);
    }
    return true;
  }
  if (receipt.status === '0x0') {
    if (expectedMessage) {
      throw new Error(`Revert message not parsed : "${expectedMessage}"`);
    }
    return true;
  }
  if (receipt === undefined) {
    throw new Error("Receipt is undefined");
  }
  throw new Error(`Transaction did not revert : "${JSON.stringify(receipt)}"`);
}

let timeDelta = 0;
async function increaseTime(numSec) {
  await ethers.provider.send('evm_increaseTime', [numSec]);
  timeDelta += numSec;
}

function recurseTests(test) {
  if (test.subTests) {
    // eslint-disable-next-line mocha/no-setup-in-describe
    describe(test.title, function () {
      // eslint-disable-next-line mocha/no-setup-in-describe
      for (const subTest of test.subTests) {
        // eslint-disable-next-line mocha/no-setup-in-describe
        recurse(subTest);
      }
    });
  } else {
    it(test.title, test.test);
  }
}

async function checERC1155Balances(account, balances, func) {
  const intialBalances = [];
  for(const name of Object.keys(balances)) {
    intialBalances[name] = await balances[name][0].balanceOf(account, balances[name][1]);
  }
  const result = await func();
  for(const name of Object.keys(balances)) {
    const newBalance = await balances[name][0].balanceOf(account, balances[name][1]);
    const diff = balances[name][2];
    if (diff._isBigNumber) {
      diff = diff.toString();
    }
    assert.equal(newBalance.toString(), intialBalances[name].add(diff).toString(), `balance of ${name} not expected`)
  }
  return result;
}

async function checERC20Balances(account, balances, func) {
  const intialBalances = [];
  for(const name of Object.keys(balances)) {
    intialBalances[name] = await balances[name][0].balanceOf(account);
  }
  const result = await func();
  for(const name of Object.keys(balances)) {
    const newBalance = await balances[name][0].balanceOf(account);
    const diff = balances[name][1];
    if (diff._isBigNumber) {
      diff = diff.toString();
    }
    assert.equal(newBalance.toString(), intialBalances[name].add(diff).toString(), `balance of ${name} not expected`)
  }
  return result;
}

function toWei(number) {
  return BigNumber.from(number).mul("1000000000000000000");
}

function cubeRoot6(bigNum) {
  const DECIMALS_18 = BigNumber.from(1).mul("1000000000000000000");
  const a = bigNum.mul(DECIMALS_18);
  const base = BigNumber.from(2);
  const root = BigNumber.from(3);
  let tmp = a.add(base).div(root);
  let c = a;
  while (tmp.lt(c)) {
    c = tmp;
    const tmpSquare = tmp.mul(tmp);
    const numerator = a.div(tmpSquare).add(tmp.mul(base));
    tmp = numerator.div(root);
  }
  return c;
}

module.exports = {
  zeroAddress: '0x0000000000000000000000000000000000000000',
  emptyBytes: '0x',
  expectRevert,
  waitFor: (p) => p.then((tx) => tx.wait()),
  recurseTests,
  checERC20Balances,
  checERC1155Balances,
  mine: () => ethers.provider.send("evm_mine", []),
  getChainCurrentTime: () => Math.floor(Date.now() / 1000) + timeDelta,
  toWei,
  increaseTime,
  cubeRoot6
};
